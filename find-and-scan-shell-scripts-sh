#!/bin/bash -x
# find-and-scan-shell-scripts-sh
# Written in bash version 5.1 on Fedora 37


###  SECTION A  ###

# Implementation-dependent arguments for options parsable by `shellcheck`:
severity='error'
shells='(sh|bash|dash|ksh)'

# Process lock & environment variables
PATH="$( getconf PATH ):/usr/bin:/usr/sbin:${PATH}"
LC_ALL=C
lock_d=/tmp/scf.lock
trap 'if [[ -d "$lock_d" ]] && [[ ! -L "$lock_d" ]]; then sudo rm -rf -- "$lock_d"; fi; trap - EXIT TERM INT; kill -s INT "$$"' EXIT TERM INT
if mkdir -- "$lock_d"; then
  printf '\nSuccessfully acquired lock: %s\n\n' "$lock_d" 1>&2
else
  printf '\n\tCannot acquire lock: exiting.\n\n' 1>&2
  exit 2
fi

# Variables
fstype_regexp='(autofs|binfmt_misc|bpf|cgroup2|configfs|debugfs|devpts|devtmpfs|efivarfs|fusectl|fuse.portal|hugetlbfs|iso9660|mqueue|proc|pstore|rpc_pipefs|securityfs|selinuxfs|sysfs|tmpfs|tracefs)'
time="$( builtin printf '%(%F_%H%M%S)T' )"

#   : arrays
export \
  all_files \
  all_files_sorted \
  all_other_files \
  endian_wtf \
  files_from_outside_rpm \
  files_with_hashbang_comments \
  shell_scripts \
  system_files_from_outside_rpm \
  user_files

#   : variables
export \
  count \
  datadir \
  datafile \
  file \
  first_two_chars \
  fstype_regexp \
  i_1 \
  LC_ALL \
  line_1 \
  mountpoint \
  n0 \
  n7 \
  od_o \
  PATH \
  previous \
  relevant_search_dirs \
  severity \
  shells \
  time \
  timedir \
  X

# Functions
_bak(){ 
  local o
  for o in "$@"; do 
    # shellcheck disable=SC2002
    sudo cat "$o" |
      sudo tee --output-error='exit' "${o}.bak" > /dev/null 2>&1 ||
        _erx '_\bak' "$o"
  done
}
_create_datafile(){
  # Open a timestamped file & append into it the list of filenames and 
  # their crashbangs. 
    # <>
    set -x

  # datafiles
  data=( "$datafile" /tmp/"${datafile##*/}" )
  # if any data files already exist, keep them
  random="$RANDOM"
  wait -f
  for x in "${data[@]}"; do
    if [[ -f "$x" ]] && [[ ! -L "$x" ]]; then
      mv "$x" "${x}.p${$}.r${random}"
    fi
  done
  wait -f

  # create the original datafile
  touch "${data[@]}"
  wait -f

  # header
  printf '# crunchbangs -- %s \n' "$time" | 
    sudo tee --output-error='exit' "${data[@]}" > /dev/null 2>&1 ||
      _erx "${LINENO}"
  
  # content
  printf '%s\n' "${shell_scripts[@]}" |
    sudo tee --append --output-error='exit' "${data[@]}" \
        > /dev/null 2>&1 ||
      _erx "${LINENO}"
  _bak "${data[@]}"
}
_erx(){ 
  local ec="$?"
  echo Error: "$@" 
  exit "$ec"
}
_num(){ 
  local a
  for a in "$@"; do
    local -n array="$a" 
    echo "${#array[@]}"
  done
}
_scan_local_disks(){
  # Sort out the scripts, ie, any file beginning with a crashbang ('#!'), 
  # from the rest of the files.
  #   Note: this function can take 30-90 minutes!
  for i_1 in "${!all_files_sorted[@]}"; do

    printf '%d of %d files\r' "$i_1" "$count"
    unset file X od_o line_1 
    
      exit 101

    file="${all_files_sorted[${i_1}]}"

    ## file must exist
    #if [[ ! -e "$file" ]]; then
      #set -x
      #unset 'all_files_sorted[$i_1]'
      #continue
      #set -
    #fi

    # Bug, inordinately long interpreter paths are rare, but do occur.
    # Read from disk in binary the first two bytes of each file in 
    # the list and output it in hexadecimal.
    #   Note: POSIX `od` doesn't have GNU's '--strings' option, so use 
    # the `strings` command separately, if necessary.
    #   Note: `od` command is POSIX compliant
    # shellcheck disable=SC2034
    wait -f
    builtin read -r X od_o X < <( 
      sudo od -N2 -x "$file" || 
        _erx "$LINENO" "$i_1" "$file" )
    
    # If 'od_o' contains some non-zero data, as it should, 
    if [[ -z "$od_o" ]]; then
      _erx "$LINENO" "$i_1" "$file";

    # compare the hexidecimal representations to find any crashbangs.
    elif [[ "$od_o" == @(2321|2123) ]]; then

      # Issue: a big endian file format, possibly DB file? not very likely.
      if [[ "$od_o" == '2123' ]]; then
        endian_wtf+=( [$i_1]="$file" )
        unset 'all_files_sorted[$i_1]'
    
      # Use 'read', and hope there won't be any non-printable characters.
      else
        IFS= builtin read -r line_1 < "$file" ||
          _erx "$LINENO" "$i_1" "$file";

        # Issue: the files with '#!comment' as the initial bytes. 
        # These aren't scripts, so restart the loop.
        if [[ "$line_1" =~ ^'#!comment' ]]; then
          files_with_hashbang_comments+=( [${i_1}]="$file" )
          unset 'all_files_sorted[$i_1]'
          continue
        fi

        # Issue: crashbang files which originate outside of the rpm 
        # package manager
        if ! rpm -qf "$file" 2> /dev/null 1>&2; then

          # user and system files from outside rpm
          if [[ "$file" = /@(root|home|run/media)/* ]]; then
            user_files+=( [${i_1}]="$file" )
            unset 'all_files_sorted[$i_1]'
            continue
          else
            system_files_from_outside_rpm+=( [${i_1}]="$file" )
            unset 'all_files_sorted[$i_1]'
            continue
          fi
        fi
      fi

      # Make a record of the filenames and their crashbangs in RAM.
      shell_scripts+=( [$i_1]="$( \
        printf '%-50s   %% %% %% %%   %s\n' "$line_1" "$file" )" )
      unset 'all_files_sorted[$i_1]'

    else
      all_other_files+=( [$i_1]="$file" )
      unset 'all_files_sorted[$i_1]'
    fi
  done
}
_usage(){
  # Usage:  _usage [exit-code]
  cat <<-\EOF
    SCF - Shell Check Find, version 1.0 (redhat-linux)
    Find and scan shell scripts depending on severity level. 
        Usage:  ./find-and-scan-shell-scripts-sh [-ehiw]
                -e error          -i info
                -h help           -w warning
    Only the first option is processed.
EOF
  exit "${1}"
}
_write_arrays(){
  # Usage: _write_arrays [one target-dir] [arrays]
  # Default directory is "$timedir".
    # <>
    set -x

  local a d
  : 'is function-pos-parm number 1 a directory?'
  if sudo command test -d "$1"; then
    d="$1"
    shift
  fi

  for a in "$@"; do 
    local target_f
          target_f="${d:-"${timedir}"}/a_${a}"
    declare -p "$a" | 
      sudo tee --output-error='exit' "$target_f" > /dev/null 2>&1 ||
        _erx "_write_arrays $d $a"
    _bak "$target_f"
    unset -v target_f
  done
}
# Usage: _write_vars [section] [raw variable names]
_write_vars(){
  local section target_f
        section="$1"
        target_f="${timedir}/${section}_vars"
  shift
  declare -p "$@" 2> /dev/null |
    sudo tee --output-error='exit' "$target_f" > /dev/null 2>&1 ||
      _erx "_write_vars, section $section"
  _bak "$target_f"
}
#   : functions
export -f \
  _bak \
  _create_datafile \
  _erx \
  _num \
  _scan_local_disks \
  _usage \
  _write_arrays \
  _write_vars


# Option parsing
if [[ "${#}" -gt 0 ]]; then
  first_two_chars="${1:0:2}"
  case "${first_two_chars}" in
    --) printf '\n\tHappy Easter!\n\n'
          exit 0;;
    -e) severity='error';;
    -i) severity='info';;
    -w) severity='warning';;
    -h) _usage 0;;
    *)  _usage 1;;
  esac
fi


# Bug: you can't pipe anything to `df`
# sudo df --sync --local --output='fstype,avail,source' --block-size=1 -- $( sudo find /run/media -mindepth 2 -maxdepth 2 -type d ) | grep --extended-regexp --invert-match '^Type[[:space:]]*Avail'


# Create the data directories
if ! sudo -v; then
  printf '\n\tValidation failed of user\x27s \x60sudo\x60 timestamp; ' 
  printf 'exiting.\n\n' 
  exit 1
fi

#   In case of large log files, programatically select a save directory, 
# attached to the local disk, where any output can be saved; prefer USB 
# flash drives. This particular `df` command will output three alpha-
# numeric strings separated by whitespace on a single line. `sort` the 
# output by descending size. With `awk`, take the device with the most 
# available space and get its mountpoint with `findmnt`. If there is no 
# output, then set 'mountpoint' according to environment variables. 
mountpoint="$( 
  findmnt --canonicalize --output=target --noheadings "$( 
    sudo df --sync --local --output='fstype,avail,source' --block-size=1 | 
      grep --extended-regexp --invert-match '^Type[[:space:]]*Avail' | 
      grep --extended-regexp --invert-match -e ^"$fstype_regexp" \
        -e 'live-rw'$ | 
      sort --general-numeric-sort --reverse --key=2 | 
      awk 'NR == 1 { print $3 }'
  )"
)"

# BUG: needs a test for whether or not there are any unmounted USB drives. 
# automatically using '/' as mountpoint is, in this case, ie, on a live usb,
# not so good of an idea.

[[ -z "${mountpoint}" ]] &&
  mountpoint="${TEMPDIR:="${HOME}"}"
datadir="${mountpoint}/scf.d/latest_data"
metadir="${mountpoint}/scf.d/current_meta"
timedir="${datadir}/t_${time}"
datafile="${timedir}/crunchbangs"
#unlisted="${timedir}/unlisted"
umask 077

# test for whether the "$datadir" is writeable
if ! sudo mkdir "${mountpoint}/write-test"; then
  _erx "$LINENO"
else 
  sudo rm -fd "${mountpoint}/write-test"
fi

# make sure "$conf_d" is a directory OR create the "$conf_d" dir 
# if necessary
for conf_d in "$datadir" "$metadir"; do
  sudo command test -d "$conf_d" ||
    sudo mkdir --parents "$conf_d"
done

# Label the current data as "latest."
#   Note: `find` sees dirs and symlinks as separate things 
mapfile -d '' -t previous < <( 
  sudo find "${datadir}" -mindepth 1 -maxdepth 1 -type d -a \! -type l \
    -name 't_*' -print0 )

  declare -p previous

# if "$t_dir" is empty, then delete it; otherwise `mv` it out
# of the `latest` dir
for t_dir in "${previous[@]}"; do 
  sudo rmdir --ignore-fail-on-non-empty "$t_dir" 
  
  : 'of previous timedir' 
  #   Note: with `test`, dirs and symlinks can refer to the same inode
  if sudo command test -e "$t_dir" &&
    ! sudo command test -L "$t_dir"; 
  then
    sudo mv "${previous[@]}" /run/media/root/15_Mar_2023/scf.d #"${mountpoint}/scf.d/"
  else
    continue
  fi

    exit 101

done

: 'of current timedir'
if ! sudo command test -d "${timedir}"; then
  sudo mkdir "${timedir}" ||
    _erx "${LINENO}"
fi


  #exit 102

#set -o xtrace 
#exec 2>3 >&3
#sudo exec 3> "${timedir}"/xtrace.log
#exit 101
	

# Gather filenames from local attached disk storage, of files with 
# size not equal to 0 bytes.
# shellcheck disable=SC2034

rst_f="${metadir}/a_relevant_search_dirs"

if sudo command test -f "$rst_f" &&
  ! sudo command test -L "$rst_f"
then
  hash_1="$( sudo sha256sum "$rst_f" )"
  sudo rm -f "$rst_f" ||
    _erx "$LINENO"
fi

mapfile -d '' -t relevant_search_dirs < <(
  # DO NOT CHANGE THIS FIND COMMAND, or the repeat-search-test will fail
  sudo find / -mindepth 1 -maxdepth 1 -type d \! -empty \
    \( \! -name proc -a \! -name sys -a \! -iname 'scf*' \) -print0 )
_write_arrays "$metadir" relevant_search_dirs

# repeat search test (rst)
[[ -v hash_1 ]] &&
  hash_2="$( sha256sum "${metadir}/a_relevant_search_dirs" )"

# DEBUG: "${relevant_search_dirs[@]}" OR '/usr/sbin' OR /usr/{,s}bin
mapfile -d '' -t all_files < <( 
  # DO NOT CHANGE THIS FIND COMMAND, or the repeat-search-test will fail
  sudo find \
    "${relevant_search_dirs[@]}" \
      -type f \! -empty -print0 2> /dev/null )
    #/usr/sbin /usr/bin \
    #/usr/sbin \
    #"${relevant_search_dirs[@]}" \

  exit 103

# sort the original array with mapfile and test it
  # <>
  set -; printf 'printf \x24array\n'

mapfile -d '' -t    all_files_sorted < <(
  printf '%s\0'  "${all_files[@]}" |
    sort -z )

  # <>
  set -x; : 'set -x'
  
[[ "$( _num all_files )" -eq "$( _num all_files_sorted )" ]] ||
  _erx "${LINENO}"

  # <> ##############################################################
  _write_arrays all_files all_files_sorted
  _write_vars 'A' PATH LC_ALL severity shells fstype_regexp time \
    first_two_chars mountpoint datadir timedir datafile \
    previous relevant_search_dirs n0 n7

  #exit 101
  #set -x





###  SECTION B  ###
# Add some brevity, and write the completed arrays to disk
count="${#all_files_sorted[@]}"
unset IFS

# if the full list exists (of files on disk which begin with crash-
# bangs), then skip the 30-90 minute search phase.
if [[ ! -f /tmp/"${datafile##*/}" ]] || 
  [[ -L /tmp/"${datafile##*/}" ]]; 
then
  _scan_local_disks
  
    set -x

  _create_datafile

    set -

fi

  # <> ##############################################################
  _write_arrays shell_scripts files_with_hashbang_comments \
    files_from_outside_rpm all_other_files endian_wtf user_files \
    system_files_from_outside_rpm
  _write_vars 'B' file datafile i_1 od_o X line_1 count

  exit 101
  set -x




    
###  SECTION C  ###    

# Make the data readable and useable.

# Alterations

# Alteration 2: fix the odd extra data segments in the middles of the rows. 
# Requires using 'relevant_search_dirs' in the above `find` path. ## works
ere_2='>?[[:space:]]{3,}<?/?[[:alnum:]].*>?[[:space:]]{3,}<?'
# Bug? is opt -n necc?
_test_2(){
  sudo grep --extended-regexp --line-number "${ere_2}" "${1}" # ere_2
}
if _test_2 "$datafile"; then
  sudo sed --in-place "s=${ere_2}=    =g" "$datafile" # ere_2
  \_test_2 "$datafile" &&
    _erx "${LINENO}"
fi
command -p cp --archive "$datafile" "${datafile}_extra-data-removed"
_bak "${datafile}_extra-data-removed"

  # <>
  ls -l "${datafile}"*
  wc "${datafile}"*
  sudo sha256sum "${datafile}.bak" "${datafile}_extra-data-removed"
  
  exit 101
  set -x


# Bug: high disk io, slow

# Alteration 3: Apply grep-style line numbers, ie, in-file indices. These 
# are necessary for section 'Extra,' however, can only be applied prior 
# to the full list having been subdivided. 
grep --extended-regexp --line-number '.' "${datafile}" > \
  "${datafile}_all-indexed"
_bak "${datafile}_all-indexed"


# CENTRAL TASK, 1 OF 2: Filter the list of crashbangs with the list 
# of shells.
#ere_3=^'[0-9]{1,7}:#! ?(/usr)?/bin/(env|(sh|bash|dash|ksh)?) *<?(/usr)?(/bin/)?(sh|bash|dash|ksh) ?>? *'
# Bug likely: ere3
ere_3=^"[0-9]{1,7}:#! ?(/usr)?/bin/(env|${shells}?) *<?(/usr)?(/bin/)?${shells} ?>? *"

grep --extended-regexp "${ere_3}" "${datafile}_all-indexed" > \
  "${datafile}_SC-scrpts-list" # ere_3
_bak "${datafile}_SC-scrpts-list"

  # <>
  ls -l "${datafile}"*
  wc "${datafile}"*
  exit 101
  set -x



# MAIN TASK, 2 of 2: with ShellCheck scan each script for errors
for i_2 in "${!shell_scripts[@]}"; do 
  script="${shell_scripts[${i_2}]}"

  # Run `shellcheck on the script and count the number of each issue's ID.
  mapfile -t careful < <( 
    shellcheck --severity "$severity" "$script" || 
      _erx "$LINENO" )
  mapfile -t errs < <( 
    grep --fixed-strings --invert-match 'shellcheck.net' \
        <<< "${careful[@]}" | 
      grep --extended-regexp --only-matching 'SC[0-9]{4}' | 
      sort --general-numeric-sort | 
      uniq --count |
      sed 's,^[[:space:]]*,,g' || 
        _erx "$LINENO" )

  # Bug: formatting

  # If shellcheck found any issues, then open & append some 
  # prioritized work lists with indices
  if [[ -n "${errs[*]:0:1}" ]]; then 
		
    printf '<idx:%d>  %%  <%s>\n' "$i_2" "$script" >> \
      "${datafile}_found_scripts_with_indices"

    for each_error in "${errs[@]}"; do
      printf '%s %% <idx:%d>\n' "${each_error//$'\n'/}" "$i_2" >> \
        "${datafile}_found_errors_with_indices_unsorted"
    done
  fi
  unset errors script 'shell_scripts[$i_2]'
done

_bak "${datafile}_found_scripts_with_indices" \
  "${datafile}_found_errors_with_indices_unsorted"

exit 0

