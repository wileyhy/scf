#!/bin/bash
# find-and-scan-shell-scripts-sh
# Written in bash version 5.1
PATH='/usr/bin:/usr/sbin'


# Implementation-dependent arguments for options parseable by `shellcheck`:
shells='(sh|bash|dash|ksh)'
severity='error'


# Variables
time="$( builtin printf '%(%F_%H%M%S)T' )"
fstype_regexp='(binfmt_misc|bpf|cgroup2|configfs|debugfs|devpts|devtmpfs|efivarfs|fusectl|hugetlbfs|iso9660|mqueue|proc|pstore|rpc_pipefs|securityfs|selinuxfs|sysfs|tmpfs|tracefs)'

# Functions
# Usage: _bak [ File ] [ optional string ]
_bak(){
  string="${2:+_${2}}"
  tee --output-error=exit "${1}${string}"{,.bak} < "$1"
}
# Bug? so if this^ fn is exec'd on cli, it doesn't end sudo-i,
# but if script exec's, `exit` is exec'd?
_erx(){ 
  local ec=$?
  echo Error: "$@" 
  return $ec ||  
    exit $ec
}
_num(){ 
  local -n array="$1" 
  echo "${#array[@]}"
}
# Usage:  _usage [exit-code]
_usage(){
  cat <<-EOF
    SCF - Shell Check Find, version 1.0 (redhat-linux)
    Find and scan shell scripts depending on severity level. 
        Usage:  ./find-and-scan-shell-scripts-sh [-ehiw]
                -e error          -i info
                -h help           -w warning
        Only the first option is processed.
    SCF homepage: https://github.com/wileyhy/scf/
EOF
  exit "$1"
}

# Option parsing
if [[ "$#" -gt 0 ]]; then
  first_two_chars="${1:0:2}"
  case "$first_two_chars" in
    --) printf '\n\tHappy Easter!\n\n'
          exit 0;;
    -e) severity='error';;
    -i) severity='info';;
    -w) severity='warning';;
    -h) _usage 0;;
    *)  _usage 1;;
  esac
fi

  # <>
  #set -x


# Create the data directories
sudo -v

#   In case of large log files, programatically select a save directory, 
# attached to the local disk, where any output can be saved; prefer USB 
# flash drives. This particular `df` command will output three alpha-
# numeric strings separated by whitespace on a single line. Filter out 
# via regexp certain FS types and `sort` the output by descending size. 
# With `awk`, take the device with the most available space and get its 
# mountpoint with `findmnt`. If there is no output, then set 'mountpoint'
# according to environment variables. 
#   Note: such a complex command in shell saves ~75 lines of step by steps.
#   Bug? is '/run/media' portable to other current distros? 
mountpoint="$( 
  findmnt --canonicalize --output=target --noheadings "$( 
    find /run/media -mindepth 2 -maxdepth 2 -type d |
      df --sync --local --output='fstype,avail,source' --block-size=1 |
      grep --extended-regexp --invert-match '^Type[[:space:]]*Avail' |
      grep --extended-regexp --invert-match ^"$fstype_regexp" |
      sort --general-numeric-sort --reverse --key=2 |
      awk 'NR == 1 { print $3 }' 
  )"
)"
[[ -z "$mountpoint" ]] &&
  mountpoint="${TEMPDIR:="$HOME"}"
datadir="${mountpoint}/scf.d/latest"
datadir="$( realpath -e "$datadir" )"
timedir="${datadir}/t_${time}"
datafile="${timedir}/crunchbangs"
unlisted="${timedir}/unlisted"
umask 077

if [[ ! -d "$datadir" ]]; then
  sudo mkdir --parents "$datadir" ||
    _erx $LINENO
fi

# Label the current data as "latest."
mapfile -d '' -t previous < <( 
  find "$datadir" -mindepth 1 -maxdepth 1 -type d \
    -name "t_$( date +%Y )*" -print0 2> /dev/null )
if [[ -n "${previous[*]:0:1}" ]]; then
  sudo mv "${previous[@]}" "${mountpoint}/scf.d/" ||  
    _erx $LINENO
fi

if [[ ! -d "$timedir" ]]; then
  sudo mkdir --parents "$timedir" ||
    _erx $LINENO
fi

  # <>
  #exit 101
  #set -x

# Gather filenames from local attached disk storage.
# shellcheck disable=SC2034
mapfile -d '' -t relevant_search_dirs < <(
  find / -mindepth 1 -maxdepth 1 -type d \
    \( \! -name proc -a \! -name sys \) -print0 )

# DEBUG: "${relevant_search_dirs[@]}" OR '/usr/sbin' OR /usr/{,s}bin
mapfile -d '' -t all_files < <( 
  find '/usr/sbin' -type f -print0 2> /dev/null )

  # <>
  #declare -p all_files
  #exit 101
  set -x


# Sort out the scripts, ie, any file beginning with a '#!', from the
# rest of the files.
for i_1 in "${!all_files[@]}"; do
  unset crashbang od_o nextfile
  nextfile="${all_files[$i_1]}"

  # File must exist and have a size greater than zero.
  if [[ ! -s "$nextfile" ]]; then
    unset 'all_files[$i_1]'
    continue
  fi

  # Read from disk in binary the first two bytes of every remaining file in 
  # the list and output it in hexadecimal.
  mapfile -d '' -t od_o < <(  
    od --address-radix=x --read-bytes=2 --format=x2z "$nextfile" |
      tr --squeeze-repeats ' \n\t' '\0' )
			
  # If 'od_o' contains some non-zero data, as it should, compare the 
  # hexidecimal representations to find any crunchbangs.
  if [[ -z "${od_o[*]:0:1}" ]]; then
    _erx $LINENO
	
  elif
    [[ "${od_o[1]}" == '2123' ]]; then

    # When a hashbang's found, use `strings` to filter out any non-
    # printable data, to protect `head` from garbage input, and to 
    # get the full "shebang" string in ASCII. 
    #   Note: `strings` does not remove newlines.
    crashbang="$( strings --bytes=1 "$nextfile" |
      head --lines=1 )"

    # Make a record of the filenames and their '#!'s in RAM.
    shell_scripts+=( [$i_1]="$(
        printf '%s> \t\t\t <%s \n' "$crashbang" "$nextfile" )" )
    unset 'all_files[$i_1]'
  fi
done

# Open & append to a timestamped file the array of the filenames and 
# their '#!'s. 
printf '%s\n' "${shell_scripts[@]}" >> "$datafile" ||
      _erx $LINENO

  exit 101
  set -x


# Make the data readable and useable.

# Backup the original data file, and add some brevity.
# Note: most distros replace certain commands with aliases.c
f="$datafile"
_bak "$f" '.orig-bak'

# Alterations
ere_1='^#![[:space:]]{1,4}/'
ere_2='>?[[:space:]]{3,}<?/?[[:alnum:]].*>?[[:space:]]{3,}<?'
#ere_3=^'[0-9]{1,7}:#! ?(/usr)?/bin/(env|(sh|bash|dash|ksh)?) *<?(/usr)?(/bin/)?(sh|bash|dash|ksh) ?>? *'
# Bug likely: ere3
ere_3=^"[0-9]{1,7}:#! ?(/usr)?/bin/(env|${shells}?) *<?(/usr)?(/bin/)?${shells} ?>? *"

_test1(){
  grep --extended-regexp "$ere_1" "$1"
}
# Bug? is opt -n necc?
_test2(){
  grep --extended-regexp --line-number "$ere_2" "$1"
}

# Alteration 1: in the data file, fix the hashbangs that have spaces in
# them. ## works
_test1 "$f"
sed --extended-regexp --invert-match "s=${ere_1}=#\!/=g" "$f"
_test1 "$f"
_bak "$f" '_spcs-deld-fr-shbngs'

# Alteration 2: fix the odd extra data segments in the middles of the rows. 
# Requires using 'relevant_search_dirs' in the above `find` path. ## works
_test2 "$f"
sed --extended-regexp --invert-match "s=${ere_2}=    =g" "$f"
_test2 "$f"
_bak "$f" '_xtra-dta-rmvd'

  ls -l "$f"*
  wc "$f"*
  exit 101
  set -x

# Bug: high disk io, slow
# Alteration 3: Apply grep-style line numbers, ie, in-file indices. These 
# are necessary for section 'Extra,' however, can only be applied prior 
# to the full list having been subdivided. 
grep --extended-regexp --line-number '.' "$f" > "${f}_all-indexed"
_bak "${f}_all-indexed"


# CENTRAL TASK, 1 OF 2: Filter the list of crunchbangs with the list 
# of shells.
grep --extended-regexp "$ere_3" "${f}_all-indexed" > "${f}_SC-scrpts-list"
_bak "${f}_SC-scrpts-list"

  ls -l "$f"*
  wc "${f}"*
  exit 101
  set -x

Bug: _bak reqs some testing

# DEBUG: Invert the previous `grep` command, i.e.,
#   { NOT (sh|bash|dash|ksh) == (tclsh|zsh|tcsh) }
grep --extended-regexp --invert-match "$ere_3" "${f}_all-indexed" |
  sed --regexp-extended 's=[<>]=-----------------------------------------------------=g' |
  sed 's=[[:space:]]==g' |
  cut --characters -64 |
  grep -F 'sh' > "${f}_addl-shells"
_bak "$f" '_addl-shells'

  ls -l "$f"*
  cat "${f}_addl-shells"
  wc "$f"*


# EXTRA: get the list of files with '#!'s that aren't relevant shell scripts.
unset full_index shells_subindx verify_subindx

# Bug: sb?: =( {0.."$( wc --lines "${f}_all-indexed" )" )
# Extra, array 1: get the full set of indices as a contiguous array. The number of indices 
# in full_index should equal `wc --lines` of "${f}_all-indexed"
mapfile -t -O 1 full_index < <( 
  cut --delimiter=':' --fields=1 "${f}_all-indexed" )

# Bug? cut this codeblock?
if ! [[ "${#full_index[@]}" == "$( 
  wc --lines "${f}_all-indexed" | 
    cut --delimiter=' ' --fields=1 )" ]]
then
  _erx $LINENO
fi

  _num full_index
  declare -p full_index | 
    less --LINE-NUMBERS --RAW-CONTROL-CHARS

# Bug? Is printing indices really necc?

# Array 2: get the partial set of indices, i.e., ; a sparse array, which signify
# only the relevant scripts. number of indices in shells_subindx should equal
# `wc -l` of "${f}_SC-scrpts-list".
mapfile -t -O 1 shells_subindx < <( 
  cut '-d:' -f1 "${f}_SC-scrpts-list" )

if ! [[ "${#shells_subindx[@]}" == "$( 
  wc --lines "${f}_SC-scrpts-list" | 
    cut --delimiter=' ' --fields=1 )" ]]
then
  _erx $LINENO
fi

  declare -p shells_subindx | 
    less --LINE-NUMBERS --RAW-CONTROL-CHARS
  _num shells_subindx
  wc "${f}"*

# Array 3: partial set of indices for only *irrelevant* scripts; also 
# a sparse array.
unset f b verify_subindx shells_dup
shells_dup=( "${shells_subindx[@]}" )

for x in "${full_index[@]}"; do

  for b in "${!shells_subindx[@]}"; do

    if [[ $x -gt "${shells_subindx[$b]}" ]]; then
      unset 'shells_subindx[$b]'
      continue 1

    elif [[ $x = "${shells_subindx[$b]}" ]]; then
      continue 2

    else
      verify_subindx+=( "$x" )
      continue 2
    fi
  done
done

  declare -p full_index shells_dup verify_subindx | 
    less --LINE-NUMBERS --RAW-CONTROL-CHARS

# the counts should equal
if [[ $(( "$( 
  _num shells_dup )" + "$( 
    _num verify_subindx )" )) -eq "$( 
    _num full_index )" ]]
then
  _erx $LINENO
fi

# Bug: can sed do this loop in one fork?
for v in "${verify_subindx[@]}"; do
  sed --quiet "${v}p" "${f}_post-test2" >> "$unlisted"
done
_bak "${unlisted}.bak"


# MAIN TASK, 2 of 2: with ShellCheck scan each script for errors
for i_2 in "${!shell_scripts[@]}"; do 
  script="${shell_scripts[$i_2]}"

  mapfile -t errs < <( 
    shellcheck --severity "$severity" "$script" | 
      grep --fixed-strings --invert-match 'shellcheck.net' | 
      grep --extended-regexp --only-matching 'SC[0-9]{4}' | 
      sort --general-numeric-sort | 
      uniq --count |
      sed 's,^[[:space:]]*,,g' )

  # Bug: formatting

  # If shellcheck found any issues, then open & append some 
  # prioritized work lists with indices
  if [[ -n "${errs[*]:0:1}" ]]; then 
		
    printf '<idx:%d>  %%  <%s>\n' "$i_2" "$script" >> \
      "${f}_found_scripts_with_indices"

    for each_error in "${errs[@]}"; do
      printf '%s %% <idx:%d>\n' "${each_error//$'\n'/}" "$i_2" >> \
        "${f}_found_errors_with_indices_unsorted"
    done
  fi
  unset errors script 'shell_scripts[$i_2]'
done

_bak "${f}_found_scripts_with_indices"
_bak "${f}_found_errors_with_indices_unsorted"
