#!/bin/bash
# find-and-scan-shell-scripts-sh
# Written in bash version 5.1 on Fedora 37


###  SECTION A  ###

:;: 'Implementation-dependent arguments for opts parsable by -shellcheck-'
severity='error'
shells='(sh|bash|dash|ksh)'

:;: 'Environment variables'
PATH="$( /usr/bin/command -p getconf PATH ):/usr/bin:/usr/sbin:${PATH}"
LC_ALL=C.UTF-8
LC_COLLATE=C

:;: 'Use -sudo-'

  : '<>'
  date

if ! sudo -v; then
  # Bug: use hex encoded punctuation here
  printf '\n\tValidation failed of user-s -sudo- timestamp; ' 
  printf 'exiting.\n\n' 
  exit "$LINENO"
fi

:;: 'Process lock'

# Bug: all 3 poss file locs sb rmd
random_n="$RANDOM"
process_lock="${XDG_RUNTIME_DIR:-"${HOME:-/tmp}"}/.${$}.${random_n}.lock"
trap '
  if [[ -d "$process_lock" ]] && 
    [[ ! -L "$process_lock" ]]; 
  then 
    rm -rf -- "$process_lock"; 
  fi;
  
  # Good code, for final versions
  #if [[ -v acl_execd_setfacl ]]; then 
    #if [[ -v acl_abs_path ]]; then 
      #sudo setfacl -R -x u:"$UID" "$acl_abs_path" ||
        #echo Error: setfacl failed, line $LINENO
    #elif [[ -v mountpoint ]]; then
      #sudo setfacl -R -x u:"$UID" "$mountpoint" ||
        #echo Error: setfacl failed, line $LINENO
    #fi
  #fi

  trap - EXIT TERM INT; 
  kill -s INT "$$"
  ' EXIT TERM INT # for cleaner xtrace output, put on one line 

if ! mkdir "$process_lock" 2> /dev/null; then
  { printf '\n\tCannot acquire process lock: <%s>.\n' "$process_lock"
    printf '\tID: %s\n' "$USER"
    printf 'Exiting.\n\n' 
  } 1>&2
  exit "$LINENO"
fi

:;: 'User variables'
fstype_regex='(btrfs|exfat|ext3|ext4|fat32|ntfs|xfs)'
timecode="$( builtin printf '%(%F_%H%M%S)T' )"

## Variables, global scope
#export \
  #LC_ALL \
  #LC_COLLATE \
  #PATH \
  #all_files_index \
  #any_existing_f \
  #array_count_new_a \
  #array_count_new_b \
  #array_count_old_a \
  #array_count_old_b \
  #acl_abs_path \
  #byte_0 \
  #byte_1 \
  #byte_count \
  #cli_input \
  #curr_time_ssubd \
  #count \
  #data_subd \
  #device \
  #acl_each_dir \
  #each_sorted_f \
  #acl_execd_setfacl \
  #filesystem_type \
  #first_line \
  #fstype_regex \
  #hash_new_a \
  #hash_new_b \
  #hash_old_a \
  #hash_old_b \
  #iterator_1 \
  #iterator_2 \
  #leftover_words_a \
  #leftover_words_b \
  #list_crunchbangs \
  #list_dirs_search \
  #list_files_all \
  #main_d \
  #mountpoint \
  #mtime_age_in_hours \
  #must_find_all_files \
  #must_scan_relevant_dirs \
  #prev_time_ssubd \
  #process_lock \
  #random_n \
  #severity \
  #shells \
  #sorted_script \
  #subd_x \
  #timecode

# Variables, local scope
#export \
  #loc_aging_hash_new \
  #loc_aging_mtime \
  #loc_exit_code \
  #loc_filename_a \
  #loc_nameref \
  #loc_prevsly_aged \
  #loc_script_section_nm \
  #loc_unquotd_array_nm_a \
  #loc_unquotd_array_nm_b \
  #loc_write_f_a \
  #loc_write_f_b

# Arrays, global scope
#export \
  #a_acl_name_indiv_dir \
  #a_all_files \
  #a_all_files_sorted \
  #a_all_other_files \
  #a_crunches_with_hashbang_comments \
  #a_each_abspath_scriptnm \
  #a_each_script_list_sorted \
  #a_each_script_SC_results \
  #a_file_DNE \
  #a_incorrect_endianness \
  #a_non_rpm_system_crunches \
  #a_non_rpm_user_crunches \
  #a_poss_write_devices \
  #a_previous_time_dirs \
  #a_relevant_search_dirs \
  #a_shell_scripts \
  #a_write_path_nms

# Arrays, local scope
#export \
  #loc_A_hashes_prev_files \
  #loc_a_previous_aged_files

:;: 'Functions'
fn_age_file(){
  : 'fn_age_file' # JASON

    :;: '<>'
    [[ -f "$1" ]] ||
      return 1

  #local loc_a_previous_aged_files loc_prevsly_aged loc_aging_hash_new
  local -A loc_A_hashes_prev_files
  mapfile -d '' -t loc_a_previous_aged_files < <( 
    find "${1%/*}" -type f -regextype egrep \
      -regex ".*/${1##*/}\.([0-9]){10}" ) 

    #:;: '<>'
    #declare -p loc_a_previous_aged_files
    #exit "$LINENO"

  # if the new hash is already present in the assoc
  # array, then the new file is a dup
  for loc_prevsly_aged in "${loc_a_previous_aged_files[@]}"; do 
    
    if [[ -f "$loc_prevsly_aged" ]]; then
      
      loc_A_hashes_prev_files["$( 
        md5sum "$loc_prevsly_aged" | 
          cut -d ' ' -f1 )"]="$loc_prevsly_aged" 
      
      loc_aging_hash_new="$( 
        md5sum "$1" | 
          cut -d ' ' -f1 )"
      
      [[ -n "${loc_A_hashes_prev_files["$loc_aging_hash_new"]}" ]] && 
        : 'END OF fn_age_file';:
        return 0
    fi
  done

  #local loc_aging_mtime
  loc_aging_mtime="$( stat -c%Y "$1" )"
  mv "${1}" "${1}.${loc_aging_mtime}" ||
    fn_erx 'fn_age_file' "$1";
  #declare -p 'loc_A_hashes_prev_files' 'loc_prevsly_aged' \
    #'loc_aging_hash_new' 'loc_aging_mtime'
  : 'END OF fn_age_file';:
}
fn_bak(){ 
  : 'fn_bak'

    :;: '<>'
    [[ "$#" -eq 0 ]] &&
      return 1

  # test verifying existence of input -- sb unnec, except for debugging
  #local loc_filename_a
  for loc_filename_a in "$@"; do 
    if [[ ! -f "${loc_filename_a}" ]]; then 
      : "fn_bak: target file <${loc_filename_a}>> DNE"
      continue
    else 
      : 'fn_bak: target file exists'
    fi
    rsync -acq "${loc_filename_a}"{,.bak}
  done
  #declare -p 'loc_filename_a'
  : 'END OF fn_bak';:
}
fn_erx(){ 
  local loc_exit_code="$?" # this assignment must be the first command
  : 'fn_erx'
  echo -e Error: "$@" 
  : 'END OF fn_erx';:
  exit "$loc_exit_code"
}
fn_num(){ 
  : 'fn_num'
  #local loc_unquotd_array_nm_a
  for loc_unquotd_array_nm_a in "$@"; do
    local -n loc_nameref="$loc_unquotd_array_nm_a" 
    echo "${#loc_nameref[@]}"
  done
  #declare -p 'loc_unquotd_array_nm_a' >&2
  : 'END OF fn_num';:
}
fn_usage(){
  : 'fn_usage'
  # Usage:  fn_usage [exit-code]
  cat <<-\EOF
    SCF - Shell Check Find, version 1.0 (redhat-linux)
    Find and scan shell scripts depending on severity level. 
        Usage:  ./find-and-scan-shell-scripts-sh [-ehiw]
                -e error          -i info
                -h help           -w warning
    Only the first option is processed.
EOF
  exit "${1}"
  : 'END OF fn_usage';:
}
fn_write_arrays(){
  : 'fn_write_arrays'
  # Usage: fn_write_arrays [arrays]
  # 'Note: Default directory is -curr_time_ssubd-.'

  :;: 'fn_write_arrays: Write each array to disk.'
  #   Note: `tee` without '-a' will overwrite an existing file
  for loc_unquotd_array_nm_b in "$@"; do 
    #local loc_write_f_b
          loc_write_f_b="${curr_time_ssubd}/${loc_unquotd_array_nm_b}"
    [[ -e "$loc_write_f_b" ]] &&
      fn_age_file "$loc_write_f_b"
    declare -p "$loc_unquotd_array_nm_b" | 
      tee --output-error='exit' "$loc_write_f_b" > /dev/null 2>&1
    :; fn_bak "$loc_write_f_b"
    #unset loc_write_f_b
  done
  #declare -p 'loc_unquotd_array_nm_b' 'loc_write_f_b'
  : 'END OF fn_write_arrays';:
}
# Usage: fn_write_vars [loc_script_section_nm] [raw variable names]
fn_write_vars(){
  : 'fn_write_vars'
  #local loc_script_section_nm loc_write_f_a
        loc_script_section_nm="$1"
        loc_write_f_a="${curr_time_ssubd}/${loc_script_section_nm}_vars"
  shift
  [[ -e "$loc_write_f_a" ]] &&
    fn_age_file "$loc_write_f_a"
  declare -p "$@" 2> /dev/null |
    tee --output-error='exit' "$loc_write_f_a" > /dev/null 2>&1
  :; fn_bak "$loc_write_f_a"
  #declare -p 'loc_script_section_nm' 'loc_write_f_a' 
  : 'END OF fn_write_vars';:
}
#export -f \
  #fn_age_file \
  #fn_bak \
  #fn_erx \
  #fn_num \
  #fn_usage \
  #fn_write_arrays \
  #fn_write_vars


:;: 'Option parsing'
if [[ "$#" -gt 0 ]]; then
  cli_input="${1:0:2}"

  case "${cli_input}" in
    --) printf '\n\tHappy Easter!\n\n'
          exit "$LINENO";;
    -e) severity='error';;
    -i) severity='info';;
    -w) severity='warning';;
    -h) :; fn_usage 0;;
    *)  :; fn_usage 1;;
  esac
fi


:;: 'Assign varnames and paths for the data directories'

# BUG? `findmnt` has a '--df' option

#   Note: In case of large log files, programatically select a save di-
# rectory, attached to the local disk, where any output can be saved; 
# prefer USB flash drives. This particular `df` command will output three 
# alphanumeric strings separated by whitespace on a single line. `sort` the 
# output by descending size. With `awk`, take the device with the most 
# available space and get its mountpoint with `findmnt`. If there is no 
# output, then set 'mountpoint' according to environment variables. 
mapfile -t a_poss_write_devices < <( 
  sudo df --local --output='fstype,avail,source' --block-size=1 | grep --extended-regexp --invert-match '^Type[[:space:]]*Avail' | grep --extended-regexp -e ^"$fstype_regex" -e 'live-rw'$ | sort --general-numeric-sort --reverse --key=2 )
#export a_poss_write_devices

read -r filesystem_type leftover_words_a device < <( 
  printf '%s\n' "${a_poss_write_devices[@]}" | head -n 1 )
#unset leftover_words_a

mountpoint="$( 
  findmnt --canonicalize --output=target --noheadings "$device" )"

# BUG: needs a test for whether or not there are any unmounted USB drives. 
# automatically using '/' as mountpoint is, in this case, ie, on a live usb,
# not so good of an idea.

[[ -z "${mountpoint}" ]] &&
  mountpoint="${process_lock:-"${TMPDIR:-/tmp}"}"
main_d="${mountpoint}/scf.d"
data_subd="${main_d}/latest_data"
curr_time_ssubd="${data_subd}/t_${timecode}"
list_crunchbangs="${curr_time_ssubd}/crunchbangs"
umask 077

:;: 'reduce use of -sudo- in this script by setting up ACL-s'
case "$filesystem_type" in
  'xfs')      true;;
  ext[2-4])   tune2fs -l "$device" | 
                grep -i 'acl'
              fn_erx "$LINENO" TODO;;
  *)          fn_erx "$LINENO" TODO;;
esac
  
:;: 'on XFS'

# Nearly all of the `sudo` commands below are allowing rw access, of  
# this script's data_subd, so simply using ACL's will reduce the overuse 
# of `sudo`. This section takes the "$mountpoint" variable, portions
# each subdirectory name into an array index, and tests each subdi-
# rectory from the FS root up for readability by the user running
# this script (ie, a regular user). As the absolute path is recon-
# structed, when a non-readable directory is found, a recursive "r-x" 
# ACL is written, and then a recursive "rwx" is written for the 
# "$main_d". 
if [[ ! -r "$main_d" ]]; then
  mapfile -d '/' -t a_acl_name_indiv_dir <<< "${mountpoint}"; 
  #export a_acl_name_indiv_dir
  a_acl_name_indiv_dir[0]='/'
  a_acl_name_indiv_dir[-1]="${a_acl_name_indiv_dir[-1]//$'\n'}"
  acl_each_dir=${#a_acl_name_indiv_dir[@]}; 
  for (( iterator_1 = 0 ; iterator_1 < acl_each_dir ; iterator_1++ )); do 
    acl_abs_path+="/${a_acl_name_indiv_dir[$iterator_1]}"; 
    acl_abs_path="$( realpath -e "$acl_abs_path" )"; 
    if [[ ! -r "$acl_abs_path" ]]; then 
      sudo mkdir --parents "$main_d" ||
        fn_erx "$LINENO"
      acl_execd_setfacl='y'
      #export acl_execd_setfacl
      sudo setfacl -R -m "$USER":r-x "$acl_abs_path" || 
        break
      sudo setfacl -R -m "$USER":rwx "${main_d%/*}" || 
        { : 'setfacl failed'
          break 
        }
      : 'setfacl succeeded'
      break
    fi ; 
  done; 
fi

:;: 'make sure -data_subd- is a directory OR create the -data_subd- dir '
: 'if necessary'
#for subd_x in "$data_subd" "$meta_subd"; do
  #[[ -d "$subd_x" ]] ||
    #mkdir "$subd_x" 
#done
[[ -d "$data_subd" ]] ||
  mkdir "$data_subd"

:;: 'Label the current data as -latest.-'
#   Note: `find` sees dirs and symlinks as separate things 
mapfile -d '' -t a_previous_time_dirs < <( 
  find "${data_subd}" -mindepth 1 -maxdepth 1 -type d -a \! -type l \
    -name 't_*' -print0 )
#export a_previous_time_dirs

:;: 'if -prev_time_ssubd- is empty, then delete it; otherwise -mv- it out'
:   ' of the -latest- dir'
for prev_time_ssubd in "${a_previous_time_dirs[@]}"; do 
  if rmdir --ignore-fail-on-non-empty "$prev_time_ssubd"; then
    : '-rmdir- succeeded'
  else
    : '-rmdir- failed'
  fi
  
    : '<>'
    test ! -e "$prev_time_ssubd" &&
      : 'prev_time_ssubd DNE' 

  : 'of previous prev_time_ssubd' 
  #   Note: with `test`, dirs and symlinks can refer to the same inode
  if [[ -e "$prev_time_ssubd" ]] &&
    [[ ! -L "$prev_time_ssubd" ]]; 
  then
    mv "${a_previous_time_dirs[@]}" "$main_d"
  else
    continue
  fi
done

: 'of curr_time_ssubd'
if [[ ! -d "${curr_time_ssubd}" ]]; then
  mkdir "${curr_time_ssubd}" ||
    fn_erx "${LINENO}"
fi

  # <> 
  :; fn_write_vars \
    'A' \
    LC_ALL \
    LC_COLLATE \
    PATH \
    acl_abs_path \
    acl_each_dir \
    acl_execd_setfacl \
    cli_input \
    curr_time_ssubd \
    data_subd \
    device \
    filesystem_type \
    fstype_regex \
    leftover_words_a \
    list_crunchbangs \
    main_d \
    mountpoint \
    prev_time_ssubd \
    process_lock \
    random_n \
    severity \
    shells \
    subd_x \
    timecode
  :; fn_write_arrays \
    a_acl_name_indiv_dir \
    a_poss_write_devices \
    a_previous_time_dirs
  #:; {
    #declare -fp \
 	    #fn_erx \
 	    #fn_usage; 
    #} | tee "${curr_time_ssubd}/A_functions"
  #exit "$LINENO"
  set -x


###  section  b  ###
# BUG:  Reduce Search Time  ==  RST

:;: 'Gather filenames from local attached disk storage'

# If a prior record of the a_relevant_search_dirs array exists, and 
# if that prior record matches the new record, then it's possible the 
# a_all_files list would be the same, too. So if the new relevant_\
# search_dirs list is new, then do the full a_all_files search again.
# But if they're the same, then ...

:;: 'Variables for -a_relevant_search_dirs-'
#array='a_relevant_search_dirs'
list_dirs_search="${curr_time_ssubd}/a_relevant_search_dirs" 

:;: 'if the a_relevant_search_dirs record file exists and is not a symlink'
if [[ -f "$list_dirs_search" ]] &&
  [[ ! -L "$list_dirs_search" ]];
then

  :;: 'Keep existing data'
  :; fn_age_file "${list_dirs_search}".bak
  :; fn_bak "$list_dirs_search"

  :;: 'For whether or not to do the full scan of a_relevant_search_dirs'
    : 'get the hash of the prior array'
    hash_old_a="$( md5sum "$list_dirs_search" )"

    :;: 'get the prior count of indices'
    # shellcheck disable=SC1090
    source "$list_dirs_search"
    array_count_old_a="$( fn_num a_relevant_search_dirs )"
    #unset a_relevant_search_dirs
fi

:;: 'in any event, create a new record for a_relevant_search_dirs and...'
mapfile -d '' -t a_relevant_search_dirs < <(
  sudo find / -mindepth 1 -maxdepth 1 -type d \! -empty \( \! -name proc -a \! -name sys -a \! -iname 'scf*' \) -print0 )
#export a_relevant_search_dirs
:; fn_write_arrays a_relevant_search_dirs

:;: 'if the pre-processing block ran, then exec this block also'
if [[ -v array_count_old_a ]]; then 
  : '<>: variable -array_count_old_a- exists'

  :;: 'these newer files were written just milliseconds ago'
  :; fn_age_file "${list_dirs_search}".bak
  :; fn_bak "$list_dirs_search"

  :;: 'For whether or not to run -find- for the a_all_files array'
    : 'get the hash of the new array' 
    hash_new_a="$( md5sum "$list_dirs_search" )"

    :;: 'get the new count of indices, and do some comparisons'
    array_count_new_a="$( fn_num a_relevant_search_dirs )"

    if [[ "${hash_old_a%% *}" != "${hash_new_a%% *}" ]] ||
      [[ "$array_count_old_a" != "$array_count_new_a" ]]; 
    then 
      must_find_all_files='y'
    fi
fi
  
:;: 'Variables for -a_all_files-'
#unset array list_files_all hash_old_b hash_new_b array_count_old_b array_count_new_b
#array='a_all_files'
list_files_all="${curr_time_ssubd}/a_all_files"

:;: 'if the record for a_all_files exists and isnt a symlink'
if [[ -f "$list_files_all" ]] &&
  [[ ! -L "$list_files_all" ]];
then

  :;: 'Keep existing data'
  :; fn_age_file "${list_files_all}".bak
  :; fn_bak "$list_files_all"

  :;: 'For whether or not to do the full scan of a_relevant_search_dirs'
    : 'get the hash of the prior array'
    hash_old_b="$( md5sum "$list_files_all" )"

    :;: 'get the prior count of indices'
    : 'set -; source -list_files_all-'; 
    set -
    source "$list_files_all"
    set -x
    array_count_old_b="$( fn_num a_all_files )"
    #unset a_all_files

  :;: 'For whether or not to run -find- for the a_all_files array'
  if [[ "$must_find_all_files" != 'y' ]]; then

    :;: 'get byte count of record file'
    byte_count="$( wc -c "$list_files_all" )"
    [[ "${byte_count%% *}" -lt 500 ]] && 
      must_find_all_files='y'

    :;: 'get delta of mtime to now'
    mtime_age_in_hours=$(( $(( $( date +%s ) - \
      $( stat -c%Y "$list_files_all" ) )) / 60 / 60 ))
    [[ "$mtime_age_in_hours" -gt 72 ]] &&
      must_find_all_files='y'
  fi
fi

:;: 'If we must run -find- for a_all_files.'
if [[ ! -v a_all_files ]] ||
  [[ "$must_find_all_files" = 'y' ]]; 
then
  
    : '<>'
    date
    #a_relevant_search_dirs=( /usr/sbin )
    a_relevant_search_dirs=( /usr/sbin /usr/bin )
    #a_relevant_search_dirs=( /usr/sbin /usr/bin /etc )
    #a_relevant_search_dirs=( /usr/sbin /usr/bin /etc /var )
  
  :;: 'Find all relevant files on disk.'
  mapfile -d '' -t a_all_files < <( 
    sudo find "${a_relevant_search_dirs[@]}" -mindepth 1 -type f -print0 \
      2> /dev/null )
  #export a_all_files 
  :; fn_write_arrays a_all_files
  
  :;: 'these newer files were written just milliseconds ago'
  :; fn_age_file "${list_files_all}".bak # AJAX
  :; fn_bak "$list_files_all"
fi

:;: 'For whether or not to do the full scan for a_all_files'
if [[ -v hash_old_b ]]; then
  : '<>: variable -hash_old_b- exists'

  :;: 'get the hash of the new array'
  hash_new_b="$( md5sum "$list_files_all" )"

  :;: 'get the prior count of indices; this array was re-assigned'
  : 'a few milliseconds ago'
  array_count_new_b="$( fn_num a_all_files )"

  :;: 'Do the comparisons' 
  if [[ "${hash_old_b%% *}" != "${hash_new_b%% *}" ]] ||
    [[ "$array_count_old_b" != "$array_count_new_b" ]]; 
  then 
    
    # BUG: as of yet unused variable
    
    must_scan_relevant_dirs='y'
  fi
fi

:;: 'Sort the original array and test it.'
  : '<>'
  set -; 

printf 'printf -a_all_files_sorted- array\n'
mapfile -d '' -t a_all_files_sorted < <(
  printf '%s\0' "${a_all_files[@]}" |
    sort --zero-terminated )

  : '<>'
  set -x; 
  : 'set -x'

:;: 'Do the second comparison.' 
[[ "$( fn_num a_all_files )" -eq "$( fn_num a_all_files_sorted )" ]] ||
  fn_erx "${LINENO}"

  # <> 
  :; fn_write_vars \
    'B' \
        array_count_new_a \
        array_count_new_b \
        array_count_old_a \
        array_count_old_b \
        byte_count \
        hash_new_a \
        hash_new_b \
        hash_old_a \
        hash_old_b \
    list_dirs_search \
    list_files_all \
        mtime_age_in_hours \
        must_find_all_files

  :; fn_write_arrays \
    a_all_files \
    a_all_files_sorted \
    a_relevant_search_dirs

  #: '<>'
  exit "$LINENO"
  #set -x


###  SECTION c  ::  SCANNING  ###

# Bug? Can more indices and fewer files be used?

:;: 'Add some brevity, and write the completed arrays to disk'
count="${#a_all_files_sorted[@]}"
unset IFS

:;: 'if the full list exists (of files on disk which begin with crash-'
:   ' bangs), then skip the 30-90 minute search phase.'
if [[ ! -f /tmp/"${list_crunchbangs##*/}" ]] || 
  [[ -L /tmp/"${list_crunchbangs##*/}" ]]; 
then
  
#fn_scan_local_disks(){
  #: 'fn_scan_local_disks'
  :;: 'fn_scan_local_disks: Sort out the scripts, ie, any file beginning' 
  :   'with a crashbang from the rest of the files'
  #   Note: this function can take 30-90 minutes!
  for all_files_index in "${!a_all_files_sorted[@]}"; do

    :;: 'fn_scan_local_disks: LOOP';:
    printf '%d of %d files\r' "$all_files_index" "$count"
    #unset each_sorted_f leftover_words_b od_o{0,1} first_line 
    each_sorted_f="${a_all_files_sorted[${all_files_index}]}"
    
    # BUG: the arrays and vars are messy; clean up the lists.

    :;: 'fn_scan_local_disks: each_sorted_f must exist'
    if [[ ! -e "$each_sorted_f" ]]; then
      set -x
      a_file_DNE+=( "$each_sorted_f" )
      #unset 'a_all_files_sorted[$all_files_index]'
      continue
      set -
    fi

    # TODO: check for empty files, make a list of them

    :;: 'fn_scan_local_disks: run -file- on each each_sorted_f'
    { 
      printf '+ %-8d: ' "$all_files_index"; 
      sudo file -pk "$each_sorted_f";
    } | 
      tee -a "${curr_time_ssubd}/file_out"
 
      # Bug: avoid as many disk writes as possible. 
      # Bug: use indices to reference each type? 
      #    RO all files array? 

    :;: 'fn_scan_local_disks: Read from disk in binary the first two bytes' 
    :   'of each each_sorted_f in the list and output it in hexadecimal.'
    #   Note: inordinately long interpreter paths are rare, but do occur.
    #   Note: `od` command is POSIX compliant
    read -r leftover_words_b byte_0 byte_1 leftover_words_b < <( 
      sudo od -j 0 -N 2 -t x1z -v "$each_sorted_f" || 
        fn_erx "$LINENO" "$all_files_index" "$each_sorted_f" )
    #unset leftover_words_b
    
    :;: 'fn_scan_local_disks: If -od_o- contains some non-zero data, as it'
    :   ' should,'
    if [[ -z "$byte_0" ]]; then
      fn_erx "L:$LINENO I:$all_files_index <${each_sorted_f}>" '*theoretically unreachable code*';

    :;: 'fn_scan_local_disks: compare the hexidecimal representations to' 
    :   'find any crashbangs.'
    elif [[ "${byte_0}${byte_1}" == @(2321|2123) ]]; then

      :;: 'fn_scan_local_disks: Issue: a big endian file format, possibly'
      :   ' a DB file, etc.'
      if [[ "${byte_0}${byte_1}" == '2123' ]]; then
        a_incorrect_endianness+=( [$all_files_index]="$each_sorted_f" )
        #unset 'a_all_files_sorted[$all_files_index]'

      # BUG: expect non-printable characters

      :;: 'fn_scan_local_disks: Crunchbang found. Use -read-, and hope'
      :   'there won`t be any non-printable characters.'
      else
        IFS= read -r first_line < "$each_sorted_f" ||
          fn_erx "$LINENO" "$all_files_index" "$each_sorted_f";

        :;: 'fn_scan_local_disks: Issue: the files with -#!comment- as the'
        :   'initial bytes. These aren-t scripts, so restart the loop.'
        if [[ "$first_line" =~ ^'#!comment' ]]; then
          a_crunches_with_hashbang_comments+=( [${all_files_index}]="$each_sorted_f" )
          #unset 'a_all_files_sorted[$all_files_index]'
          continue
        fi

        :;: 'fn_scan_local_disks: Issue: crashbang files which originate'
        :   'outside of the rpm package manager'
        #   Note: with only /bin/sbin, this if-fi block doesn't execute
        if ! rpm -qf "$each_sorted_f" 2> /dev/null 1>&2; then

          :;: 'fn_scan_local_disks: user and system files from outside -rpm-'
          if [[ "$each_sorted_f" = /@(root|home|run/media)/* ]]; then
            a_non_rpm_user_crunches+=( [${all_files_index}]="$each_sorted_f" )
            #unset 'a_all_files_sorted[$all_files_index]'
            continue

          else
            a_non_rpm_system_crunches+=( [${all_files_index}]="$each_sorted_f" )
            #unset 'a_all_files_sorted[$all_files_index]'
            continue
          fi
        fi
      fi
      
      :;: 'fn_scan_local_disks: Make a record in RAM of the relevant'
      :   'filenames and their crashbangs.'
      a_shell_scripts+=( [$all_files_index]="$( \
        printf '%-50s   %% %% %% %%   %s\n' "$first_line" "$each_sorted_f" )" )
      #unset 'a_all_files_sorted[$all_files_index]'

    else
      a_all_other_files+=( [$all_files_index]="$each_sorted_f" )
      #unset 'a_all_files_sorted[$all_files_index]'
    fi
  done
  :; fn_bak "${curr_time_ssubd}"/{file,stat}_out
  #: 'END OF fn_scan_local_disks';:
#}
  #:; fn_scan_local_disks

#fn_createdatafile(){
  #: 'fn_createdatafile'
  :;: 'fn_createdatafile: Open a timestamped file & append into it the list' 
  :   ' of filenames and their crashbangs.' 

  :;: 'fn_createdatafile: data files'
  a_write_path_nms=( "${list_crunchbangs:=crunchbangs}" /tmp/"${list_crunchbangs##*/}" )
  
  :;: 'fn_createdatafile: if any data files already exist, keep them'
  for any_existing_f in "${a_write_path_nms[@]}"; do
    if [[ -f "$any_existing_f" ]] && [[ ! -L "$any_existing_f" ]]; then
      mv "$any_existing_f" "${any_existing_f}.${$}.${random_n}" ||
        fn_erx "$LINENO"
    fi
  done

  :;: 'fn_createdatafile: create the original list_crunchbangs'
  touch "${a_write_path_nms[@]}"

  :;: 'fn_createdatafile: header'
  printf '# crunchbangs -- %s \n' "$timecode" | 
    tee --output-error='exit' "${a_write_path_nms[@]}" > /dev/null 2>&1
  
  :;: 'fn_createdatafile: printing contents of a_shell_scripts array'
  set -
  printf '%s\n' "${a_shell_scripts[@]}" |
    tee --append --output-error='exit' "${a_write_path_nms[@]}" > /dev/null 2>&1
  set -x
  :; fn_bak "${a_write_path_nms[@]}"
  #: 'END OF fn_createdatafile';:
#}
  #:; fn_createdatafile
fi

  # <>
  :; fn_write_arrays a_shell_scripts a_crunches_with_hashbang_comments \
    a_all_other_files a_incorrect_endianness \
    a_non_rpm_system_crunches a_non_rpm_user_crunches 
  :; fn_write_vars 'B' each_sorted_f list_crunchbangs all_files_index od_o{0,1} X first_line count

  : '<>'
  exit "$LINENO"
  #set -x

    
###  SECTION d  ###    

# Make the data readable and useable.

:;: 'CENTRAL TASK, 1 OF 2: Filter the list of crashbangs with the list' 
:   '  of shells.'
grep --extended-regexp '/bin/'"${shells}"'.*% % % %' \
  "${list_crunchbangs}" > "${list_crunchbangs}_SC-scrpts-list" ||
    fn_erx "$LINENO"
:; fn_bak "${list_crunchbangs}_SC-scrpts-list"
rsync -ca "${list_crunchbangs}_SC-scrpts-list" /tmp ||
  fn_erx "$LINENO"

  : '<>'
  ls -l "${list_crunchbangs}"*
  wc "${list_crunchbangs}"*
  exit "$LINENO"
  #set -x

:;: 'MAIN TASK, 2 of 2: with ShellCheck scan each script for errors'
  
:;: 'A hell world of pipelines:'
# Bug? line 1 of script could contain percent symbols
mapfile -d '' -t a_each_abspath_scriptnm < <( 
  cut -d '%' -f5- "${list_crunchbangs}_SC-scrpts-list" | 
    sed 's,^ *,,' | 
    tr '\n' '\0' )
  # awk , multi-char delim, remv lead+trail wspc - redef $0 ?, printf
  # grep -Eo | tr

  : '<>'
  exit "$LINENO"
  set -x

# why sort by line count? More text, more bugs? How to prior mult factrs
mapfile -t a_each_script_list_sorted < <( 
  for c in "${a_each_abspath_scriptnm[@]}"; do 
    wc -l "$c"; 
  done | 
    sort -gr | 
    awk '{ print $2 }' )

  : '<>'
  exit "$LINENO"
  set -x

iterator_2=0; 
{
  for sorted_script in "${!a_each_script_list_sorted[@]}"; do 
    #unset a_each_script_SC_results;
    # Bug? 1st grep extra?
    mapfile -d '' -t a_each_script_SC_results < <( 
      shellcheck -S error "${a_each_script_list_sorted[$sorted_script]}" | 
        grep --fixed-strings --invert-match 'shellcheck.net' | 
        grep --extended-regexp -o "SC[0-9a-zA-Z\ \t():,.'-$&#\!]*" | 
        cut -b -64 | 
        sort --general-numeric-sort | 
        uniq --count ; printf '\0' ); 
    if [[ -n "${a_each_script_SC_results[*]:0:1}" ]]; then 
      printf '\n%-4d%s\n' $((iterator_2++)) "${a_each_script_list_sorted[$sorted_script]}"; 
      printf '%s' "${a_each_script_SC_results[@]}"; 
    fi; 
  done;
} | tee -a "${list_crunchbangs}_found_scripts_with_indices"

  : '<>'
  exit "$LINENO"
  set -x

:; fn_bak "${list_crunchbangs}_found_scripts_with_indices"

:;: 'Write semi-permanent archives'
rsync -ca "${list_crunchbangs}_found_scripts_with_indices" "$main_d" ||
  fn_erx "$LINENO"
rsync -ca "${list_crunchbangs}_found_scripts_with_indices" /tmp ||
  fn_erx "$LINENO"

exit "$LINENO"


# scan 'a_all_other_files' for anything that isn't an ELF file
# . /run/media/*/*/scf.d/latest_data/t_*/a_all_other_files
# for f in "${a_all_other_files[@]}"; do sudo file -pk "$f" | grep -v 'ELF 64-bit LSB '; done

# scan 'a_all_files_sorted' for proper sorting
# . /run/media/*/*/scf.d/latest_data/t_*/a_all_files_sorted
# fn_num a_all_files_sorted
# sudo command -p printf '' | sudo tee ./a_all_files_sorted_printed; for g in "${a_all_files_sorted[@]}"; do sudo -p command printf '%s\n' "$g" | sudo tee -a ./a_all_files_sorted_printed ; done

# check 'file_out' for anything odd
# grep -v 'ELF 64-bit' ./scf.d/latest_data/t_2023-04-03_084130/file_out | grep 'read permission'
# grep -v 'ELF 64-bit' ./scf.d/latest_data/t_2023-04-03_084130/file_out | grep -v 'read permission' | grep -v 'script text exec'

# 
