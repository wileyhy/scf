#!/bin/bash
# find-and-scan-shell-scripts-sh
# Written in bash version 5.1


# Implementation-dependent arguments for options parseable by `shellcheck`.
shells='(sh|bash|dash|ksh)'
severity='error'

# Variables
time="$( builtin printf '%(%F_%H%M%S)T' )"
mountpoint="${TEMPDIR:="$HOME"}"
regex='(binfmt_misc|bpf|cgroup2|configfs|debugfs|devpts|devtmpfs|efivarfs|fusectl|hugetlbfs|iso9660|mqueue|proc|pstore|rpc_pipefs|securityfs|selinuxfs|sysfs|tmpfs|tracefs)'

# Functions
_erx(){ 
  local ec=$?; 
  echo Error: "$@"; 
  return $ec ||  
    exit $ec; 
}

_num(){ 
  local -n array="$1"; 
  echo "${#array[@]}"; 
}

# Usage:  _usage [exit-code]
_usage(){
  cat <<-EOF
    SCF - Shell Check Find, version 1.0 (redhat-linux)
    Find and scan shell scripts depending on severity level. 
        Usage:  ./find-and-scan-shell-scripts-sh [-ehiw]
                -e error          -i info
                -h help           -w warning
        Only the first option is processed.
    SCF homepage: https://github.com/wileyhy/scf/
  EOF
  exit "$1"
}

# Option parsing
# TODO: parse '--other-language=python', perl, etc
if [[ "$#" -gt 0 ]]; then
  first_two_chars="${1:0:2}"
  case "$first_two_chars" in
    --) printf '\n\tHappy Easter!\n\n';
          exit 0;;
    -e) severity='error';;
    -i) severity='info';;
    -w) severity='warning';;
    -h) _usage 0;;
    *)  _usage 1;;
  esac
fi

# Programatically select a save directory, attached 
# to the local disk, where any output can be
# saved; prefer USB flash drives. This particular `df` command 
# will output three alphanumeric strings separated by whitespace 
# on a single line.
#   Bug? is '/run/media' portable to other distros? 
mapfile -d '' -t save_dirs < <(  
  find /run/media -mindepth 2 -maxdepth 2 -type d -print0 )
save_dirs+=( ~ /tmp /var/tmp )

mapfile -t df_o < <(  
  df --sync -l --output=fstype,avail,source --block-size=1 | 
    grep -Ev '^Type[[:space:]]*Avail' )


# filter out via regex certain FS types by sorting the output of `df`
for o in "${!df_o[@]}"; do
  if [[ "${df_o[$o]}" =~ ^$regex ]]; then
    unset 'df_o[$o]';
  fi;
done


# In case of large log files, of the remaining 'save_dirs' take the 
# device with the most available space and get its mountpoint. 
# If there are no 'save_dirs' left then leave 'mountpoint' set as above. 
device="$( printf '%s\n' "${df_o[@]}" | 
  sort --general-numeric-sort --reverse --key=2 | 
  awk 'NR == 1 { print $3 }' )"
mountpoint="$( mount | 
  awk "\$1 ~ /${device##*/}/ "'{ print $3 }' )"
datadir="${mountpoint}/.scf.d"
datafile="${datadir}/${time}_crunchbangs"
unlisted="${datafile/crunchbangs/unlisted}"

# Create the data directory
if [[ ! -d "$datadir" ]]; then
  mkdir "$datadir" ||
    _erx $LINENO
fi

# Gather filenames from local attached disk storage
mapfile -d '' -t relevant_search_dirs < <(
  find / -mindepth 1 -maxdepth 1 -type d \
    \( \! -name proc -a \! -name sys -a \! \
    -name git \) -print0 )

# DEBUG: "${relevant_search_dirs[@]}" OR '/usr/sbin'
mapfile -d '' -t all_files < <( 
  find "${relevant_search_dirs[@]}" -type f -print0 2> /dev/null )

# get files that are shell scripts that ShellCheck can parse

# sort out the scripts, ie, any file beginning with a '#!',
# from the rest of the files.
for i_1 in "${!all_files[@]}"; do
  unset two_bits hexes nextfile extension
  nextfile="${all_files[$i_1]}"

  
  # filter 1: file must exist and have a size greater than zero
  if [[ ! -s "$nextfile" ]]; then
    unset 'all_files[$i1]'
    continue
  fi

  # read from disk in binary the first two bytes of every file left in 
  # the list, and format it in hexadecimal.
  mapfile -d '' -t hexes < <(  
    od --address-radix=x --read-bytes=2 --format=x "$nextfile" |
      tr --squeeze-repeats ' \n\t' '\0' )
			
  # compare the hexidecimal representations to find any crunchbangs
  if [[ "${hexes[1]}" == '2123' ]]; then
 
    # when a crashbang's found, use `strings` to filter out any non-
    # printable data, to protect `head` from garbage input, and to 
    # get the full shebang string in ASCII.
    two_bits="$( strings -n 1 "$nextfile" |
      head -n 1 |
      head -c 32 )";

    # make a record of the filenames and their 
    # crunchbangs, ie, open & append to a timestamped file
    printf '%s \t\t\t %s \n' "$crunchbangs" "$nextfile" >> \
      "${mountpoint}/${time}_crunches"; 
    unset 'all_files[$i]'
  fi; 
done

# array 'shell_scripts' must exist
[[ -n "${shell_scripts[*]:0:1}" ]] || 
  exit 3

# with ShellCheck scan each script for errors
for i2 in "${!shell_scripts[@]}"; do 
  script="${shell_scripts[$i2]}"

  mapfile -t errs < <( 
    shellcheck -S "$severity" "$script" | 
      grep -vFe 'shellcheck.net' | 
      grep --color=never -Eo 'SC[0-9]{4}' | 
      sort -g | 
      uniq -c |
      sed 's,^[[:space:]]*,,g' )

  if [[ -n "${errs[*]:0:1}" ]]; then 
		
    # open & append some prioritized work lists with indices
    printf '%d  <%s>\n' "$i2" "$script" >> \
      "${mountpoint}/${time}_found_scripts_with_indices"

    for each_error in "${errs[@]}"; do
      printf '%s | <idx:%d>\n' "${each_error//$'\n'/}" "$i2" >> \
      "${mountpoint}/${time}_found_errors_with_indices_unsorted"
    done
  fi

  unset errors script 'shell_scripts[$j]'
  wait -f
done
