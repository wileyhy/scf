#!/bin/bash -x
# Written in bash version 5.1 on Fedora 37 & 38

# Note: Keep your goal in mind.


# SECTION A

: 'Regular users only'

if [[ "${UID}" == 0 ]]; then
  printf '\n\t Must be a regular user and use sudo. \n\n'
  exit 1
else
  sudo -v \
    || exit 1
fi

: 'Environment variables'

unset LC_ALL
LC_COLLATE="C.UTF-8"              # for predictable sorting
LC_CTYPE="C.UTF-8"                #  "   "           "
LC_NUMERIC="en_US.UTF-8"          # for commas in large numbers
GREP_COLORS='mt=01;104'
export GREP_COLORS
getconf_o="$(/usr/bin/command -p getconf PATH)"
PATH="${getconf_o}:/usr/bin:/usr/sbin:${PATH}" \
  || "${Halt_PATH:?}"             # Causes an immediate halt of caller
export LC_COLLATE LC_CTYPE LC_NUMERIC PATH

: 'Aliases -- for brevity during debugging'

shopt -s expand_aliases;
alias     :_=':;: "<>"';
alias     D_='declare -p ';
alias     L_='exit "${LINENO}"';
alias     M_='sudo namei -xl ';
alias     S_='sudo ';
alias     T_='tee --output-error=exit ';
alias     X_='set -x';
alias     awk='gawk --lint ';

# If xtrace was previously on, then on first execution of this function, 
# turn xrtrace off, and on second execution, turn xtrace back on and 
# forget about this function's settings. If xtrace was previously off, 
# then leave it off. 

_xtrace_duck(){
  local hyphen="$-"
  
  # If xtrace is on...
  if [[ "$hyphen" =~ x ]]; then
      
    # ...then record its state
    local -g xtrace_prev
    export xtrace_prev

    # and turn xtrace off
    set -
    
  # but if xtrace is off...
  else
    # ...then if xtrace was previously on...
    if [[ -n "${xtrace_prev}" ]]; then
      
      # ...then restore xtrace and unset its variable
      set -x
      unset xtrace_prev

    # but if xtrace is off and was previously off...
    fi
  fi
}

export setenv_prev setenv_now setenv_delta env_prev env_now env_delta
_mk_setenv_prev(){
  if [[ -n "${setenv_now}" ]]; then
    
    if [[ -n "${setenv_prev}" ]]; then
      rm -f "${setenv_prev}"
    fi
    setenv_prev="${setenv_now}"
  fi
}
_mk_setenv_now(){
  setenv_now="$(mktemp)"
  set \
    |& tee -- "${setenv_now}" > /dev/null
  env \
    |& tee -a "${setenv_now}" > /dev/null
}
_mk_setenv_delta(){
  if [[ -n "${setenv_now}" ]] && [[ -n "${setenv_prev}" ]]; then
    
    if [[ -n "${setenv_delta}" ]]; then
      rm -f "${setenv_delta}"
    else  
      setenv_delta="$(mktemp)"
    fi

    { 
      diff -y --suppress-{common-lines,blank-empty} \
        --color=always \
        "${setenv_prev}" "${setenv_now}" \
        |& grep -v setenv
    } \
      |& tee -- "${setenv_delta}" 

    {
      diff -B --suppress-{common-lines,blank-empty} \
        --color=always --palette='ad=1;3;38;5;154:de=1;3;38;5;9' \
        "${setenv_prev}" "${setenv_now}" \
        |& grep -v setenv
    } \
      |& tee -a "${setenv_delta}"
    
    less -RNS "${setenv_delta}" 
    wc "${setenv_delta}"
    GREP_COLORS='mt=01;104'
    export GREP_COLORS
  fi
}
_mk_deltas(){
  _xtrace_duck
  _mk_setenv_prev
  _mk_setenv_now
  _mk_setenv_delta
  _xtrace_duck
}

# ? what of BASH_LINENO 

PS4='+${BASH_SOURCE[0]}:${LINENO}:${FUNCNAME[0]}: '
_debug_prompt(){ 
  _mk_deltas; 
  read -rp "[${BASH_SOURCE[0]}:${LINENO}] ${BASH_COMMAND[0]}?" _
}
_full_xtrace(){
  set -o functrace
  trap '_debug_prompt "$_";' DEBUG
  set -x
}



  #exit 101
  _full_xtrace

: 'Implementation dependent arguments for options parsable by -shellcheck-'

sc_severity=error
# shellcheck disable=SC2034
SC_shells='(sh|bash|dash|ksh)'

: 'Variables more likely to be manually chaged'

repo_nm=scf
script_dirnm="${repo_nm}.d"
protected_git_dir_1="${HOME}/MYPROJECTS"
protected_git_dir_2="${HOME}/OTHERSPROJECTS"
script_nm=find-and-scan-shell-scripts-sh
script_proper_nm='Script Finder'
script_version=1.0
a_poss_proces_lock_dirs=([0]="${XDG_RUNTIME_DIR}" [1]="${HOME}"
  [2]="${TMPDIR}" [3]=/tmp [4]=/var/tmp)

  # <>
  abbrev_rel_search_dirs=/

# to search dirs...
: Option parsing
if [[ $# -gt 0 ]]; then 
  cli_input=("${@}")
fi


  #declare -p sc_severity SC_shells repo_nm protected_git_dir_1 protected_git_dir_2 script_nm script_proper_nm script_version a_poss_proces_lock_dirs cli_input
  #exit 101
  #set -x


# Variables re getopts
find_exclude_optargs_default=(
  [0]='(' [1]='!' [2]='-name' [3]='proc' [4]='-a' [5]='!' 
  [6]='-name' [7]='sys' [8]='-a' [9]='!' [10]='-iname' 
  [11]="${script_dirnm}*" [12]='-a' [13]='!' [14]='-ipath' 
  [15]="${protected_git_dir_1}" [16]='-a' [17]='!' [18]='-ipath' 
  [19]="${protected_git_dir_2}" [20]='-a' [21]='!' [22]='-path' 
  [23]='*/git/*' [24]=')' 
)
  
    # <>
  find_exclude_optargs_default+=([100]='default')
find_exclude_optargs=("${find_exclude_optargs_default[@]}")

bash_path_orig="${PATH}:/default"
bash_path="${bash_path_orig}"
#bash_path="${bash_path_orig%:/default}"
IFS=':' read -ra find_path <<< "${bash_path}"
memory_usage=default_temp_files
sc_severity=default_error

search_methods_descend=default_without # bash or find
search_methods_path=(default_PATH_as-is)
search_methods_proc=default_without
search_methods_prog=default_bin_bash
search_methods_spec_dirs=default_without
search_methods_symlinks=default_with
search_methods_sys=default_without

fn_usage() {
  # Usage:  fn_usage [exit-code]
  : fn_usage

  # print a usage message and exit with a pre-determined exit code
  {
    cat <<- EOF
  ${repo_nm} - ${script_proper_nm}, version ${script_version}
    Find and scan shell scripts depending on severity level. 
    Options are parsed by bash's builtin "getopts".
  Usage:
    ./${script_nm} -H[b|p|l] -P[ac|as|bi|bo|ge|sb|pr|sy]
        -R[DIRECTORY] -S[e|i|s|w] -V -X[r|p|t] -h|? -p[ba|cp|cv|fi|ty] 
        -q[c|i|p] -r[d|y|n] -s[s|y|n

      H:  Follow symlinks         M:  Memory usage
       *[b]ash                      [r]   RAM only
        [p]hysical                  [p]   Persistent storage
        [l]ogical                  *[t]   Temporary files
      P:  Path                    h   Help message
        [ac]  Actually all        p:  Progam and method
       *[as]  As-is                *[ba]  "bash" binary
        [bi]  /bin only             [cp]  builtin "command -pV"
        [bo]  Both /{,s}bin only    [cv]  builtin "command -V"
        [ge]  Getconf PATH only     [fi]  "find" binary
        [sb]  /sbin only            [ty]  builtin "type -a"
        [pr]  Add /proc           q:  Validate information
        [sy]  Add /sys              [a]cls
      R:  Path                      [c]rashbangs
        [STRING]  Add search dir    [d]acs
      S:  Severity level            [i]nterpreters
       *[e]rror                     [p]ath
        [i]nfo                    r:  Recurse into dirs
        [s]tyle                     [d|y] Yes   *[n] No
        [w]arning                 s:  Scan excluded dirs
      V   Version                   [s|y] Yes   *[n] No 
EOF
  } | more -e
  : 'END OF fn_usage'

  # shellcheck disable=SC2086
  exit "${1}"
}

  #declare -p find_exclude_optargs_default find_exclude_optargs 
  #declare -p bash_path find_path memory_usage sc_severity 
  #declare -p search_methods_descend search_methods_path search_methods_proc search_methods_prog search_methods_spec_dirs search_methods_symlinks search_methods_sys 
  #declare -pf fn_usage
  #exit 101
  set -x


while getopts "AH:M:P:R:S:Vhp:q:r:s:" cli_input; do
  declare -p OPTIND OPTARG 

  # Parse command line options
  case "${cli_input}" in
    # Easter egg
    A) printf '%s%s%s' 'CgkiSSB3b3VsZCBoYXZlIG1hZGUgdGhpcyBzaG9y' \
        'dGVyLCBidXQgSSBkaWRuJ3QgaGF2ZSB0aGUg' \
        'dGltZS4iCgkJLS0gTWFyayBUd2FpbgoK' \
        | base64 -d
      exit 0
      ;;   
    # Follow symlinks
    #   `bash` always follows symlinks, therefore to not follow any 
    # symlinks requires `find` and is a clobbering setting, ie, 
    # selecting either '-h P' or '-h L' will also select the use of 
    # `find`. The 'P' and 'L' refer to `find`s first argument, which 
    # by default is assumed (by `find`) to be '-P'. `find -H` is not 
    # implemented in this script.
    H) 
      # Input validation: make upper case letters lower case, and truncate all but first letter. this code block repeats below.
      OPTARG="${OPTARG,,[A-Z]}"
      OPTARG="${OPTARG:0:1}"
      
      # Parse option arguments
      case "${OPTARG}" in
        # Bash
        b)
          search_methods_symlinks=bash # default
          search_methods_prog=bin_bash
          ;;
        # Physical
        p)
          search_methods_symlinks=physical
          search_methods_prog=bin_find 
# side effect: setting '-H p' also clobbers this variable. side effects such as these are marked below as "clobber."
          find_sym_opt='-P'
          ;;
        # Logical
        l)
          search_methods_symlinks=logical
          search_methods_prog=bin_find # clobber
          find_sym_opt='-L'
          ;;
        # this parameter expansion, ':?', when a parameter is null or unset, causes the shell to immediately halt, ignoring any trap on EXIT.
        *) "${arg_wrong__h:?}"
          ;;
      esac
      ;;
    # Whether and how to save data. 
    M) 
      # Input validation
      OPTARG="${OPTARG,,[A-Z]}"
      OPTARG="${OPTARG:0:1}"
      
      # Parse option arguments
      case "${OPTARG}" in
        r) memory_usage=RAM_only ;;
        p) memory_usage=persistent_storage ;;
        t) memory_usage=temp_files ;;
        
        # Error handling
        *) "${arg_wrong__X:?}" ;;
      esac
      ;;
    # PATH (array) - Part 1 - Options with no args . ('-P /usr/share' is an option with an argument.)
    #   For scanning '/proc' or '/sys', see also option 's'.
    P)
      # Part 1.A -- clobbering settings
      OPTARG="${OPTARG,,[A-Z]}"
      OPTARG="${OPTARG:0:2}"
      case "${OPTARG}" in
      
        # Multiple abbreviations accepted
        ac|aa)
          unset find_path search_methods_path 
          search_methods_path=(actually_all)
          bash_path='/'
          
          # For consistency, find_path is always defined after bash_path, regardless of which one is used.
          IFS=':' read -ra find_path <<< "${bash_path}"
          search_methods_prog=bin_find
          ;;
        as|ai)
          unset find_path search_methods_path 
          search_methods_path=(as-is)
          bash_path="${PATH}"
          IFS=':' read -ra find_path <<< "${bash_path}"
          ;;
        bi|b)             
          unset find_path search_methods_path 
          search_methods_path=(bin_only)
          bash_path='/usr/bin'
          IFS=':' read -ra find_path <<< "${bash_path}"
          ;;
        bo|bs)
          unset find_path search_methods_path 
          search_methods_path=(both_bin_sbin_only)
          bash_path='/usr/bin:/usr/sbin'
          IFS=':' read -ra find_path <<< "${bash_path}"
          ;;
        ge|g)
          unset find_path search_methods_path 
          search_methods_path=(getconf_PATH_only)
          bash_path="${getconf_o}"
          IFS=':' read -ra find_path <<< "${bash_path}"
          ;;
        sb|so|s)
          unset find_path search_methods_path 
          search_methods_path=(sbin_only)
          bash_path='/usr/sbin'
          IFS=':' read -ra find_path <<< "${bash_path}"
          ;;
      # Part 1.B -- additive PATH settings, but the Program 
      #   setting gets clobbered
        pr|p|pa)
          unset find_path
          search_methods_path+=(add_proc)
          bash_path="${bash_path//:\/default/}"
          bash_path="${bash_path}:/proc"
          IFS=':' read -ra find_path <<< "${bash_path}"
          search_methods_prog=bin_find
          ;;
        sy|sa)
          unset find_path
          search_methods_path+=(add_sys)
          bash_path="${bash_path//:\/default/}"
          bash_path="${bash_path}:/sys"
          IFS=':' read -ra find_path <<< "${bash_path}"
          search_methods_prog=bin_find
          ;;
      # Part 1.C - handle erroneous input
        *) "${arg_wrong__P:?}" ;;
      esac
      ;;
    # PATH (array) - Part 2 - options with args
    R) 
      # Input validation, more thorough. Remove unprintable strings.
      OPTARG="$(strings -n1 <<< "${OPTARG}")"
      
      # Bug: sb a printf one liner
      # for i in DECIMALS; do printf '%b' "\\${i}"; done #...

      # List unsafe ASCII characters
      bad_strings=([0]="|" [1]="&" [2]=";" [3]="(" [4]=")" [5]="<" 
        [6]=">" [7]=" " [8]=$'\t' [9]=$'\n' [10]="||" [11]="&&" 
        [12]=";;" [13]=";&" [14]=";;&" [15]="|&" [16]="!" [17]="{" 
        [18]="}" [19]="[" [20]="]" [21]="[[" [22]="]]" [23]="\$" 
        [24]="=")
        
      # Remove unsafe characters
      new_optarg="${OPTARG//["${bad_strings[@]}"]/}"
      
      # If any ASCII characters were removed, print an error and exit
      if [[ "${new_optarg}" != "${OPTARG}" ]]; then
        printf '\n\tError: option -R: directory name includes '
        printf 'an illegal character\n\n'
      fi
      
      # Canonicalize path
      new_optarg="$( realpath -e "${new_optarg}" )"
      
      $ Value must be a directory
      if  [[ ! -d "${new_optarg}" ]]; then 
        "${arg_wrong__R:?}"
      fi
      unset find_path
      search_methods_path+=( "add_dir__${new_optarg//\//_}" )
      
        # <> Debug: bash_path="${bash_path//:\/default/}"
      
      # Append dirname to PATH
      bash_path="${bash_path}:${new_optarg}"
      
      # load directories of PATH into an array
      IFS=':' read -ra find_path <<< "${bash_path}"
      ;;
    # ShellCheck's '-S' setting, ie, severity level
    S)
      # Mis-spellings allowed
      OPTARG="${OPTARG,,[A-Z]}"
      OPTARG="${OPTARG:0:1}"
      case "${OPTARG}" in
        e) sc_severity=error ;; # default
        i) sc_severity=info ;;
        s) sc_severity=style ;;
        w) sc_severity=warning ;;
        *) "${arg_wrong__S:?}" ;;
      esac
      ;;
      
    # Bug: hardcoded info: license  
    V) 
      printf '\n\t%s, version %s. Apache 2 license.\n\n' \
        "${script_proper_nm}" "${script_version}"
      ;;
    # Help message
    h|\?) fn_usage 0
      ;;
    # Program to search with (variable) -- all settings clobber
    p)
      OPTARG="${OPTARG,,[A-Z]}"
      OPTARG="${OPTARG:0:2}"
      case "${OPTARG}" in
        ba|b)
          search_methods_prog=bin_bash
          ;;
        cp)
          search_methods_prog=bash_command_pV
          ;;
        cv)
          search_methods_prog=bash_command_V
          ;;
        fi|f)
          search_methods_prog=bin_find
          ;;
        ty|t)
          search_methods_prog=bash_type_a
          ;;
        *) 
          "${arg_wrong__p:?}" 
          ;;
      esac
      ;;
    # What information to verify -- none are enabled by defaulted 
    q) 
      # ALSO: verify DACs and ACLs is written below!
    
      OPTARG="${OPTARG,,[A-Z]}"
      OPTARG="${OPTARG:0:2}"
      case "${OPTARG}" in
        a|ac) verify+=(acls);;
        c|cr) verify+=(crashbangs);;
        d|da) verify+=(dacs);;
        i|in) verify+=(interpreters);;
        p|pa) verify+=(path);;
        u|un) unset verify;;
        *) "${arg_wrong__X:?}";;
      esac
      ;;
    # Descend into dirs (recurse)
    #   `bash`s path search cannot descend into dirs; for `find` the 
    # default is to 'do descend' into dirs. For this script, the default 
    # for descending follows `bash`, and selecting this setting switches 
    # the search program to `find`. `find`s '-mindepth' and '-maxdepth' 
    # are not implemented. 
    r) 
      OPTARG="${OPTARG,,[A-Z]}"
      OPTARG="${OPTARG:0:1}"
      case "${OPTARG}" in
        # recurse|descend|yes
        r|d|y)
          search_methods_descend=yes
          search_methods_prog=bin_find # clobber
          unset bash_path
          ;;
        # no_descend
        n)
          search_methods_descend=no # default
          search_methods_prog=bin_bash # clobber 
          unset find_path
          ;;
        *) "${arg_wrong__r:?}"
          ;;
      esac
       ;;
    # Scan excluded dirs
    #   By default, this script assumes for `find` a set of automatic-
    # ally excluded search directories that often prove to be somewhat 
    # problematic: '/proc', '/sys', and anything with a find '-path' 
    # of either '*/git/*' or the script's name. With a default PATH 
    # setting, `bash` usually also skips these directories, so enabling 
    # this option indicates the wish to use `find`, and so clobbers 
    # `bash`. To add '/proc' or '/sys' to `find`s search path, see 
    # option 'P', 'add_proc' and 'add_sys'. 
    s) 
      OPTARG="${OPTARG,,[A-Z]}"
      OPTARG="${OPTARG:0:1}"
      case "${OPTARG}" in
        # scan_excluded|yes
        s|y)
          search_methods_scan_excluded=yes
          search_methods_prog=bin_find
          find_exclude_optargs=()
          ;;
        # no_scan_excluded
        n)
          search_methods_scan_excluded=no
          search_methods_prog=bin_find
          find_exclude_optargs=("${find_exclude_optargs_default[@]}")
          unset 'find_exclude_optargs[100]'
          ;;
        *) "${arg_wrong__s:?}"
          ;;
      esac
      ;;
    *) 
      fn_usage 1 
      ;;   
  esac 
done
  set -
  unset 'find_exclude_optargs[100]'
{ 

  # <>
  declare -p find_exclude_optargs_default find_exclude_optargs 
  declare -p bash_path find_path find_sym_opt memory_usage sc_severity search_methods_descend search_methods_path search_methods_proc search_methods_prog search_methods_scan_excluded search_methods_spec_dirs search_methods_symlinks search_methods_sys OPTARG bad_strings new_optarg verify 2> /dev/null
} |& grep -v default 2> /dev/null
  : 'find_exclude_optargs:' "${find_exclude_optargs[@]}"
  #declare -pf fn_usage
  #exit 101
  set -x

# Verify PATH 
#   (...before running the builtins [type and command], or they'll 
# print dups)
if [[ "${verify[*]}" =~ path ]]; then

# for Verify PATH

  # Get constituent dirs from PATH
  unset path path_2 p; IFS=':' read -ra path <<< "${PATH}" # this
  
  # get the cannonicalized paths of each such dir
  for p in "${!path[@]}"; do path[p]="$(realpath -e "${path[p]}" 2> /dev/null)"; done; unset p # this
 
  # if the index is empty, then unset it
  for p in "${!path[@]}"; do if [[ -z "${path[p]}" ]]; then unset 'path[p]'; fi; done; unset p # this
  
  # remove any duplicates while preserving order of dirs
  for p in "${!path[@]}"; do if [[ "${path_2[*]}" =~ ${path[p]} ]]; then unset 'path[p]'; else path_2+=("${path[p]}"); fi; done; unset p # this
  
  # reset indices of path_2 and print results 
  path_2=("${path_2[@]}"); declare -p path_2 # this

  # reset PATH
  PATH="$(printf '%s' "${path_2[0]}"; unset 'path_2[0]'; printf ':%s' "${path_2[@]}")"; declare -p PATH
fi
  #declare -p PATH
  #exit 101




# Bug: greps. parse full outputs of type and command

# Process value of search_methods_prog
if [[ "${search_methods_prog}" = \
  @(bash_command_pV|bash_command_V|bash_type_a) ]]
then

  # create a single array of all commands found by each kind of search.
  # to do this...

  # search for commands with odd yet permitted-by-Linux initial 
  # characters, such as \n \t \c or \l

  # create a dictionary list of each possible initial character
  unset allchr char i all_commands real_dirs re

  for i in 8 9 10 11 12 13 {32..127}; do allchr+=( ["$i"]="$( printf '%b' "\\$( printf %03o "$i" )" )" ); done; allchr[10]=$'\n'; unset i; declare -p allchr;


  for i in "${!allchr[@]}"; do mapfile -O $((i * 1000)) -t all_commands < <( compgen -c "${allchr[i]}" ); done; unset i; declare -p all_commands

  mapfile -t real_dirs < <( sudo find / -maxdepth 1 -mindepth 1 -type d \! -empty | sort ); declare -p real_dirs

  re="$( printf '(%s' "${real_dirs[0]#/}"; unset 'real_dirs[0]'; printf '|%s' "${real_dirs[@]#/}"; printf ')\n')"; declare -p re

  #search_methods_prog=bash_type_a; for i in "${!all_commands[@]}"; do if [[ "${search_methods_prog}" = bash_type_a ]]; then type -a "${all_commands[i]}" ; fi; done

# Bug: the tests for search_methods_prog need to be at the top level of 
# logic structure

  for i in "${!all_commands[@]}"; do 
    
    # For anywhere in PATH: BASH_type_a
    if [[ "${search_methods_prog}" = *bash_type_a ]]; then 
      type -a "${all_commands[i]}" \
        | grep -E 'is /'"${re}" ; 
    fi;

    # For `command -pV` (usually only '/usr/bin'): BASH_command_pV
    if [[ "${search_methods_prog}" = *bash_command_pV ]]; then
      command -pV "${all_commands[i]}" \
        | grep -E 'is /'"${re}" ; 
    fi

    # For `command -V` (usually includes '/usr/sbin'): BASH_command_V
    if [[ "${search_methods_prog}" = *bash_command_V ]]; then
      command -V "${all_commands[i]}" \
        | grep -E 'is /'"${re}" ; 
    fi

  done \
    | sudo tee all_commands

elif  [[ "${search_methods_prog}" = *bin_bash ]]; then
  command -v bash || exit "${LINENO}"
elif  [[ "${search_methods_prog}" = *bin_find ]]; then
  command -v find || exit "${LINENO}"
else
  echo error
fi

  # <>
  [[ -f ./all_commands ]] \
    &&
  ls lsllssßsd   all_commands
  for v in search_method_prog all_chr re char; do
    declare -p "${v}"
  done; unset v
  exit 101


    # delete? re-work? 

abbrev_rel_search_dirs=all
    #
    # To search some specific directories, uncomment them; to search 
    # all of the common dirs or FULL DISK instead # --really-- --slow--
    #
    declare -A A_rsd
    A_rsd=( 
      # useful for testing 
        #[usr_bin]='/bin' 
        #[usr_lib]='/lib' 
        #[usr_lib64]='/lib64' 
        [usr_sbin]='/sbin' 
      # common search dirs on Fedora, ie, "all"
        #[boot]='/boot' 
        #[dev]='/dev' 
        #[etc]='/etc' 
        #[home]='/home' 
        #[root]='/root' 
        #[run]='/run' 
        #[tmp]='/tmp' 
        #[usr]='/usr' 
        #[var]='/var' 
      # usually empty
        #[afs]='/afs' 
        #[lost+found]='/lost+found' 
        #[media]='/media' 
        #[mnt]='/mnt' 
        #[opt]='/opt' 
        #[srv]='/srv' 
      # usually quite difficult to parse; rarely any shell scripts
        #[proc]='/proc' 
        #[sys]='/sys' 
    )


# for actually_all
  umask 117

  get_rel_search_dirs(){
    mapfile -d '' -t "${1}" < <(
      sudo find / -mindepth 1 -maxdepth 1 -type d \! -empty \
        \( \! -name proc -a \! -name sys \
          -a \! -iname "${script_dirnm:- scf.d}" \
          -a \! -iname "${protected_git_dir_1:- ~}" \
          -a \! -iname "${protected_git_dir_2:- tmp}" \
        \) -print0 2> /dev/null);
      }
  get_rel_search_dirs a_relevant_search_dirs


# for memory usage persistent storage
  # take each found dir and convert abs path [of sym, okay] to a string
  # usable for directory names
  unset index element calc;

  # for each dirname /  directory in search path
  for index in "${!A_rsd[@]}"; do 
    element="${A_rsd["$index"]}"; 
    calc="$(realpath -e "$element")"; 
    calc="${calc//\//_}"; 
    calc="${calc#_}"; 
    printf 'element: %-12s index: %-12s calc: %s \n' \
      "$element" "$index" "$calc"; 
    if [[ "$index" != "$calc" ]]; then 
      echo wrong; 
      exit; 
    fi; 
  done
  get_mountpoint(){
    unset d dir
    d="$(realpath -e "$1")"
    mapfile -t dir < <(
      namei -xl "$d" \
      | tac \
      | grep -A100 ^D \
      | grep -E ^'[Dd]' \
      | awk '{ print $4 }')
    unset j x i
    j="${#dir[@]}"
    for (( i=j; i>0; i--)); do 
      x+="${dir[$i-1]}"/
    done; 
    x="$(realpath -e "$x")"
    echo "$x"
  }
  get_mountpoint /sbin

  # <>
  exit



 
# check DAC's, 
namei_o="$( 
  for d in "${path_2[@]}"; do 
    namei -xl "$(
      realpath -e "$d" 2> /dev/null)"; 
  done \
    | grep -v ^'f:' \
    | awk '$2 !~ /root/ || $3 !~ /root/ { print }'
)"
if [[ -n "${namei_o}" ]]; then
  echo 'A directory in PATH is not fully owned by root (DAC).'
  echo "${namei_o}"
  exit "${LINENO}"
fi

# check ACL's 

# Variables, this section
unset end_dirname full_dir_list ext_array dir sub_dir num_sub_dirs N n \
  extglob_pattern ext_first ext_last getfacl_o grep_o
end_dirname=/; 
declare -A full_dir_list; 
ext_array=()

# for each actual directory in PATH
for dir in "${path_2[@]}"; do 
  
  # limit the number of loops to the number of constituent directory
  # inodes. safely split each directory into its constituent directory 
  # names, ie, by using NULL's in place of '/'s
  unset sub_dir
  num_sub_dirs="$(tr '/' '\0' <<< "$dir" \
    | awk -F'\0' '{ print NF }')"; 
  N=$((num_sub_dirs - 1))

  # read the ACLs of each dir and sub_dir
  for ((n=N;n>=0;--n)); do 

    # Assign a value to $sub_dir as necessary
    : "${sub_dir:="${dir}"}"

    # If the sub_dir is already listed in the extglob_pattern, then 
    # move on to the next small loop  
    # shellcheck disable=SC2053
    if [[ "${sub_dir}" = ${extglob_pattern} ]]; then 
      sub_dir="$(dirname "${sub_dir:="${dir}"}")"
      
      # If the sub_dir is '/', then move on to the next big loop
      if [[ "${sub_dir}" = "${end_dirname}" ]]; then
        break 
      fi
      continue
    fi

    # Use an Associative array to filter out duplicate entries. 
    # (With associative arrays, duplicate assignments are indempotent.)
    full_dir_list["${sub_dir}"]+="${n}," 

    # create a list of directories and subdirectories that have been
    # tested so far. This section concatenates directories as strings
    # into a variable that the shell will later interpret as an 
    # extglob.
    ext_array=("${!full_dir_list[@]}")
    ext_first="${ext_array[0]}"
    [[ -n "${ext_first}" ]] \
      && unset 'ext_array[0]'
    # shellcheck disable=SC2124
    ext_last="${ext_array[@]: -1:1}"
    [[ -n "${ext_last}" ]] \
      && unset "ext_array[${#ext_array[@]}]" 
    # index math can be a little weird

    # create the exglob_pattern
    if [[ -n "${ext_first}" ]]; then 
      extglob_pattern="$(         printf '@(%s' "${ext_first}" )"
      [[ "${#ext_array[@]}" -gt 0 ]] \
        && extglob_pattern+="$(   printf '|%s' "${ext_array[@]}" )"
      if [[ -n "${ext_last}" ]]; then
        extglob_pattern+="$(      printf '|%s)' "${ext_last}" )"
      else
        extglob_pattern+="$(      printf ')' )"
      fi
    fi

    # look for any ACL's on the directory
    getfacl_o="$(getfacl -enp -- "${sub_dir}" 2> /dev/null)"
    grep_o="$(grep -ve '^#' -e ^'user::' -e ^'group::' -e ^'other::' \
      <<< "${getfacl_o}")"
    
    # If found, halt the script and inform the user
    if [[ -n "${grep_o}" ]]; then
      printf '\n%s: ACL defined for this directory:\n\t%s\n\n' \
        "${script_nm}" "${sub_dir}"
      echo "${getfacl_o}"
      printf '\n\tThis command will remove all ACL\x27s from the '
      printf 'specified directory:\n\n\t\tsetfacl -b %s\n\n' "${sub_dir}"
      exit 1

    # otherwise, move on to the next big loop  
    else
      if [[ "${sub_dir}" = "${end_dirname}" ]]; then
        break 
      fi
    fi 

    sub_dir="$(dirname "${sub_dir:="${dir}"}")"
  done    
done; 
unset end_dirname full_dir_list ext_array dir sub_dir num_sub_dirs \
  N n extglob_pattern ext_first ext_last getfacl_o grep_o


# check MAC's


#exit 101



: 'Functions -- for brevity during debugging'
set -v
function  B_() { fn_bak "$@";};
function  I_() { fn_erx "${LINENO}";};
#function N_() { fn_num "$@";};
#function V_() { fn_write_vars "$@";};
function  W_() { fn_write_arrays "$@";};
set +v


: 'Check for Process Locks'

for d in "${a_poss_proces_lock_dirs[@]}"; do
  if [[ -d "${d}" ]]; then
    mapfile -d '' -t lkds < <( 
      S_ find "${d}" -type d -empty -name ".${repo_nm}.[0-9a-zA-Z_-]*.lock" \
        -print0 2> /dev/null)

    : 'lkds, count:' "${#lkds[@]}"

    for l in "${lkds[@]}"; do
      if [[ -d "${l}" ]]; then
        if [[ -v delete_locks ]]; then
          rmdir -v -- "${l}"
        else
          printf '\n\t A process lock exists for this script. Exiting '
          printf 'now.\n\n'
          L_
        fi
      fi
    done
  fi
done
[[ -v delete_locks ]] \
  && L_


: 'Functions'

fn_bak() {
  : fn_bak

  # for each of multiple input files
  for loc_filename_a in "${@}"; do

    # test verifying existence of input
    if S_ test -f "${loc_filename_a}"; then

      # BUG: Why does this ^ test req sudo when this test \/ doesnt?

      # if the destination (.bak) file already exists,
      # then age it first.
      if [[ -f "${loc_filename_a}.bak" ]]; then
        
        if [[ -s "${loc_filename_a}.bak" ]]; then
          return
        else
          S_ rm -f -- "${loc_filename_a}.bak"
        fi
      fi

      # write a new .bak file
      S_ rsync -acq -- "${loc_filename_a}"{,.bak} \
        || I_

    # if input file DNE, then print an error and exit
    else
      { 
        echo WARNING: file DNE "${loc_filename_a}"
        return
      }
    fi
  done
  : 'END OF fn_bak'

}
fn_erx() {
  # this assignment must be the first command
  local loc_exit_code="${?}"
  : fn_erx

  # print an error message and exit with the correct exit code
  echo -e Error: "${@}"
  : 'END OF fn_erx'

  exit "${loc_exit_code}"
}
#fn_num() {
#  # Usage: N_ [raw arrays names]
#  : fn_num
#
#  # for each of multiple input array names
#  for loc_unquotd_array_nm_a in "${@}"; do
#
#    # set a local name reference variable
#    local -n loc_nameref_a="${loc_unquotd_array_nm_a}"
#
#    # and use the nameref to print the number of indices in the input array
#    echo ${#loc_nameref_a[@]}
#  done
#  : 'END OF fn_num'
#  
#}
fn_usage() {
  # Usage:  fn_usage [exit-code]
  : fn_usage

  # print a usage message and exit with a pre-determined exit code
  cat <<- EOF
    ${repo_nm} - ${script_proper_nm}, version ${script_version}
    Find and scan shell scripts depending on severity level. 
        Usage:  ${script_nm} [-ehiw]
                -e error          -i info
                -h help           -w warning
    Only the first option is processed.

EOF
  : 'END OF fn_usage'

  # shellcheck disable=SC2086
  exit "${1}"
}
fn_write_arrays() {
  # Usage: W_ [arrays]

  : fn_write_arrays: Write each array to a file on disk.

  loc_write_d_b="${curr_time_ssubd}arrays"

  if [[ ! -d "${loc_write_d_b}" ]]; then
    S_ mkdir -p -- "${loc_write_d_b}" \
      || I_
  fi

  # for each of multiple input array names
  for loc_unquotd_array_nm_b in "${@}"; do
    
    # create local variables, for use as both array and string
    local -n loc_nameref_b="${loc_unquotd_array_nm_b}"
    loc_array_nm="${loc_unquotd_array_nm_b}"
    loc_write_f_b="${loc_write_d_b}/_${sc_severity:0:1}"
    loc_write_f_b="${loc_write_f_b}_${abbrev_rel_search_dirs}_${loc_array_nm}"

    # solved?  BUG: mixing variable and array. sb a nameref

    # Bug? When array correctly is empty. 'declare -p ... > /dev/null ||' ?

    # if the input array holds no data, then populate it
    if [[ ! -v loc_nameref_b[@] ]]; then
      loc_nameref_b=([0]='fn_write_arrays: Empty array')

    fi

    # then write a data file to disk
    declare -p "${loc_array_nm}" \
      | S_ T_ -- "${loc_write_f_b}" > /dev/null

    # write a backup of the new data file

    B_ "${loc_write_f_b}"
  done
  : 'END OF fn_write_arrays'

}
#fn_write_vars() {
#  # Usage: V_ [loc_script_section_nm] [raw variable names]
#
#  # first pos-parm is string used for differentiating filename
#  : fn_write_vars
#  loc_script_section_nm="${1}"
#  loc_write_f_a="${curr_time_ssubd}/${loc_script_section_nm}_vars"
#  shift
#
#  # if the destination file already exists, then return from FN
#  [[ -e "${loc_write_f_a}" ]] \
#    && return
#
#  # write a new data file
#  declare -p "${@}" 2>/dev/null \
#    | S_ T_ -- "${loc_write_f_a}" >/dev/null
#
#  # and write a .bak file
#  
#  B_ "${loc_write_f_a}"
#  : END OF fn_write_vars
# 
#}


: Use -sudo-
if ! S_ -v; then
  printf '\n\tValidation failed of user\x27s \x60sudo\x60 timestamp; '
  printf 'exiting.\n\n'
  L_
fi

# Set up a trap on signals "exit", "term" and "int"
# shellcheck disable=SC2154
trap '
  #set -

  # [Trap] Delete all possible existing process directories. 
  for poss_lk_d in "${a_poss_proces_lock_dirs[@]}"; do 

    # [Trap] Abbreviate variable, then test and delete lock directories.
    pl="${poss_lk_d}/${proc_lk_f_nm}"

    if [[ -d "${pl}" ]] && [[ ! -L "${pl}" ]]; then 
      S_ rm -rf -- "${pl}" \
        || L_
    fi
  done

  # [Trap] Remove any script-s ACL-s based on whether the canary variables
  # exist.
  if [[ -v acl_execd_setfacl ]]; then 

    if [[ -v acl_abs_path ]]; then 
      S_ setfacl -R -x "u:${UID}" -- "${acl_abs_path}" ||
        echo Error: trap: setfacl failed, line "${LINENO}"

    # bug? Should this var be main_d \/ ? Sb erx ^ ?

    elif [[ -v mountpoint ]]; then
      S_ setfacl -R -x "u:${UID}" -- "${mountpoint}" ||
        echo Error: trap: setfacl failed, line "${LINENO}"
    fi
  fi

  trap - EXIT TERM INT
  kill -s INT "$$"
' EXIT TERM INT

#X_; :_


: 'Process lock'

# define basename and absolute path of the lock directory
random_n="${RANDOM}"
proc_lk_f_nm=".${repo_nm}.$$${random_n}.lock"

#:_; D_ a_poss_proces_lock_dirs

# from among the possible dirnames
for poss_lk_d in "${a_poss_proces_lock_dirs[@]}"; do

  # use the first one that fulfills certain requirements
  if [[ -d "${poss_lk_d}" ]] \
    && [[ ! -L "${poss_lk_d}" ]] \
    && [[ -w "${poss_lk_d}" ]]; then

    # define the lock directory
    process_lock_d="${poss_lk_d}/${proc_lk_f_nm}"
    break
  fi
done

# create the lock directory
if ! mkdir -m 0000 "${process_lock_d}" 2>/dev/null; then
  {
    printf '\n\tCannot acquire process lock: <%s>.\n' "${process_lock_d}"
    #printf '\tID: %s\n' "${USER}" # why?
    printf 'Exiting.\n\n'
  } 1>&2
  L_
fi

#:_; D_ process_lock_d; M_ -- "${process_lock_d}"; L_


: User variables
timecode="$(builtin printf '%(%F_%H%M%S)T')"


# SECTION B

#:_
#X_

# BUGs: Hardcoded $mountpoint; trailing backslash

: 'Assign varnames and paths for the data directories'
mountpoint=/run/media/root/29_Mar_2023
main_d="${mountpoint}/${script_dirnm}"
data_subd="${main_d}/latest_data"
curr_time_ssubd="${data_subd}/t_${timecode}/"
list_crunchbangs="${curr_time_ssubd}/crunchbangs"
found_scrpts_f="${list_crunchbangs}_found_scripts_${sc_severity:0:1}_${abbrev_rel_search_dirs}"

: 'data files'
a_write_path_nms=("${list_crunchbangs:=crunchbangs}" "/tmp/${list_crunchbangs##*/}")

# TODOs: grep scripts for 'todo's
#   - grep for 'shellcheck disable'
#   - This section seems buggy.

: 'Reduce use of sudo'
if [[ ! -r "${main_d}" ]]; then

  mapfile -d / -t a_acl_name_indiv_dir <<< "${main_d}"

  a_acl_name_indiv_dir[0]=/
  a_acl_name_indiv_dir[-1]="${a_acl_name_indiv_dir[-1]//$'\n'/}"

  acl_each_dir="${#a_acl_name_indiv_dir[@]}"

  for ((iterator_1 = 0; iterator_1 < acl_each_dir; iterator_1++)); do
    acl_abs_path+="/${a_acl_name_indiv_dir[iterator_1]}"
    acl_realpath="$(realpath -e "${acl_abs_path}")"

    # Bug: why sudo? \/

    if S_ test -e -- "${acl_realpath}"; then
      : 'test succeeded: acl_realpath exists '
    else

      : 'test failed: acl_realpath DNE'

      if [[ ! -d "${acl_abs_path}" ]]; then

        S_ mkdir -p -- "${main_d}" \
          || I_
      fi

      acl_realpath="$(realpath -e "${acl_abs_path}" 2>/dev/null)"

      #:_

      # TODO: use alias w namei

      #M_ -- "${acl_realpath}"

    fi

    if [[ -r "${acl_realpath}" ]]; then
      : 'test succeeded: acl_realpath is readable'
    else

      : 'test failed: acl_realpath is not readable'

      acl_execd_setfacl=y
      export acl_execd_setfacl # SC2034, while trap-s setfacl blk is #-d # this comment means what?

      # readable up to the main_d
      S_ chmod -R 750 -- "${acl_realpath}" \
        || I_

      S_ setfacl -d -m "${USER}:r-x" -- "${acl_realpath}" \
        || I_

      S_ setfacl -m "${USER}:r-x" -- "${acl_realpath}" \
        || I_

      #:_
      #id "${USER}"
      #groups "${USER}"
      #M_ -- "${acl_realpath}"
      #S_ getfacl -- "${acl_realpath}"

      [[ -r "${acl_realpath}" ]] \
        || I_
    fi
  done

  # writeable within the main_d
  S_ setfacl -d -m "${USER}:rwx" -- "${main_d}" \
    || I_

  S_ setfacl -R -m "${USER}:rwx" -- "${main_d}" \
    || I_

  #:_
  #id "${USER}"
  #groups "${USER}"
  #M_ -- "${main_d}"
  #S_ getfacl -- "${main_d}"

fi

: 'make sure -data_subd- is a directory OR create the -data_subd- dir '
: 'if necessary'
[[ -d "${data_subd}" ]] \
  || mkdir "${data_subd}" # as liveuser

#:_
#M_ -- "${data_subd}"

: Label the current data as -latest.-
# shellcheck disable=SC2312
mapfile -d '' -t a_previous_time_dirs < <(
  find "${data_subd}" -mindepth 1 -maxdepth 1 -type d -a \! -type l \
    -name 't_*' -print0
)

: if -prev_time_ssubd- is empty, delete it, otherwise -mv- it out
: of the -latest- dir
for prev_time_ssubd in "${a_previous_time_dirs[@]}"; do
  rmdir --ignore-fail-on-non-empty -- "${prev_time_ssubd}"

  : of previous prev_time_ssubd
  if [[ -d "${prev_time_ssubd}" ]] && [[ ! -L "${prev_time_ssubd}" ]]; then
    S_ mv -- "${a_previous_time_dirs[@]}" "${main_d}"
  else
    continue
  fi
done

: of curr_time_ssubd
if [[ ! -d "${curr_time_ssubd}" ]]; then
  S_ mkdir -p -- "${curr_time_ssubd}" \
    || I_
fi

#:_
#M_ -- "${curr_time_ssubd}"

# SECTION C

: 'Gather filenames from local attached disk storage'

if [[ "${abbrev_rel_search_dirs}" == all ]]; then

  : 'set a value for a_relevant_search_dirs and..'
  # shellcheck disable=SC2312
  mapfile -d '' -t a_relevant_search_dirs < <(
    S_ find / -mindepth 1 -maxdepth 1 -type d \! -empty \
      \( \! -name proc -a \! -name sys -a \! -iname "${script_dirnm}*" \) \
      -print0 2> /dev/null
  )

  for sd in "${a_relevant_search_dirs[@]}"; do 

    # assign 
    echo "${sd}"
  done

fi

: 'Find all files within the search area. Even the empty ones.'
# shellcheck disable=SC2312
mapfile -d '' -t a_all_files < <(
  S_ find "${a_relevant_search_dirs[@]}" -mindepth 1 -type f \
    -print0 2> /dev/null
)

: 'Sort the original array and test it.'
# shellcheck disable=SC2312
mapfile -d '' -t a_all_files_sorted < <(
  printf '%s\0' "${a_all_files[@]}" \
    | sort -z
)

# SECTION D

# Bug? Can more indices and fewer files be used?

: 'Sort out the scripts, ie, any file beginning with a crashbang from'
: 'the rest of the files'

: 'Get the total number of found files, for the progress indicator'
# shellcheck disable=SC2034
total_count="$(printf "%'d" "${#a_all_files_sorted[@]}")"
unset IFS

[[ -f /tmp/"${list_crunchbangs##*/}" ]] \
  && S_ rm -f -- "/tmp/${list_crunchbangs##*/}"

# BUG: the search dirs must be the same, as well as the dnf tx number
# BUG: Use of /tmp/crunchbangs as yn on do loop q. Sb a set of file lists
#.   difftd by search dir / search type / etc. See file "priority"

: 'if the full list exists -- of files on disk which begin with'
: 'crashbangs -- skip the 30-90 minute search phase.'
if [[ ! -f "/tmp/${list_crunchbangs##*/}" ]] \
  || [[ -L "/tmp/${list_crunchbangs##*/}" ]]
then


  for all_files_index in "${!a_all_files_sorted[@]}"; 
  do

    : 'Loop'

    loop_idx="$(printf "%'d" $((all_files_index + 1)) )"
    printf '%s of %s files\r' "${loop_idx}" "${total_count}"

    : 'file must exist'
    each_sorted_f="${a_all_files_sorted[all_files_index]}"

    if [[ ! -e "${each_sorted_f}" ]]; 
    then
      a_file_DNE+=([all_files_index]="${each_sorted_f}")
      continue
    fi

    : 'list of empties'
    if [[ ! -s "${each_sorted_f}" ]]; 
    then
      a_empty_files+=([all_files_index]="${each_sorted_f}")
      continue
    fi

    : '-file- magic'
    printf '+ %-8d: ' "${all_files_index}" \
      | S_ tee -a -- "${curr_time_ssubd}file_out" > /dev/null

    file_o="$(S_ file -pk -- "${each_sorted_f}" 2>&1)" # Bug: needs erx
    file_o="${file_o%%64-bit LSB *}"
    a_bin_file_output+=([all_files_index]="${file_o}")

    # Bug? Needs tracking index? One array or file, one line per fso,
    #. use symbols or csv to indicate test results, w common indices
    # Bug: [[ -n sb right after exec file

    if [[ -n "${file_o}" ]]; 
    then
      S_ tee -a -- "${curr_time_ssubd}file_out" <<< "${file_o}" > /dev/null
    else
      err_msg="WARNING: -file- produced 0 output:  <${each_sorted_f}>"
      S_ tee -a -- "${curr_time_ssubd}file_out" <<< "${err_msg}" > /dev/null
    fi

    # Bug: keep `od` output in an array
    # Bug: avoid as many disk writes as possible. 
    #.  Write out only stats?
    # Bug: use indices to reference each type? Store array diffs btw loop?
    #. Time loss to disk io? Run file in parallel? Read each file once and
    #. use var for both od and file?

    : 'two bytes each'

      #X_; :_

      # fix?: mapfile -d '' -t -O "${all_files_index}" a_od_output

    od_o="$(S_ od -j 0 -N 2 -t x1z -v -- "${each_sorted_f}"\
      | tr -s ' ' \
      | awk '{ print $2, $3, $4 }' \
      | tr -d '\n' \
      || I_ "P:${PIPESTATUS[*]} I:${all_files_index} ${each_sorted_f}"
    )"

    #D_ od_o

    [[ -n "${od_o}" ]] \
      || I_ "I:${all_files_index} ${each_sorted_f}"

    a_bin_od_output+=([all_files_index]="${od_o}")

      #D_ a_bin_od_output

    read -r byte_0 byte_1 printable_chars <<< "${od_o}" 

      #D_ byte_0 byte_1 printable_chars a_all_other_files; L_;

    export printable_chars # SC2034

    : '-od_o- non-zero'
    if [[ -z "${byte_0}" ]]; 
    then
      I_ "I:${all_files_index} <${each_sorted_f}>" \
        '*unreachable code*'
    elif [[ "${byte_0}" == @(23|21) ]]; 
    then
      : 'compare hexadecimals'

      : 'endianness'
      if [[ "${byte_0}${byte_1}" == 2123 ]]; 
      then
        a_incorrect_endianness+=([all_files_index]="${each_sorted_f}")

      else

        : 'Crunchbangs'

        # q, does strings recognize unicode? Color codes? Cr's? Etc
        # test dd vs strings

        strings_o="$(strings -n1 < "${each_sorted_f}" \
          | head -n1 \
          | cut -b -$((2**14)) \
          || I_ "P:${PIPESTATUS[*]} I:${all_files_index} ${each_sorted_f}")"

        IFS= read -r first_line_printable <<< "${strings_o}" \
          || I_ "I:${all_files_index} ${each_sorted_f}"

        : '-#!comment-'
        if [[ "${first_line_printable}" =~ ^'#!comment' ]]; 
        then
          a_crunches_with_hashbang_comments+=(
            [all_files_index]="${each_sorted_f}")
          continue
        fi

        #D_ strings_o first_line_printable all_files_index each_sorted_f; L_;

        #   Note: with only /bin/sbin, this if-fi block doesn't execute


        # FR: sort also per-rpm, awk script, probably

        : 'outside of rpm'
        if ! rpm -qf "${each_sorted_f}" 2>/dev/null 1>&2; 
        then

          : 'user or system'
          if [[ "${each_sorted_f}" = /@(root|home|run/media)/* ]]; 
          then
            a_non_rpm_user_crunches+=([all_files_index]="${each_sorted_f}")
            continue
          else
            a_non_rpm_system_crunches+=(
              [all_files_index]="${each_sorted_f}")
            continue
          fi
        fi
      fi

      #X_; :_

      # scan non-shell scripts for shell escapes ie sys-bin calls
      # https://www.sans.org/blog/escaping-restricted-linux-shells/

      # Bug, "shell scripts" incls python perl etc

      # how to make IRT lists for each interpreter?

      : 'Make an array of the relevant filenames and their crashbangs.'
      a_shell_scripts+=([all_files_index]="$(printf \
        "%'-12d %%=%%=%%=%% %-50s %%=%%=%%=%% %s\n" \
          "${all_files_index}" "${first_line_printable}" \
          "${each_sorted_f}")"
        )

      #:_; D_ a_shell_scripts all_files_index first_line_printable each_sorted_f; L_
    else

      : 'all others'
      a_all_other_files+=([all_files_index]="$(printf \
        "%'-12d %%=%%=%%=%% %s\n" "${all_files_index}" \
          "${each_sorted_f}")"
        )
    fi
  done

  #X_; :_; D_ a_shell_scripts all_files_index first_line_printable each_sorted_f; L_

  # Note, you want to see the full crunchbangs in printed ASCII form

  : 'Open a timestamped file and append into it the list of filenames' 
  : 'and their crashbangs.'

  : 'Exporting is necessary of the array names from the above scan'
  a_arrays=( a_all_files a_all_files_sorted a_file_DNE a_empty_files a_bin_file_output a_bin_od_output a_incorrect_endianness a_crunches_with_hashbang_comments a_non_rpm_user_crunches a_non_rpm_system_crunches a_shell_scripts a_all_other_files a_write_path_nms )
  export  "${a_arrays[@]}"

  W_ "${a_arrays[@]}"; 
  B_ "${curr_time_ssubd}/file_out"; 
  #L_;

  : 'if any data files already exist, keep them'
  for any_existing_f in "${a_write_path_nms[@]}"; do

    if [[ -f "${any_existing_f}" ]] && [[ ! -L "${any_existing_f}" ]]; then
      S_ mv -- "${any_existing_f}" "${any_existing_f}.${$}.${random_n}" \
        || I_
    fi
  done

  : 'create the original list_crunchbangs'
  S_ touch -- "${a_write_path_nms[@]}"

  : 'write a file header'
  {
    printf '# crunchbangs -- %s\n' "${timecode%-*}"
    printf '# %s\n' "$(declare -p a_relevant_search_dirs)"
  } | S_ T_ -- "${a_write_path_nms[@]}" > /dev/null

  : 'printing contents of a_shell_scripts array, with backup'
  printf '%s\n' "${a_shell_scripts[@]}" \
    | S_ T_ -a -- "${a_write_path_nms[@]}" > /dev/null
  B_ "${a_write_path_nms[@]}"

else

  # the time_dir needs a copy of the crunchbangs file, also.  copy it in
  # from the hopefully correct backup in /tmp
  if [[ ! -f "${list_crunchbangs}" ]]; 
  then
    S_ rsync -ca -- "/tmp/${list_crunchbangs##*/}" "${list_crunchbangs}" \
      || I_
  fi
fi

  # <> ?
  W_ a_write_path_nms; 

  #X_; :_; 
  
  S_ head -- "/tmp/${list_crunchbangs##*/}"; 
  #L_;



: 'Verify interpreters'

: 'Get the list of interpreters from the list of crunchbangs.'
#   Note: new indices starting from 0
# use the contrived delimiter to capture entire shebang string
# remove leading whitespace
# sort and print unique
# remove leading ^'#!' from each interpreter
# shellcheck disable=SC2016
mapfile -t a_interpreters < <( 
  S_ awk 'BEGIN { FS = "%=%=%=%" } ; /#!/ { print $2 }' -- \
    "/tmp/${list_crunchbangs##*/}" \
    | awk 'BEGIN { FS = " -" } ; { print $1 }' \
    | sed 's, *,,g' \
    | sort -u \
    | cut -b3- \
    || I_ "P:${PIPESTATUS[*]}"
  )

  # <>
  :_; D_ a_interpreters; 
  #L_
  
# Duplicate with post-getopts section ?

: 'Ways to find an interpreter if it-s available on disk:'

# Bug: `realpath -e` and `command -V` are redundant?
# Answer: no. `command` is limited to PATH; realpath is limited by FS permissions.

# `find` can produce symlinks or actual files 
#   # find /usr/sbin -type l | grep resolvconf
#       /usr/sbin/resolvconf
# `command` can produce symlinks
#   # command -V resolvconf
#       resolvconf is /usr/sbin/resolvconf
# `realpath` produces physical paths
#   # realpath -e /usr/sbin/resolvconf
#       /usr/bin/resolvectl

for program in "${a_interpreters[@]}"; do
  : 'command -pV'
  command_o="$(command -pV "${program}" 2>&1)"
  
  if [[ -n "${command_o}" ]]; then 
    realpath_o="$(realpath -e "${command_o}" 2> /dev/null)"
    
    if [[ -f "${realpath_o}" ]]; then 
      a_interps_rps+=("${realpath_o}")
      m="exists on disk"; 
      break
    fi
  fi
done  

# Bug: add "-d ''" to mapfile

# Canonicalize interpreters paths, sort and list each unique binary.
#   Note: new indices starting from 0
mapfile -t a_interps_rps < <(
  S_ realpath -e -- "${a_interpreters[@]}" \
    | sort -u
  )

  # <>
  D_ a_interps_rps; L_
  
# for each interpreter, print it in the 1st 32 bits of a line.

{
for b in "${!a_interps_rps[@]}"; do

  printf '%-32s' "${a_interps_rps[b]}"; 

  # use a shell builtin to test for each interpreter's presence on disk, and write to a variable the test's result

  if command -pV "${a_interps_rps[b]}" > /dev/null; then 
    m="exists on disk"; 
  else 
    m="DNE on disk"; 
  fi; 

  # create a new array of structured data: index, interpreter and test result
  a_interps_disk_repo+=([b]="${b} : ${a_interps_rps[b]} : ${m}")
  
  # into the next 8 bits of a line, print the test result
  printf '%-8s' "${m}"; 

  # identify the originating rpm for each interpreter. 
  # binary need not be installed.
  # filter for rpm name by CPU type in its filename
  # sort rpms and print each unique
  dnf_po="$( S_ dnf provides -- "${a_interps_rps[b]}" \
    | awk '/x86_64|i686/ { print $1 }' \
    | sort -u 
    )"; 

  # based on whether there was any output, 
  # save a result message to variable
  if [[ -n "$dnf_po" ]]; then 
    n="exists in repos"; 
  else 
    n="DNE in repos"; 
  fi;

  # in the same array, in a different range of indices,
  # save the index, interpretet name and rpm test result
  a_interps_disk_repo+=([b+100]="${b} : ${a_interps_rps[b]} : ${n}")
  
  # print rpm test result to end of line; include a newline
  printf '\t\t\t\t%s\n' "${n}"; 
  
  # if any data exists, print the list of originating rpms
  printf '%s\n' "$dnf_po"; 
  unset dnf_po m n

done
} | S_ T_ -a -- "${curr_time_ssubd}a_interpreters" > /dev/null
unset b

  # <>
  #X_; :_; 
  W_ a_write_path_nms a_interpreters a_interps_rps a_interps_disk_repo
  L_



# SECTION E

: 'CENTRAL TASK, 1 OF 2: Filter the list of crashbangs with the list'
: 'of shells.'

# print one file header

{
  printf '# SC-scrpts-list -- %s\n' "${timecode%-*}"
  printf '# %s\n' "$(D_ a_relevant_search_dirs)"
} | S_ T_ -- "${list_crunchbangs}_SC-scrpts-list" > /dev/null

# filter out interpreters not compatible with shellcheck.
# file $list_crunchbangs is located in $time_dir.
S_ grep -E -- '/bin/'"${SC_shells}"'.*%=%=%=%' "${list_crunchbangs}" \
  | S_ tee -a -- "${list_crunchbangs}_SC-scrpts-list" \
  || I_

# Copy list to /tmp
S_ rsync -ca -- "${list_crunchbangs}_SC-scrpts-list" /tmp \
  || I_

# Backup both lists
B_ "${list_crunchbangs}_SC-scrpts-list" /tmp/*_SC-scrpts-list

  # <>
  X_; :_; W_ timecode list_crunchbangs SC_shells 
  L_



: 'CENTRAL TASK, 2 of 2: with ShellCheck scan each script for errors'

# TODO: keep "$all_files_index" tracked with content all the way through
#   into the "_found_scripts" file
# Bug? line 1 of script could contain percent symbols

: 'A hell world of pipelines'
#   Q: how to translate the correct newlines into nulls to separate the 
#   filenames when reading from a file?  awk? files _can_ contain \n-s

# for every line beginning with a crashbang...
grep_o="$(S_ grep ^'#!' -- "${list_crunchbangs}_SC-scrpts-list")"

# get the filename
cut_o="$(cut -d '%' -f5- <<< "${grep_o}")"

# collect the filenames in a single list
mapfile -t a_each_abspath_scriptnm <<< "${cut_o}"

# remove leading whitespace
a_each_abspath_scriptnm=("${a_each_abspath_scriptnm[@]##* }")

# Wk: awk , multi-char delim, remv lead+trail wspc - redef $0 ?, printf

#   grep -Eo | tr

# Bug: rename variable "$c" below
# Bug: why sort by line count? More text, more bugs? How to prior mult
#   factors?


# count number of newlines in each script
wc_o="$(S_ wc -l -- "${a_each_abspath_scriptnm[@]}")"

# remove 'totals' line
wc_o="${wc_o%$'\n*'}"

# sort script lengths descending
sort_o="$(sort -gr <<< "${wc_o}")"

# print script names
awk_o="$(awk '{ print $2 }' <<< "${sort_o}")"

# create a list of script names sorted by line count descending
mapfile -t a_each_script_list_sorted_by_linect \
  <<< "${awk_o}"

# define file name, including severity and path symbols (target file)
found_scrpts_f="${list_crunchbangs}_found_scripts_${sc_severity:0:1}_${abbrev_rel_search_dirs}"
i=0

# Bug? 1st grep extra?

{

  # for each sorted script
  for sorted_script in "${!a_each_script_list_sorted_by_linect[@]}"; do

    # run shellcheck with selected/default severity
    # remove URL's
    # capture SC error codes with their descriptions
    # truncate descriptions to 64 bytes
    # sort numerically
    # count the number of unique errors
     # sort by the third column: severity
     # collect output in an array
     # on any non-zero exit status, print an error, incuding PIPEFAIL array, and exit the script
     # when filters, etc completes, print a NULL to start a new mapfile index
     mapfile -d '' -t a_each_script_SC_results < <(
      shellcheck -S "${sc_severity}" \
        "${a_each_script_list_sorted_by_linect[sorted_script]}" \
        | grep -Fv 'shellcheck.net' \
        | grep -Eo "SC[0-9]{4}.*" \
        | cut -b -64 \
        | sort -g \
        | uniq -c \
        | sort -k3 \
        || I_ "P:${PIPESTATUS[*]} I: S:" # index and script name
          # end of pipe intended 
      printf '\0'
    )

    # if there's any output from shellcheck
    if [[ -n "${a_each_script_SC_results[*]:0:1}" ]]; then

      # Bug: iterator sb $sorted_script ? sorted_script should have

      # print a line header. (as-is:) including a new index number for each script
      printf '\n%-4d%s\n' $((i++)) \
        "${a_each_script_list_sorted_by_linect[sorted_script]}"
      # print all massaged SC results for each script
      printf '%s' "${a_each_script_SC_results[@]}"
    fi
  done; unset i
  
# append each text group to a findings file
} | S_ tee -a -- "${found_scrpts_f}" > /dev/null


: 'Write semi-permanent archives'

# backup the findings file
B_ "${found_scrpts_f}"

# make copies of the findings file and backup those copies
for d in /tmp "${main_d}"; do
  S_ rsync -ca -- "${found_scrpts_f}" "${d}" \
  || I_
  B_ "${d}/${found_scrpts_f##*/}"
done; unset d

  # <> Print some variables   for interactive use
  z=0
  for d in "${curr_time_ssubd}" "${main_d}" /tmp; do 
    printf '\n\t data_d_%d=%s\n' $((z++)) "${d}"
  done; unset d z

trap - EXIT
exit 00
