#!/bin/bash
# Written in bash version 5.1 on Fedora 37 & 38

# Note: Keep your goal in mind.

# SECTION A

: 'Regular users only, and -sudo- required'

if [[ "${UID}" == 0 ]]; then
  printf '\n\t Must be a regular user and use sudo. \n\n'
  exit 1
else
  if ! sudo -v; then
    printf '\n\tValidation failed of user\x27s \x60sudo\x60 timestamp; '
    printf 'exiting.\n\n'
    exit "${LINENO}"
  fi
fi

: 'Environment variables'

unset LC_ALL Halt
declare -rx Halt
FUNCNEST=8
GREP_COLORS='mt=01;43'
LC_COLLATE="C.UTF-8"     # for predictable sorting
LC_CTYPE="C.UTF-8"       #  "   "           "
LC_NUMERIC="en_US.UTF-8" # for commas in large numbers
getconf_o="$(/usr/bin/command -p getconf PATH)" \
  || "${Halt:?}"
PATH="${getconf_o}:/usr/bin:/usr/sbin:${PATH}"
PS4='+${BASH_SOURCE[0]}:${LINENO}:${FUNCNAME[0]}: '
export FUNCNEST GREP_COLORS LC_COLLATE LC_CTYPE LC_NUMERIC PATH PS4

: 'Implementation-dependent arguments for options parsable by ShellCheck'

sc_severity=error
SC_shells='(sh|bash|dash|ksh)'

: 'Variables more likely to be manually changed'

protected_git_dir_1="${HOME}/MYPROJECTS"
protected_git_dir_2="${HOME}/OTHERSPROJECTS"
repo_nm=scf
script_dirnm="${repo_nm}.d"
script_lic='Apache 2 license'
script_nm=find-and-scan-shell-scripts-sh
script_proper_nm='Script Finder'
script_version=1.0

: 'Other user variables and arrays'

a_poss_proces_lock_dirs=([0]="${XDG_RUNTIME_DIR}" [1]="${HOME}"
  [2]="${TMPDIR:-/tmp}" [3]=/tmp [4]=/var/tmp)
random_n="${RANDOM}"
unique_string="${repo_nm}.${$}.${random_n}"
mktemp_sfx=".${unique_string}.txt"
proc_lk_f_nm="${unique_string}.lock"
timecode="$(builtin printf '%(%F_%H%M%S)T')"
for pld in "${a_poss_proces_lock_dirs[@]}"; do
  process_lock_dirs+=("${pld}/${proc_lk_f_nm}")
done; unset pld

: '<> Debug Variables' # "<>" means, "This is a debugging section."

abbrev_rel_search_dirs=/
# "${Halt:?}"

: '<> Debug Aliases'

shopt -s expand_aliases
alias :_=':;: "<>"'
alias D_='declare -p '
alias F_='IFS=":" read -ra find_path <<<"${bash_path}"'
alias L_='exit "${LINENO}"'
alias M_='sudo namei -xl '
alias R_='rm --one-file-system --preserve-root=all '
alias S_='sudo '
alias T_='tee --output-error=exit '
alias X_='set -x'

: 'Delete any left over xtrace files in /tmp'

mapfile -d "" -t xtrace_files < <(
  find /tmp -maxdepth 1 -type f \
    -name "tmp.[a-zA-Z0-9]*.scf.[0-9]*.[0-9]*.txt" -print0 
)

# ...if theyre files & not symlinks, & owned by the same EUID.
for f in "${xtrace_files[@]}"; do
  if [[ -f "${f}" ]] \
    && [[ ! -L "${f}" ]] \
    && [[ -O "${f}" ]];
  then
    R_ "$f"
  fi
done; unset f

: 'Traps'

trap '
  trap - DEBUG

  # Delete all possible existing process _lock_directories_. 
  for pld in "${process_lock_dirs[@]}"; do 

    #[[ "${pld}" =~ "$$"*.lock ]] \
      #|| continue

    # test and delete lock directories.
    if [[ -d "${pld}" ]] && [[ ! -L "${pld}" ]]; then 
      echo S_ R_ -rf -- "${pld}" \
        || L_
    fi
  done; unset pld

    # <>
    #: "${Halt?}"

  # Remove any script-s ACL-s based on canary variables
  if [[ -n "${acl_execd_setfacl}" ]]; then 

    if [[ -n "${acl_abs_path}" ]]; then 
      
      # Manual (non-alias/function) error handling reqd wi traps
      if ! S_ setfacl -R -x "u:${UID}" -- "${acl_abs_path}"; then
        echo Error: trap: setfacl failed, line "${LINENO}"
        : "${Halt:?}"
      fi

    # Bug? Should this var \/ be main_d ?

    elif [[ -v mountpoint ]] \
      || [[ -v main_d ]] 
    then
      if ! S_ setfacl -R -x "u:${UID}" -- "${mountpoint}"; then 
        echo Error: trap: setfacl failed, line "${LINENO}"
        : "${Halt:?}"
      fi
    fi
  fi

  trap - EXIT INT TERM
  kill -s INT "$$"
' EXIT INT TERM

: '<> Table of traps' # Learning about how `bash` uses signals

# trap 'set -x; echo SIGEXIT;   trap SIGEXIT;   kill -s INT $$' EXIT # 0
trap 'set -x; echo SIGHUP;    trap SIGHUP;    kill -s 2   $$' HUP # 1
# trap 'set -x; echo SIGINT;    trap 2;         kill -s 2   $$' 2 # INT
#   ^--- ^C
trap 'set -x; echo SIGQUIT;   trap SIGQUIT;   kill -s 2   $$' QUIT # 3
trap 'set -x; echo SIGILL;    trap SIGILL;    kill -s 2   $$' ILL  # 4
trap 'set -x; echo SIGTRAP;   trap SIGTRAP;   kill -s 2   $$' TRAP # 5
trap 'set -x; echo SIGABRT;   trap SIGABRT;   kill -s 2   $$' ABRT # 6
trap 'set -x; echo SIGBUS;    trap SIGBUS;    kill -s 2   $$' BUS  # 7
trap 'set -x; echo SIGFPE;    trap SIGFPE;    kill -s 2   $$' FPE  # 8
# trap 'set -x; echo SIGKILL;   trap SIGKILL;   kill -s 2   $$' KILL # 9
#   ^--- cannot be caught, per `shellcheck`
trap 'set -x; echo SIGUSR1;   trap SIGUSR1;   kill -s 2   $$' USR1 # 10
trap 'set -x; echo SIGSEGV;   trap SIGSEGV;   kill -s 2   $$' SEGV # 11
trap 'set -x; echo SIGUSR2;   trap SIGUSR2;   kill -s 2   $$' USR2 # 12
trap 'set -x; echo SIGPIPE;   trap SIGPIPE;   kill -s 2   $$' PIPE # 13
trap 'set -x; echo SIGALRM;   trap SIGALRM;   kill -s 2   $$' ALRM # 14
# trap 'set -x; echo SIGTERM;   trap SIGTERM;   kill -s 2   $$' TERM # 15
trap 'set -x; echo SIGSTKFLT; trap SIGSTKFLT; kill -s 2 $$' STKFLT # 16
# trap 'set -x; echo SIGCHLD;   trap SIGCHLD;   kill -s 2   $$' CHLD # 17
#   ^--- triggered by returning command substitution
trap 'set -x; echo SIGCONT;   trap SIGCONT;   kill -s 2   $$' CONT # 18
# trap 'set -x; echo SIGSTOP;   trap SIGSTOP;   kill -s 2   $$' STOP # 19
#   ^--- cannot be caught, per `shellcheck`
trap 'set -x; echo SIGTSTP;   trap SIGTSTP;   kill -s 2   $$' TSTP # 20
trap 'set -x; echo SIGTTIN;   trap SIGTTIN;   kill -s 2   $$' TTIN # 21
trap 'set -x; echo SIGTTOU;   trap SIGTTOU;   kill -s 2   $$' TTOU # 22
trap 'set -x; echo SIGURG;    trap SIGURG;    kill -s 2   $$' URG  # 23
trap 'set -x; echo SIGXCPU;   trap SIGXCPU;   kill -s 2   $$' XCPU # 24
trap 'set -x; echo SIGXFSZ;   trap SIGXFSZ;   kill -s 2   $$' XFSZ # 25
trap 'set -x; echo SIGVTALRM; trap SIGVTALRM; kill -s 2 $$' VTALRM # 26
trap 'set -x; echo SIGPROF;   trap SIGPROF;   kill -s 2   $$' PROF # 27
#trap 'set -x; echo SIGWINCH;  trap SIGWINCH;  kill -s 2  $$' WINCH # 28
trap 'set -x; echo SIGIO;     trap SIGIO;     kill -s 2   $$' IO   # 29
trap 'set -x; echo SIGPWR;    trap SIGPWR;    kill -s 2   $$' PWR  # 30
trap 'set -x; echo SIGSYS;    trap SIGSYS;    kill -s 2   $$' SYS  # 31
trap 'set -x; echo SIGRTMIN;  trap SIGRTMIN;  kill -s 2  $$' RTMIN # 32

: '<> XTrace variables and functions'

funclvl=0
fence=' ++++++++++++++++++++++++++++++++++++++++++++ '
export setenv_prev setenv_now setenv_delta env_prev env_now env_delta

# If xtrace was previously on, then on first execution of this function,
# turn xrtrace off, and on second execution, turn xtrace back on and
# forget about this function's settings. If xtrace was previously off,
# then leave it off.

_xtrace_duck() {
  : '_xtrace_duck BEGINS' "$((++funclvl))" "${fence}"
  local hyphen="$-"

  # If xtrace is on...
  if [[ "${hyphen}" =~ x ]]; then

    # ...then record its state
    local -g xtrace_prev
    export xtrace_prev

    # and turn xtrace off
    set -

  # but if xtrace is off...
  else
    # ...then if xtrace was previously on...
    if [[ -n "${xtrace_prev}" ]]; then

      # ...then restore xtrace and unset its variable
      set -x
      unset xtrace_prev

    # but if xtrace is off and was previously off...
    fi
  fi
  : '_xtrace_duck ENDS  ' "$((--funclvl))" "${fence}"
}

_mk_setenv_prev() {
  : '_mk_setenv_prev BEGINS' "$((++funclvl))" "${fence}"
  if [[ -n "${setenv_now}" ]]; then

    if [[ -n "${setenv_prev}" ]]; then
      R_ -f -- "${setenv_prev}"
    fi
    setenv_prev="${setenv_now}"
  fi
  : '_mk_setenv_prev ENDS  ' "$((--funclvl))" "${fence}"
}

_mk_setenv_now() {
  : '_mk_setenv_now BEGINS' "$((++funclvl))" "${fence}"
  setenv_now="$(mktemp --suffix="${mktemp_sfx}")"
  set \
    |& tee -- "${setenv_now}" >/dev/null
  env \
    |& tee -a "${setenv_now}" >/dev/null
  : '_mk_setenv_now ENDS  ' "$((--funclvl))" "${fence}"
}

_mk_setenv_delta() {
  : '_mk_setenv_delta BEGINS' "$((++funclvl))" "${fence}"
  if [[ -n "${setenv_now}" ]] && [[ -n "${setenv_prev}" ]]; then

    if [[ -n "${setenv_delta}" ]]; then
      R_ -f -- "${setenv_delta}"
      # [line 1] rm --one-file-system --preserve-root=all -f -- \
      #   /tmp/tmp.HjN8ow8GHi.scf.32869.15382.txt
      wait -f
    else
      setenv_delta="$(mktemp --suffix="${mktemp_sfx}")" #
    fi

    {
      diff -y --suppress-{common-lines,blank-empty} --color=never \
        "${setenv_prev}" "${setenv_now}" \
        |& grep -v setenv \
        | grep --color=always -E '.*'
    } \
      |& tee -- "${setenv_delta}"
    # [line 2] tee -- /tmp/tmp.HjN8ow8GHi.scf.32869.15382.txt

    {
      diff --suppress-{common-lines,blank-empty} --color=always \
        --palette="ad=1;3;38;5;190:de=1;3;38;5;129" \
        "${setenv_prev}" "${setenv_now}" \
        | grep -ve BASH_LINENO -e BASH_COMMAND -e BASH_SOURCE \
          -e setenv_ -Fe '---'
    } \
      |& tee -a "${setenv_delta}"

    GREP_COLORS='mt=01;104'
    export GREP_COLORS
    wc "${setenv_delta}" \
      | grep --color=always -E '.*'
    GREP_COLORS='mt=01;43'
    export GREP_COLORS
  fi
  : '_mk_setenv_delta ENDS  ' "$((--funclvl))" "${fence}"
}

_mk_deltas() {
  : '_mk_deltas BEGINS' "$((++funclvl))" "${fence}"
  _xtrace_duck
  _mk_setenv_prev
  _mk_setenv_now
  _mk_setenv_delta
  _xtrace_duck
  : '_mk_deltas ENDS  ' "$((--funclvl))" "${fence}"
}

# ? what of BASH_LINENO

_debug_prompt() {
  : '_debug_prompt BEGINS' "$((++funclvl))" "${fence}"
  _mk_deltas
  read -rp "[${BASH_SOURCE[0]}:${LINENO}] ${BASH_COMMAND[0]}?" _
  : '_debug_prompt ENDS  ' "$((--funclvl))" "${fence}"
}

_full_xtrace() {
  : '_full_xtrace BEGINS' "$((++funclvl))" "${fence}"
  #set -o functrace
  trap '_debug_prompt "$_";' DEBUG
  set -x
  : '_full_xtrace ENDS  ' "$((--funclvl))" "${fence}"
}

#exit 101
#_full_xtrace

: 'Regualar script Functions'

fn_bak() {
  : 'fn_bak BEGINS' "$((++funclvl))" "${fence}"

  # for each of multiple input files
  for loc_filename_a in "${@}"; do

    # test verifying existence of input
    if S_ test -f "${loc_filename_a}"; then

      # Bug: Why does this ^ test req sudo when this test \/ doesnt?

      # if the destination (.bak) file already exists,
      # then age it first.
      if [[ -f "${loc_filename_a}.bak" ]]; then

        if [[ -s "${loc_filename_a}.bak" ]]; then
          return
        else
          S_ R_ -f -- "${loc_filename_a}.bak"
        fi
      fi

      # write a new .bak file
      S_ rsync -acq -- "${loc_filename_a}"{,.bak} \
        || E_ "${LINENO}"

    # if input file DNE, then print an error and exit
    else
      {
        echo WARNING: file DNE "${loc_filename_a}"
        return
      }
    fi
  done
  : 'fn_bak ENDS  ' "$((--funclvl))" "${fence}"
}

fn_erx() {
  local loc_exit_code="${?}" # this assignment must be the first command
  : 'fn_erx BEGINS' "$((++funclvl))" "${fence}"

  # print an error message and exit with the correct exit code
  echo -e Error: "${@}"
  exit "${loc_exit_code}"
  : 'fn_erx ENDS  ' "$((--funclvl))" "${fence}"
}

#fn_num() {
#  : 'fn_num BEGINS' "$((++funclvl))" "${fence}"
#  # Usage: N_ [raw arrays names]
#
#  # for each of multiple input array names
#  for loc_unquotd_array_nm_a in "${@}"; do
#
#    # set a local name reference variable
#    local -n loc_nameref_a="${loc_unquotd_array_nm_a}"
#
#    # and use the nameref to print the number of indices in the
#    # input array
#    echo ${#loc_nameref_a[@]}
#  done
#  : 'fn_num ENDS  ' "$((--funclvl))" "${fence}"
#}

fn_write_arrays() {
  : 'fn_write_arrays BEGINS' "$((++funclvl))" "${fence}"
  # Write each array to a file on disk.
  # Usage: W_ [arrays]

  loc_write_d_b="${curr_time_ssubd}arrays"

  if [[ ! -d "${loc_write_d_b}" ]]; then
    S_ mkdir -p -- "${loc_write_d_b}" \
      || E_ "${LINENO}"
  fi

  # for each of multiple input array names
  for loc_unquotd_array_nm_b in "${@}"; do

    # create local variables, for use as both array and string
    local -n loc_nameref_b="${loc_unquotd_array_nm_b}"
    loc_array_nm="${loc_unquotd_array_nm_b}"
    loc_write_f_b="${loc_write_d_b}/_${sc_sev_abrv}"
    loc_write_f_b+="_${abbrev_rel_search_dirs}_${loc_array_nm}"

    # solved?  Bug: mixing variable and array. sb a nameref

    # Bug? When array correctly is empty.
    #   'declare -p ... > /dev/null ||' ?

    # if the input array holds no data, then populate it
    if [[ ! -v loc_nameref_b[@] ]]; then
      loc_nameref_b=([0]='fn_write_arrays: Empty array')
    fi

    # then write a data file to disk
    declare -p "${loc_array_nm}" \
      | S_ T_ -- "${loc_write_f_b}" >/dev/null

    # write a backup of the new data file
    B_ "${loc_write_f_b}"
  done
  : 'fn_write_arrays ENDS  ' "$((--funclvl))" "${fence}"
}

#fn_write_vars() {
#  : 'fn_write_vars BEGINS' "$((++funclvl))" "${fence}"
#  # Usage: V_ [loc_script_section_nm] [raw variable names]
#
#  # first pos-parm is string used for differentiating filename
#  loc_script_section_nm="${1}"
#  loc_write_f_a="${curr_time_ssubd}/${loc_script_section_nm}_vars"
#  shift
#
#  # if the destination file already exists, then return from FN
#  [[ -e "${loc_write_f_a}" ]] \
#    && return
#
#  # write a new data file
#  declare -p "${@}" 2>/dev/null \
#    | S_ T_ -- "${loc_write_f_a}" >/dev/null
#
#  # and write a .bak file
#
#  B_ "${loc_write_f_a}"
#  : 'fn_write_vars ENDS  ' "$((--funclvl))" "${fence}"
#}

: '<> Debug Functions' # Abreviations of arrays of previous section

function B_() {
  : 'B_ BEGINS' "$((++funclvl))" "${fence}"
  fn_bak "$@"
  : 'B_ ENDS  ' "$((--funclvl))" "${fence}"
}
function E_() {
  : 'E_ BEGINS' "$((++funclvl))" "${fence}"
  fn_erx "$@"
  : 'E_ ENDS  ' "$((--funclvl))" "${fence}"
}
#function N_() {
#  : 'N_ BEGINS' "$((++funclvl))" "${fence}"
#  fn_num "$@";
#  : 'N_ ENDS  ' "$((--funclvl))" "${fence}"
#};
#function V_() {
#  : 'V_ BEGINS' "$((++funclvl))" "${fence}"
#  fn_write_vars "$@";
#  : 'V_ ENDS  ' "$((--funclvl))" "${fence}"
#};
function W_() {
  : 'W_ BEGINS' "$((++funclvl))" "${fence}"
  fn_write_arrays "$@"
  : 'W_ ENDS  ' "$((--funclvl))" "${fence}"
}

: 'Required programs'

reqd_progs=(strings)
unset b reqd_progs_exit # [Line 1] +./find-and-scan-shell-scripts-sh:302:: unset b reqd_progs_exit
for b in "${reqd_progs[@]}"; do
  if ! hash "${b}" 2>/dev/null; then
    if [[ -z "${reqd_progs_exit}" ]]; then
      reqd_progs_exit=yes
      printf '\n\tThe following programs are required:\n'
    fi
    printf '\t\t%s\n' "${b}"
  fi
done
unset b # [Line 2] +./find-and-scan-shell-scripts-sh:311:: unset b
# ^--- added `wait -f` at line302
if [[ "${reqd_progs_exit}" == yes ]]; then
  echo
  exit 1
fi

: 'Option parsing'

if [[ $# -gt 0 ]]; then
  cli_input=("${@}")
fi

#exit 101
#_full_xtrace

: 'Variables re getopts'
unsaf_ascii=(
  [0]="|" [1]="&" [2]=";" [3]="(" [4]=")" [5]="<"
  [6]=">" [7]=" " [8]=$'\t' [9]=$'\n' [10]="||" [11]="&&"
  [12]=";;" [13]=";&" [14]=";;&" [15]="|&" [16]="!" [17]="{"
  [18]="}" [19]="[" [20]="]" [21]="[[" [22]="]]" [23]="\$"
  [24]="="
)
readonly unsaf_ascii
bash_path_orig="${PATH}"
bash_path="${bash_path_orig}"
easter_egg="$(
  printf '%s%s%s' 'CgkiSSB3b3VsZCBoYXZlIG1hZGUgdGhpcyBzaG9y' \
    'dGVyLCBidXQgSSBkaWRuJ3QgaGF2ZSB0aGUg' \
    'dGltZS4iCgkJLS0gTWFyayBUd2FpbgoK' \
    | base64 -d
)"
find_exclude_optargs_default=(
  [0]='(' [1]='!' [2]='-name' [3]='proc' [4]='-a' [5]='!'
  [6]='-name' [7]='sys' [8]='-a' [9]='!' [10]='-iname'
  [11]="${script_dirnm}*" [12]='-a' [13]='!' [14]='-ipath'
  [15]="${protected_git_dir_1}" [16]='-a' [17]='!' [18]='-ipath'
  [19]="${protected_git_dir_2}" [20]='-a' [21]='!' [22]='-path'
  [23]='*/git/*' [24]=')'
)
find_exclude_optargs=()
IFS=':' read -ra find_path <<<"${bash_path}"
find_sym_opt_L='-L'
memory_usage=temp_files
sc_sev_abrv="${sc_severity:0:1}"
methods_recurse_n=no
methods_path=('as-is')
methods_prog_cv=bash_command_V
methods_scan_excluded_by=yes
methods_symlinks_l=logical
verify=(all)

: 'Functions re getopts'

fn_usage() {
  # Print a usage message and exit with a pre-determined exit code
  # Usage:  fn_usage [exit-code]
  : 'fn_usage BEGINS' "$((++funclvl))" "${fence}"
  {
    cat <<-EOF
  ${repo_nm} - ${script_proper_nm}, version ${script_version}
    Find and scan shell scripts depending on severity level. 
    Options are parsed by bash's builtin "getopts".
  Usage:
    ./${script_nm} -H [b|p|l] -M [r|p|t] 
      -P [ac|as|bi|bo|ge|sb|pr|sy] -R [DIRECTORY] -S [e|i|s|w] 
      -V -X [r|p|t] -h -p [ba|cp|cv|fi|ty] -q [a|c|d|i|l|p|u] 
      -r [d|y|n] -s [s|y|n]

      l:  Follow symlinks         m:  Memory usage
        [p]   physical              [r]   RAM only
       *[l]   logical               [p]   Persistent storage
      d:  Path                     *[t]   Temporary files
        [ac]  Actually all        h   Help message
        [al]  All                 p:  Progam and method
       *[as]  As-is                                    
        [bi]  /bin only             [cp]  builtin "command -pV"
        [bo]  Both /{,s}bin only   *[cv]  builtin "command -V"
        [ge]  Getconf PATH only     [fi]  "find" binary
        [sb]  /sbin only            [ty]  builtin "type -a"
        [pr]  Add /proc           q:  Validate information
        [sy]  Add /sys             *[a]   all
      a:  Path                      [c]   add crashbangs
        [DIR]  Add search dir       [d]   add DACs
      c:  Severity level            [i]   add interpreters
       *[e]   error                 [l]   add ACLs
        [i]   info                  [p]   add PATH
        [s]   style                 [u]   unset all
        [w]   warning             r:  Recurse into dirs
      v   Version                   [d|y] Yes   *[n] No
      s:  Scan excluded dirs      *:  Help message
       *[s|y|b] Yes   [n] No       
EOF
  } | more -e
  : 'fn_usage ENDS  ' "$((--funclvl))" "${fence}"
  exit "${1}"
}

#exit 101
#_full_xtrace

shopt -s nocasematch
while getopts "a:bc:d:hl:m:p:q:r:s:v" cli_input; do

  # Parse command line options
  case "${cli_input}" in

    # PATH (array) - Part 2 - options with args
    a)
      # Input validation, more thorough. Remove unprintable strings.
      OPTARG="$(strings -n1 <<<"${OPTARG}")"

      # Bug: sb a printf one liner
      # for i in DECIMALS; do printf '%b' "\\${i}"; done #...

      # Bug: \/ this PE probably doesn't work

      # Remove unsafe characters
      new_optarg="${OPTARG//["${unsaf_ascii[@]}"]/}"

      # If any ASCII characters were removed, print an error and exit
      if [[ "${new_optarg}" != "${OPTARG}" ]]; then
        printf '\n\tError: option -R: directory name includes '
        printf 'an illegal character\n\n'
      fi

      # Canonicalize path
      new_optarg="$(realpath -e "${new_optarg}")"

      # Amended value must be a directory
      if [[ ! -d "${new_optarg}" ]]; then
        "${arg_wrong__a:?}"
      fi

      # Append dirname to bash_path and reset find_path
      bash_path+=":${new_optarg}"
      F_

      # adjust tracking array
      new_optarg="${new_optarg//\//_}"
      methods_path+=("add_dir_${new_optarg}")
      ;;

    # Easter egg
    b)
      printf '%s' "${easter_egg}"
      exit 0
      ;;

    # ShellCheck's '-S' setting, ie, severity level. Default is error.
    c) case "${OPTARG:0:1}" in
      e*) sc_severity=error ;;
      i*) sc_severity=info ;;
      s*) sc_severity=style ;;
      w*) sc_severity=warning ;;
      *) "${arg_wrong__c:?}" ;;
    esac ;;

    # PATH (array) - Part 1 -
    #   These options with have no arguments. The default is 'as-is'.
    # '-P /usr/share' is an option with an argument. For scanning
    # '/proc' or '/sys', see also option 's'. Multiple abbreviations
    # are accepted. For consistency, find_path is always defined after
    # bash_path, regardless of which one is used. Clobbering settings
    # are: ac as bi bo ge sb. Additive PATH settings, but the Program
    # setting gets clobbered, are: pr sy.
    d) case "${OPTARG:0:2}" in

      ac* | aa*)
        bash_path='/'
        F_
        find_exclude_optargs=()
        methods_path=(actually_all) 
        methods_prog_cv=bin_find
        methods_scan_excluded_by=yes
        ;;
      al* )
        bash_path='/'
        F_
        find_exclude_optargs=("${find_exclude_optargs_default[@]}")
        methods_path=(all) 
        methods_prog_cv=bin_find
        methods_scan_excluded_by=no
        ;;
      as* | ai*)
        bash_path="${bash_path_orig}"
        F_
        methods_path=('as-is') 
        ;;
      bi* | b)
        bash_path='/usr/bin'
        F_
        methods_path=(bin_only) 
        ;;
      bo* | bs*)
        bash_path='/usr/bin:/usr/sbin'
        F_
        methods_path=(both_bin_sbin_only)
        ;;
      ge* | g)
        bash_path="${getconf_o}"
        F_
        methods_path=(getconf_PATH_only) 
        ;;
      sb* | so* | s)
        bash_path='/usr/sbin'
        F_
        methods_path=(sbin_only) 
        ;;
      pr* | p | pa*)
        bash_path+=':/proc'
        F_
        methods_path+=(add_proc) 
        methods_prog_cv=bin_find
        find_exclude_optargs=()
        methods_scan_excluded_by=yes
        ;;
      sy* | sa*)
        bash_path+=':/sys'
        F_
        methods_path+=(add_sys) 
        methods_prog_cv=bin_find
        find_exclude_optargs=()
        methods_scan_excluded_by=yes
        ;;
      *) "${arg_wrong__d:?}" ;;
    esac ;;

    # Help message
    h) fn_usage 0 ;;

    # Follow symlinks
    #   `bash` always follows symlinks, therefore to not follow any
    # symlinks requires `find` and is a clobbering setting, ie,
    # selecting either '-h P' or '-h L' will also select the use of
    # `find`. The 'P' and 'L' refer to `find`s first argument, which
    # by default is assumed (by `find`) to be '-P'. `find -H` is not
    # implemented in this script. Default is bash.
    #   Side effect: setting '-l p' also clobbers this variable. Side
    # effects such as these are marked below as "clobber."
    #   This parameter expansion, ':?', when a parameter is null or
    # unset, causes the shell to immediately halt, ignoring any trap
    # on EXIT.
    #   Mis-spellings beyond the first one or two letters are allowed.
    l)
      case "${OPTARG:0:1}" in
        l* ) # follow symlinks
          methods_symlinks_l=logical
          find_sym_opt_L='-L' 

          case "${methods_prog_cv}" in
            *find)
              methods_recurse_n=yes 
              find_exclude_optargs=("${find_exclude_optargs_default[@]}")
              methods_scan_excluded_by=no 
              ;;
            *bash*)
              methods_recurse_n=no 
              find_exclude_optargs=()
              methods_scan_excluded_by=yes
              ;;
            *) "${arg_wrong__l:?}" 
              ;;
          esac
          ;;
        p* ) # never follow symlinks
          methods_prog_cv=bin_find
          methods_symlinks_l=physical 
          find_sym_opt_L='-P' 
          methods_recurse_n=yes 
          find_exclude_optargs=("${find_exclude_optargs_default[@]}")
          methods_scan_excluded_by=no 
          ;;
        *) "${arg_wrong__l:?}" ;;
      esac ;;

    # Whether and how to save data. Default is temp files.
    m) case "${OPTARG:0:1}" in
      p*) memory_usage=persistent_storage ;;
      r*) memory_usage=RAM_only ;;
      t*) memory_usage=temp_files ;;
      *) "${arg_wrong__m:?}" ;;
    esac ;;

    # Program to search with. All settings clobber; bash is default
    p) case "${OPTARG:0:2}" in
      [bct]*)
        methods_recurse_n=no 
        methods_symlinks_l=logical
        find_exclude_optargs=()
        methods_scan_excluded_by=yes

        case "${OPTARG:0:2}" in
          c|c[a-p]*) methods_prog_cv=bash_command_pV ;;
          c[q-z]*) methods_prog_cv=bash_command_V ;;
          t* ) methods_prog_cv=bash_type_a ;;
        esac
        ;;
      f*) 
        methods_prog_cv=bin_find 
        methods_recurse_n=yes 
        find_exclude_optargs=("${find_exclude_optargs_default[@]}")
        methods_scan_excluded_by=no 
        ;;
      *) 
        "${arg_wrong__p:?}" 
        ;;
    esac ;;

    # What information to verify. The default is all.
    q) case "${OPTARG:0:2}" in
      l | al*) verify=(all) ;;
      u | un*) unset verify ;;
      *) [[ "${verify[*]}" =~ all ]] \
        && unset verify ;;&
      a | ac*) verify+=(acls) ;;
      c | cr*) verify+=(crashbangs) ;;
      d | da*) verify+=(dacs) ;;
      i | in*) verify+=(interpreters) ;;
      p | pa*) verify+=(path) ;;
      *) "${arg_wrong__q:?}" ;;
    esac ;;

    # Descend into dirs (recurse)
    #   `bash`s path search cannot descend into dirs; for `find` the
    # default is to 'do descend' into dirs. For this script, the default
    # for descending follows `bash`, and changing this setting to 'yes',
    # 'recurse' or 'descend' switches the search program to `find`.
    # `find`s '-mindepth' and '-maxdepth' are not used.
    #unset bash_path # why unset it? the setting '-r' could be
    # reversed later on the same command line
    #unset find_path # again, why unset it?
    r) case "${OPTARG:0:1}" in
      r | d | y) 
        methods_prog_cv=bin_find 
        methods_recurse_n=yes 
        find_exclude_optargs=("${find_exclude_optargs_default[@]}")
        methods_scan_excluded_by=no 
        ;;
      n) 
        #methods_prog_cv= # could be any of command_pV command_V type_a
        methods_recurse_n=no 
        
        if [[ "${methods_prog_cv}" =~ find ]]; then
          methods_prog_cv=bash_command_V
        fi
            
        find_exclude_optargs=()
        methods_scan_excluded_by=yes
        methods_symlinks_l=logical
        find_sym_opt_L='-L' 
        ;;
      *) 
        "${arg_wrong__r:?}" 
        ;;
    esac ;;

    # Scan excluded dirs
    #   By default, this script assumes for `find` a set of automatic-
    # ally excluded search directories that often prove to be somewhat
    # problematic: '/proc', '/sys', and anything with a find '-path'
    # of either '*/git/*' or this script's repo's name. With a default
    # PATH setting, `bash` usually also skips these directories. The 
    # default is bash, so disabling this option indicates the wish to 
    # use `find`, and so clobbers `bash`. To explicitly add '/proc' or 
    # '/sys' to your search path, see option 'd', 'add_proc' and 'add_sys'.
    s) case "${OPTARG:0:1}" in
        s | y | b) 
          find_exclude_optargs=() 
          methods_scan_excluded_by=yes 
          ;;

        n) 
          methods_recurse_n=yes
          methods_prog_cv=bin_find
          find_exclude_optargs=("${find_exclude_optargs_default[@]}")
          methods_scan_excluded_by=no 
         
          # if /proc or /sys have been added to the list of dirs to 
          # be searched, then remove each of them from each of the
          # variables they've been added to. Then reassign find_path.

          # if /proc or /sys...
          for x in /proc /sys; do

            # (loop in case ':/proc' or ':/sys' have been added multiple 
            # times)
            while :; do
              
              # ...have been added to the list of dirs to be searched...
              if [[ "${bash_path}" =~ ${x} ]]; then

                # then remove them, first from $bash_path...
                bash_path="${bash_path//:"${x}"}"
              
              # (finish the loop when there aren'r any more ':/proc's or 
              # ':/sys's in bash_path)
              else
                break
              fi
            done

            # ...then remove them from methods_path.
            if [[ "${methods_path[*]}" =~ ${x#/} ]]; then
            
              # (iterate through each index)
              for i in "${!methods_path[@]}"; do
              
                if [[ "${methods_path[i]}" =~ ${x#/} ]]; then
                  unset 'methods_path[i]'
                fi  
              done
            fi

            # and then re-assign find_path
            F_
          done
          ;;
        *) 
          "${arg_wrong__s:?}" 
          ;;
      esac ;;

    v) printf '\n\t%s, version %s. %s.\n\n' "${script_proper_nm}" \
      "${script_version}" "${script_lic}" ;;

    *) fn_usage 1 ;;
  esac
done
shopt -u nocasematch

#D_ methods_symlinks_l methods_recurse_n methods_prog_cv methods_scan_excluded_by find_sym_opt_L find_exclude_optargs bash_path find_path PATH methods_path

# <>
#_full_xtrace
#exit 101

# Table of opts and settings, precedence
#         prog    l   p   r   s     L           P                     R           S
#                                    3RD         1ST                   2ND         4TH
#               
# l           +---------------- 
#  *l     b   |   #   __  n   n                 __ = ba cp cv ty                                  3RD 
#   l       f |   #   fi  y   y 
#  +p       f |   #   fi  y   y 
# p           +----------------
#  *ba    b   |   b   ##  n   n                                                                   1ST
#   cp    b   |   b   ##  n   n 
#   cv    b   |   b   ##  n   n  
#   fi      f |   _   ##  y   n     _ = l p     
#   ty    b   |   b   ##  n   n
# r           +----------------
#   y       f |   _   fi  #   ^     _ = l p                                       ^ = y n         2ND
#  *n     b   |   b   __  #   y                 __ = ba cp cv ty
# s           +----------------
#  *y     b f |   _   __  ^   #     _ = b l p   __ = ba cp cv fi ty   ^ = y n                     4TH
#   n       f |   _   fi  y   #     _ = l p     
#             +---------------- 
# 
# Input >     
#   eq to def, 
#     rtn
#
#   ne to def
#     set primary var
#
#     set clobber vars
#
#     set if-changed vars
#     
#       opts if bash  
#       opts if find
#

_verify_path(){
  : '_verify_path BEGINS'  "$((++funclvl))" "${fence}"
  #_full_xtrace
  
  # ...before running `type` / `command` or they'll print dups
  # Note: var $PATH is always processed
  local loc_var_nm
  local -n loc_nameref
  loc_var_nm="${1}"
  loc_nameref="${1}"

  # var $bash_path is only processed when the CLI optargs say so
  if [[ "${loc_var_nm}" == bash_path ]] \
    && [[ "${verify[*]}" != *+(all|path)* ]]
  then
    return
  fi

  # Get constituent dirs from $1
  local loc_path_{1,2} p
  IFS=':' read -ra loc_path_1 <<< "${loc_nameref}"

  # get the cannonicalized paths of each such dir, replacing the 
  # existing array element with the corrected value. no result
  # from `realpath` sets an empty ('') array value.
  for p in "${!loc_path_1[@]}"; do
    loc_path_1[p]="$(realpath -e "${loc_path_1[p]}" 2>/dev/null)"
    
    # if the resulting index value is empty, then unset it
    if [[ -z "${loc_path_1[p]}" ]]; then
      unset 'loc_path_1[p]'
    fi
  done; unset p

  # if the loc_path_1 is now empty, then exit
  if [[ "${#loc_path_1[@]}" -eq 0 ]]; then
    E_ _verify_path "${loc_nameref}"
  fi

  # remove any duplicates while preserving order of dirs
  for p in "${!loc_path_1[@]}"; do
    if [[ "${loc_path_2[*]}" =~ ${loc_path_1[p]} ]]; then
      unset 'loc_path_1[p]'
    else
      loc_path_2+=("${loc_path_1[p]}")
    fi
  done; unset p

  # reset indices of loc_path_2
  loc_path_2=("${loc_path_2[@]}")

  # reset path vars
  builtin printf -v "${loc_var_nm}" '%s' "$(
    printf '%s' "${loc_path_2[0]}";
    unset 'loc_path_2[0]';
    [[ -n "${loc_path_2[*]}" ]] \
      && printf ':%s' "${loc_path_2[@]}"
  )"

  # if the path var is bash_path, then reset find_path
  if [[ "${loc_var_nm}" = bash_path ]]; then 
    F_
  fi
  : '_verify_path ENDS  '  "$((--funclvl))" "${fence}"
}

_verify_path PATH
_verify_path bash_path

# TODO: grep output of `rpm -qi` for URL's, ie, github. which can I 
# repair without adding a new login?

: 'methods_recurse_n'
declare -p methods_recurse_n

: 'methods_symlinks_l'
declare -p methods_symlinks_l

#_full_xtrace
#exit 101

# Bug: greps. parse full outputs of type and command

: 'Get all the commands: bash'

if [[ "${methods_prog_cv}" = @(bash_command_pV|bash_command_V|bash_type_a) ]]; then

  # create a single array of all commands found by each kind of search.
  # to do this...

  # search for commands with odd yet permitted-by-Linux initial
  # characters, such as \n \t \c or \l

  # create a dictionary list of each possible initial character
  unset allchr char i all_commands real_dirs re tempd

  # Workaround: `compgen -c "*"` was picking up executable shell
  # scripts from the CWD
  tempd="$(mktemp -d --suffix="${mktemp_sfx/%.txt/.d}")"
  cd "${tempd}" \
    || E_ cd
  
  #for i in 33 42 46 47 58; do
  for i in 91 95; do
  #for i in 8 9 10 11 12 13 {32..127}; do
    allchr+=(["$i"]="$(printf '%b' "\\$(printf %03o "$i")")")
  done
  allchr[10]=$'\n'
  unset i
  _full_xtrace

  # for each possible ascii character or value
  for i in "${!allchr[@]}"; do
    
    # get a per-character (sub-)list of possible command completions
    mapfile -t per_idx_commands < <(
      compgen -A command "${allchr[i]}"
    )
  
      # <>
      declare -p per_idx_commands

    # One difficulty is that a completion string can be any of
    # actual binary command, function, alias, shell keyword,
    # shell builtin and / or directory

    # for each possible completion string found by `compgen`
    for n in "${!per_idx_commands[@]}"; do
      
      # remove any functions, aliases, shell keywords and builtins from 
      # the (sub-)list
      
      # use `type` to get the shell's definition(s) of `compgen`s completion 
      # string, then use `grep` to filter out full function definitions.
      mapfile -t type_a_o < <(
        type -a "${per_idx_commands[n]}" \
          | grep -F "${per_idx_commands[n]} is "
      )
      
      # if `type -a` has no knowledge of the completion string, 
      if [[ -z "${type_a_o[*]}" ]]; then
        
        # then unset the completion string and start with the next one
        unset_per_idx_commands_n=yes
      fi

      # for each line of output from `type -a`
      for line in "${!type_a_o[@]}"; do
      
        # if any result (ie, index) of `type -a`s output refers to an
        # alias, function or shell keyword, then unset that index
        if grep -qE ' is a(liased| function| shell (builtin|keyword))' \
            <<< "${type_a_o[line]}"; 
          then
            unset 'type_a_o[line]'
        
        # if any result refers to a file...
        elif grep -qE ' is /' <<< "${type_a_o[line]}"; then 
         
          command_basename="${type_a_o[line]##*/}" 
          
              # <>
              declare -p all_commands per_idx_commands type_a_o line \
                command_basename prev_per_idx_cmds

          # ...and if that file is not already included in either the 
          # larger all_commands list or the per-ascii-character
          # prev_per_idx_cmds list...
          if ! [[ "${all_commands[*]}" =~ ${command_basename} ]] \
            && ! grep -E "$( printf '\%s' "${command_basename}" )" \
              <<< "${prev_per_idx_cmds[@]}"
          then

            # ...then record the command's basename in the 
            # prev_per_idx_cmds list, unset the type-a output index
            # and start with the next line of type-a output
            prev_per_idx_cmds+=("${command_basename}")
            unset 'type_a_o[line]'
            continue
        
          else
            unset 'type_a_o[line]'
          fi
        fi

        # if all lines of `type -a`s output have been deleted, then 
        # begin with the next completion string
        if [[ "${#type_a_o[@]}" -eq 0 ]]; then
          unset_per_idx_commands_n=yes
        fi
      done; unset line type_a_o
    
      # remove any directories from the (sub-)list
      if [[ -z "${unset_per_idx_commands_n}" ]]; then
        realpath_e_o="$(realpath -e "${per_idx_commands[n]}" 2>/dev/null)"
      
        if [[ -d "${realpath_e_o}" ]]; then 
          unset_per_idx_commands_n=yes
        fi; unset realpath_e_o
      fi
      
      if [[ "${unset_per_idx_commands_n}" == yes ]]; then 
        unset 'per_idx_commands[n]'
      fi; unset unset_per_idx_commands_n
    done; unset n
    
    # add the (sub-)list to the full list, being careful of index numbers
    mapfile -O $((i * 1000)) -t all_commands < <(
      for x in "${per_idx_commands[@]}"; do
        printf '%s\n' "${x}"
      done; unset x per_idx_commands
    )
  done; unset i
  
  cd - \
    || E_ cd
  rmdir "${tempd}"; unset tempd

  mapfile -t real_dirs < <(
    sudo find / -maxdepth 1 -mindepth 1 -type d \! -empty \
      | sort
  )

  re="$(
    printf '(%s' "${real_dirs[0]#/}"
    unset 'real_dirs[0]'
    printf '|%s' "${real_dirs[@]#/}"
    printf ')\n'
  )"

  #methods_prog_cv=bash_type_a;
  #for i in "${!all_commands[@]}"; do
  #if [[ "${methods_prog_cv}" = bash_type_a ]]; then
  #type -a "${all_commands[i]}" ; fi; done

  # Bug: the tests for methods_prog_cv need to be at the top level of
  # logic structure

  for i in "${!all_commands[@]}"; do

    # For anywhere in PATH: BASH_type_a
    if [[ "${methods_prog_cv}" = *bash_type_a ]]; then
      type -a "${all_commands[i]}" \
        | grep -E 'is /'"${re}"
    fi

    # For `command -pV` (usually only '/usr/bin'): BASH_command_pV
    if [[ "${methods_prog_cv}" = *bash_command_pV ]]; then
      command -pV "${all_commands[i]}" \
        | grep -E 'is /'"${re}"
    fi

    # For `command -V` (usually includes '/usr/sbin'): BASH_command_V
    if [[ "${methods_prog_cv}" = *bash_command_V ]]; then
      command -V "${all_commands[i]}" \
        | grep -E 'is /'"${re}"
    fi

  done 

elif [[ "${methods_prog_cv}" = *bin_find ]]; then
  hash find 2>/dev/null \
    || exit "${LINENO}"

else
  echo error
fi

# <>
_full_xtrace
exit 101

# delete? re-work?

abbrev_rel_search_dirs=all
#
# To search some specific directories, uncomment them; to search
# all of the common dirs or FULL DISK instead # --really-- --slow--
#
declare -A A_rsd
A_rsd=(
  # useful for testing
  #[usr_bin]='/bin'
  #[usr_lib]='/lib'
  #[usr_lib64]='/lib64'
  [usr_sbin]='/sbin'
  # common search dirs on Fedora, ie, "all"
  #[boot]='/boot'
  #[dev]='/dev'
  #[etc]='/etc'
  #[home]='/home'
  #[root]='/root'
  #[run]='/run'
  #[tmp]='/tmp'
  #[usr]='/usr'
  #[var]='/var'
  # usually empty
  #[afs]='/afs'
  #[lost+found]='/lost+found'
  #[media]='/media'
  #[mnt]='/mnt'
  #[opt]='/opt'
  #[srv]='/srv'
  # usually quite difficult to parse; rarely any shell scripts
  #[proc]='/proc'
  #[sys]='/sys'
)

: 'actually_all'

umask 117

get_rel_search_dirs() {
  : 'get_rel_search_dirs BEGINS' "$((++funclvl))" "${fence}"
  mapfile -d '' -t "${1}" < <(
    sudo find / -mindepth 1 -maxdepth 1 -type d \! -empty \
      \( \! -name proc -a \! -name sys \
      -a \! -iname "${script_dirnm:- scf.d}" \
      -a \! -iname "${protected_git_dir_1:- ~}" \
      -a \! -iname "${protected_git_dir_2:- tmp}" \
      \) -print0 2>/dev/null
  )
  : 'get_rel_search_dirs ENDS  ' "$((--funclvl))" "${fence}"
}
get_rel_search_dirs a_relevant_search_dirs

: 'memory_usage'

export memory_usage

# take each found dir and convert abs path [of sym, okay] to a string
# usable for directory names
unset index element calc

# for each dirname /  directory in search path
for index in "${!A_rsd[@]}"; do
  element="${A_rsd["$index"]}"
  calc="$(realpath -e "$element")"
  calc="${calc//\//_}"
  calc="${calc#_}"
  printf 'element: %-12s index: %-12s calc: %s \n' \
    "$element" "$index" "$calc"
  if [[ "$index" != "$calc" ]]; then
    echo wrong
    exit
  fi
done
get_mountpoint() {
  : 'get_mountpoint BEGINS' "$((++funclvl))" "${fence}"
  unset d dir
  d="$(realpath -e "$1")"
  mapfile -t dir < <(
    namei -xl "$d" \
      | tac \
      | grep -A100 ^D \
      | grep -E ^'[Dd]' \
      | gawk --lint '{ print $4 }'
  )
  unset j x i
  j="${#dir[@]}"
  for ((i = j; i > 0; i--)); do
    x+="${dir[$i - 1]}"/
  done
  x="$(realpath -e "$x")"
  echo "$x"
  : 'get_mountpoint ENDS  ' "$((--funclvl))" "${fence}"
}
get_mountpoint /sbin

# <>
_full_xtrace
exit 101

: 'DACs'

# Bug: var path_2 is now loc_path_2 

namei_o="$(
  for d in "${bash_path[@]}"; do
    namei -xl "$(
      realpath -e "$d" 2>/dev/null
    )"
  done \
    | grep -v ^'f:' \
    | gawk --lint '$2 !~ /root/ || $3 !~ /root/ { print }'
)"
if [[ -n "${namei_o}" ]]; then
  echo 'A directory in PATH is not fully owned by root (DAC).'
  echo "${namei_o}"
  exit "${LINENO}"
fi

: 'ACLs'

# Variables, this section
unset end_dirname full_dir_list ext_array dir sub_dir num_sub_dirs N n \
  extglob_pattern ext_first ext_last getfacl_o grep_o
end_dirname=/
declare -A full_dir_list
ext_array=()

# for each actual directory in PATH
for dir in "${bash_path[@]}"; do

  # limit the number of loops to the number of constituent directory
  # inodes. safely split each directory into its constituent directory
  # names, ie, by using NULL's in place of '/'s
  unset sub_dir
  num_sub_dirs="$(tr '/' '\0' <<<"$dir" \
    | gawk --lint -F'\0' '{ print NF }')"
  N=$((num_sub_dirs - 1))

  # read the ACLs of each dir and sub_dir
  for ((n = N; n >= 0; --n)); do

    # Assign a value to $sub_dir as necessary
    : "${sub_dir:="${dir}"}"

    # <> quote ${extglob_pattern or not? - SC-2053=w
    [[ "${sub_dir}" = "${extglob_pattern}" ]]
    echo $?
    #[[ "${sub_dir}" = ${extglob_pattern} ]] ; echo $?
    "${Halt:?}"

    # If the sub_dir is already listed in the extglob_pattern, then
    # move on to the next small loop
    if [[ "${sub_dir}" = "${extglob_pattern}" ]]; then
      sub_dir="$(dirname "${sub_dir:="${dir}"}")"

      # If the sub_dir is '/', then move on to the next big loop
      if [[ "${sub_dir}" = "${end_dirname}" ]]; then
        break
      fi
      continue
    fi

    # Use an Associative array to filter out duplicate entries.
    # (With associative arrays, duplicate assignments are indempotent.)
    full_dir_list["${sub_dir}"]+="${n},"

    # create a list of directories and subdirectories that have been
    # tested so far. This section concatenates directories as strings
    # into a variable that the shell will later interpret as an
    # extglob.
    ext_array=("${!full_dir_list[@]}")
    ext_first="${ext_array[0]}"
    [[ -n "${ext_first}" ]] \
      && unset 'ext_array[0]'

    X_
    :_
    D_ ext_array

    ext_last="${ext_array[*]: -1:1}" # [@] or [*] ? SC-2124=w

    X_
    :_
    D_ ext_last
    L_

    [[ -n "${ext_last}" ]] \
      && unset "ext_array[${#ext_array[@]}]"
    # index math can be a little weird

    # create the exglob_pattern
    if [[ -n "${ext_first}" ]]; then
      extglob_pattern="$(printf '@(%s' "${ext_first}")"
      [[ "${#ext_array[@]}" -gt 0 ]] \
        && extglob_pattern+="$(printf '|%s' "${ext_array[@]}")"
      if [[ -n "${ext_last}" ]]; then
        extglob_pattern+="$(printf '|%s)' "${ext_last}")"
      else
        extglob_pattern+="$(printf ')')"
      fi
    fi

    # look for any ACL's on the directory
    getfacl_o="$(getfacl -enp -- "${sub_dir}" 2>/dev/null)"
    grep_o="$(grep -ve '^#' -e ^'user::' -e ^'group::' -e ^'other::' \
      <<<"${getfacl_o}")"

    # If found, exit the script and inform the user
    if [[ -n "${grep_o}" ]]; then
      printf '\n%s: ACL defined for this directory:\n\t%s\n\n' \
        "${script_nm}" "${sub_dir}"
      echo "${getfacl_o}"
      printf '\n\tThis command will remove all ACL\x27s from the '
      printf 'specified directory:\n\n\t\tsetfacl -b %s\n\n' "${sub_dir}"
      exit 1

    # otherwise, move on to the next big loop
    else
      if [[ "${sub_dir}" = "${end_dirname}" ]]; then
        break
      fi
    fi

    sub_dir="$(dirname "${sub_dir:="${dir}"}")"
  done
done
unset end_dirname full_dir_list ext_array dir sub_dir num_sub_dirs \
  N n extglob_pattern ext_first ext_last getfacl_o grep_o

: 'Find command'

export find_path
export find_sym_opt_L
export methods_scan_excluded_by
export find_exclude_optargs

# <>
_full_xtrace
exit 101

: 'Check for Process Locks'

for d in "${a_poss_proces_lock_dirs[@]}"; do
  if [[ -d "${d}" ]]; then
    mapfile -d '' -t lkds < <(
      S_ find "${d}" -type d -empty -name \
        ".${repo_nm}.[0-9a-zA-Z_-]*.lock" -print0 2>/dev/null
    )

    : 'lkds, count:' "${#lkds[@]}"

    for l in "${lkds[@]}"; do
      if [[ -d "${l}" ]]; then
        if [[ -v delete_locks ]]; then
          rmdir -v -- "${l}"
        else
          printf '\n\t A process lock exists for this script. Exiting '
          printf 'now.\n\n'
          L_
        fi
      fi
    done
  fi
done
[[ -v delete_locks ]] \
  && L_

_full_xtrace
exit 101

#X_; :_

_full_xtrace
exit 101

: 'Process lock'

# from among the possible dirnames
for poss_lk_d in "${a_poss_proces_lock_dirs[@]}"; do

  # use the first one that fulfills certain requirements
  if [[ -d "${poss_lk_d}" ]] \
    && [[ ! -L "${poss_lk_d}" ]] \
    && [[ -w "${poss_lk_d}" ]]; then

    # define the lock directory
    process_lock_d="${poss_lk_d}/${proc_lk_f_nm}"
    break
  fi
done

# create the lock directory
if ! mkdir -m 0000 "${process_lock_d}" 2>/dev/null; then
  {
    printf '\n\tCannot acquire process lock: <%s>.\n' "${process_lock_d}"
    #printf '\tID: %s\n' "${USER}" # why?
    printf 'Exiting.\n\n'
  } 1>&2
  L_
fi

_full_xtrace
exit 101

# SECTION B

#:_
#X_

# Bugs: Hardcoded $mountpoint

: 'Assign varnames and paths for the data directories'
mountpoint=/run/media/root/29_Mar_2023
main_d="${mountpoint}/${script_dirnm}"
data_subd="${main_d}/latest_data"
curr_time_ssubd="${data_subd}/t_${timecode}/"
list_crunchbangs="${curr_time_ssubd}/crunchbangs"

: 'data files'
a_write_path_nms=("${list_crunchbangs:=crunchbangs}"
  "/tmp/${list_crunchbangs##*/}"
)

# TODOs: grep scripts for 'todo's
#   - grep for 'shellcheck disable'
#   - This section seems Buggy.

_full_xtrace
exit 101

: 'Reduce use of sudo'
if [[ ! -r "${main_d}" ]]; then

  mapfile -d / -t a_acl_name_indiv_dir <<<"${main_d}"

  a_acl_name_indiv_dir[0]=/
  a_acl_name_indiv_dir[-1]="${a_acl_name_indiv_dir[-1]//$'\n'/}"

  acl_each_dir="${#a_acl_name_indiv_dir[@]}"

  for ((iterator_1 = 0; iterator_1 < acl_each_dir; iterator_1++)); do
    acl_abs_path+="/${a_acl_name_indiv_dir[iterator_1]}"
    acl_realpath="$(realpath -e "${acl_abs_path}")"

    # Bug: why sudo? \/

    if S_ test -e -- "${acl_realpath}"; then
      : 'test succeeded: acl_realpath exists '
    else

      : 'test failed: acl_realpath DNE'

      if [[ ! -d "${acl_abs_path}" ]]; then

        S_ mkdir -p -- "${main_d}" \
          || E_ "${LINENO}"
      fi

      acl_realpath="$(realpath -e "${acl_abs_path}" 2>/dev/null)"

      #:_

      # TODO: use alias w namei

      #M_ -- "${acl_realpath}"

    fi

    if [[ -r "${acl_realpath}" ]]; then
      : 'test succeeded: acl_realpath is readable'
    else

      : 'test failed: acl_realpath is not readable'

      acl_execd_setfacl=y
      # SC-2034, while trap-s setfacl blk is #-d
      #   ^--- this comment means what???
      export acl_execd_setfacl

      # readable up to the main_d
      S_ chmod -R 750 -- "${acl_realpath}" \
        || E_ "${LINENO}"

      S_ setfacl -d -m "${USER}:r-x" -- "${acl_realpath}" \
        || E_ "${LINENO}"

      S_ setfacl -m "${USER}:r-x" -- "${acl_realpath}" \
        || E_ "${LINENO}"

      #:_
      #id "${USER}"
      #groups "${USER}"
      #M_ -- "${acl_realpath}"
      #S_ getfacl -- "${acl_realpath}"

      [[ -r "${acl_realpath}" ]] \
        || E_ "${LINENO}"
    fi
  done

  # writeable within the main_d
  S_ setfacl -d -m "${USER}:rwx" -- "${main_d}" \
    || E_ "${LINENO}"

  S_ setfacl -R -m "${USER}:rwx" -- "${main_d}" \
    || E_ "${LINENO}"

  #:_
  #id "${USER}"
  #groups "${USER}"
  #M_ -- "${main_d}"
  #S_ getfacl -- "${main_d}"

fi

_full_xtrace
exit 101

: 'make sure -data_subd- is a directory OR create the -data_subd- dir '
: 'if necessary'
[[ -d "${data_subd}" ]] \
  || mkdir "${data_subd}" # as liveuser

#:_
#M_ -- "${data_subd}"

: Label the current data as -latest.-
mapfile -d '' -t a_previous_time_dirs < <(
  find "${data_subd}" -mindepth 1 -maxdepth 1 -type d -a \! -type l \
    -name 't_*' -print0
)

: 'if -prev_time_ssubd- is empty, delete it, otherwise -mv- it out'
: 'of the -latest- dir'

for prev_time_ssubd in "${a_previous_time_dirs[@]}"; do
  rmdir --ignore-fail-on-non-empty -- "${prev_time_ssubd}"

  : of previous prev_time_ssubd
  if [[ -d "${prev_time_ssubd}" ]] \
    && [[ ! -L "${prev_time_ssubd}" ]]; then
    S_ mv -- "${a_previous_time_dirs[@]}" "${main_d}"
  else
    continue
  fi
done

: of curr_time_ssubd
if [[ ! -d "${curr_time_ssubd}" ]]; then
  S_ mkdir -p -- "${curr_time_ssubd}" \
    || E_ "${LINENO}"
fi

#:_
#M_ -- "${curr_time_ssubd}"

_full_xtrace
exit 101

# SECTION C

: 'Gather filenames from local attached disk storage'

if [[ "${abbrev_rel_search_dirs}" == all ]]; then

  : 'set a value for a_relevant_search_dirs and..'
  mapfile -d '' -t a_relevant_search_dirs < <(
    S_ find / -mindepth 1 -maxdepth 1 -type d \! -empty \
      \( \! -name proc -a \! -name sys -a \! \
      -iname "${script_dirnm}*" \) -print0 2>/dev/null
  )

  for sd in "${a_relevant_search_dirs[@]}"; do

    # assign
    echo "${sd}"
  done

fi

: 'Find all files within the search area. Even the empty ones.'
mapfile -d '' -t a_all_files < <(
  S_ find "${a_relevant_search_dirs[@]}" -mindepth 1 -type f \
    -print0 2>/dev/null
)

: 'Sort the original array and test it.'
mapfile -d '' -t a_all_files_sorted < <(
  printf '%s\0' "${a_all_files[@]}" \
    | sort -z
)

_full_xtrace
exit 101

# SECTION D

# Bug? Can more indices and fewer files be used?

: 'Sort out the scripts, ie, any file beginning with a crashbang from'
: 'the rest of the files'

: 'Get the total number of found files, for the progress indicator'
total_count="$(printf "%'d" "${#a_all_files_sorted[@]}")"
unset IFS

[[ -f /tmp/"${list_crunchbangs##*/}" ]] \
  && S_ R_ -f -- "/tmp/${list_crunchbangs##*/}"

# Bug: the search dirs must be the same, as well as the dnf tx number
# Bug: Use of /tmp/crunchbangs as yn on do loop q. Sb a set of file lists
#.   difftd by search dir / search type / etc. See file "priority"

: 'if the full list exists -- of files on disk which begin with'
: 'crashbangs -- skip the 30-90 minute search phase.'
if [[ ! -f "/tmp/${list_crunchbangs##*/}" ]] \
  || [[ -L "/tmp/${list_crunchbangs##*/}" ]]; then

  for all_files_index in "${!a_all_files_sorted[@]}"; do

    : 'Loop'

    loop_idx="$(printf "%'d" $((all_files_index + 1)))"
    printf '%s of %s files\r' "${loop_idx}" "${total_count}"

    : 'file must exist'
    each_sorted_f="${a_all_files_sorted[all_files_index]}"

    if [[ ! -e "${each_sorted_f}" ]]; then
      a_file_DNE+=([all_files_index]="${each_sorted_f}")
      continue
    fi

    : 'list of empties'
    if [[ ! -s "${each_sorted_f}" ]]; then
      a_empty_files+=([all_files_index]="${each_sorted_f}")
      continue
    fi

    : '-file- magic'
    printf '+ %-8d: ' "${all_files_index}" \
      | S_ tee -a -- "${curr_time_ssubd}file_out" >/dev/null

    file_o="$(S_ file -pk -- "${each_sorted_f}" 2>&1)" # Bug: needs erx
    file_o="${file_o%%64-bit LSB *}"
    a_bin_file_output+=([all_files_index]="${file_o}")

    # Bug? Needs tracking index? One array or file, one line per fso,
    #. use symbols or csv to indicate test results, w common indices
    # Bug: [[ -n sb right after exec file

    if [[ -n "${file_o}" ]]; then
      S_ tee -a -- "${curr_time_ssubd}file_out" <<<"${file_o}" \
        >/dev/null
    else
      err_msg="WARNING: -file- produced 0 output:  <${each_sorted_f}>"
      S_ tee -a -- "${curr_time_ssubd}file_out" <<<"${err_msg}" \
        >/dev/null
    fi

    # Bug: keep `od` output in an array
    # Bug: avoid as many disk writes as possible.
    #  Write out only stats?
    # Bug: use indices to reference each type? Store array diffs btw
    # loop? Time loss to disk io? Run file in parallel? Read each file
    # once and use var for both od and file?

    : 'two bytes each'

    #X_; :_

    # fix?: mapfile -d '' -t -O "${all_files_index}" a_od_output

    od_o="$(
      S_ od -j 0 -N 2 -t x1z -v -- "${each_sorted_f}" \
        | tr -s ' ' \
        | gawk --lint '{ print $2, $3, $4 }' \
        | tr -d '\n' \
        || E_ "P:${PIPESTATUS[*]} I:${all_files_index} ${each_sorted_f}"
    )"

    [[ -n "${od_o}" ]] \
      || E_ "I:${all_files_index} ${each_sorted_f}"

    a_bin_od_output+=([all_files_index]="${od_o}")

    read -r byte_0 byte_1 printable_chars <<<"${od_o}"

    export printable_chars # SC-2034

    : '-od_o- non-zero'
    if [[ -z "${byte_0}" ]]; then
      E_ "I:${all_files_index} <${each_sorted_f}>" \
        '*unreachable code*'
    elif [[ "${byte_0}" == @(23|21) ]]; then
      : 'compare hexadecimals'

      : 'endianness'
      if [[ "${byte_0}${byte_1}" == 2123 ]]; then
        a_incorrect_endianness+=([all_files_index]="${each_sorted_f}")

      else

        : 'Crunchbangs'

        # q, does strings recognize unicode? Color codes? Cr's? Etc
        # test dd vs strings

        strings_o="$(strings -n1 <"${each_sorted_f}" \
          | head -n1 \
          | cut -b -$((2 ** 14)) \
          || E_ "P:${PIPESTATUS[*]} I:${all_files_index} \
            ${each_sorted_f}")"

        IFS= read -r first_line_printable <<<"${strings_o}" \
          || E_ "I:${all_files_index} ${each_sorted_f}"

        : '-#!comment-'
        if [[ "${first_line_printable}" =~ ^'#!comment' ]]; then
          a_crunches_with_hashbang_comments+=(
            [all_files_index]="${each_sorted_f}")
          continue
        fi

        #   Note: with only /bin/sbin, this if-fi block doesn't execute

        # FR: sort also per-rpm, awk script, probably

        : 'outside of rpm'
        if ! rpm -qf "${each_sorted_f}" 2>/dev/null 1>&2; then

          : 'user or system'
          if [[ "${each_sorted_f}" = /@(root|home|run/media)/* ]]; then
            a_non_rpm_user_crunches+=(
              [all_files_index]="${each_sorted_f}"
            )
            continue
          else
            a_non_rpm_system_crunches+=(
              [all_files_index]="${each_sorted_f}"
            )
            continue
          fi
        fi
      fi

      #X_; :_

      # scan non-shell scripts for shell escapes ie sys-bin calls
      # https://www.sans.org/blog/escaping-restricted-linux-shells/

      # Bug, "shell scripts" incls python perl etc

      # how to make IRT lists for each interpreter?

      : 'Make an array of the relevant filenames and their crashbangs.'
      a_shell_scripts+=([all_files_index]="$(printf \
        "%'-12d %%=%%=%%=%% %-50s %%=%%=%%=%% %s\n" \
        "${all_files_index}" "${first_line_printable}" \
        "${each_sorted_f}")"
      )

    else

      : 'all others'
      a_all_other_files+=([all_files_index]="$(printf \
        "%'-12d %%=%%=%%=%% %s\n" "${all_files_index}" \
        "${each_sorted_f}")"
      )
    fi
  done

  # Note, you want to see the full crunchbangs in printed ASCII form

  : 'Open a timestamped file and append into it the list of filenames'
  : 'and their crashbangs.'

  : 'Exporting is necessary of the array names from the above scan'
  a_arrays=(a_all_files a_all_files_sorted a_file_DNE a_empty_files
    a_bin_file_output a_bin_od_output a_incorrect_endianness
    a_crunches_with_hashbang_comments a_non_rpm_user_crunches
    a_non_rpm_system_crunches a_shell_scripts a_all_other_files
    a_write_path_nms)
  export "${a_arrays[@]}"

  W_ "${a_arrays[@]}"
  B_ "${curr_time_ssubd}/file_out"
  #L_;

  : 'if any data files already exist, keep them'
  for any_existing_f in "${a_write_path_nms[@]}"; do

    if [[ -f "${any_existing_f}" ]] \
      && [[ ! -L "${any_existing_f}" ]]; then
      S_ mv -- "${any_existing_f}" "${any_existing_f}.${$}.${random_n}" \
        || E_ "${LINENO}"
    fi
  done

  : 'create the original list_crunchbangs'
  S_ touch -- "${a_write_path_nms[@]}"

  : 'write a file header'
  {
    printf '# crunchbangs -- %s\n' "${timecode%-*}"
    printf '# %s\n' "$(declare -p a_relevant_search_dirs)"
  } | S_ T_ -- "${a_write_path_nms[@]}" >/dev/null

  : 'printing contents of a_shell_scripts array, with backup'
  printf '%s\n' "${a_shell_scripts[@]}" \
    | S_ T_ -a -- "${a_write_path_nms[@]}" >/dev/null
  B_ "${a_write_path_nms[@]}"

else

  # the time_dir needs a copy of the crunchbangs file, also.  copy it in
  # from the hopefully correct backup in /tmp
  if [[ ! -f "${list_crunchbangs}" ]]; then
    S_ rsync -ca -- "/tmp/${list_crunchbangs##*/}" \
      "${list_crunchbangs}" \
      || E_ "${LINENO}"
  fi
fi

_full_xtrace
exit 101

# <> ?
W_ a_write_path_nms

#X_; :_;

S_ head -- "/tmp/${list_crunchbangs##*/}"
#L_;

: 'Verify interpreters'

: 'Get the list of interpreters from the list of crunchbangs.'
#   Note: new indices starting from 0
# use the contrived delimiter to capture entire shebang string
# remove leading whitespace
# sort and print unique
# remove leading ^'#!' from each interpreter
# Note: in `awk` cmd, %=%=%=% may need to be double quoted
mapfile -t a_interpreters < <(
  sudo gawk --lint 'BEGIN { FS = "%=%=%=%" } ; /#!/ { print $2 }' -- \
    "/tmp/${list_crunchbangs##*/}" \
    | gawk --lint 'BEGIN { FS = " -" } ; { print $1 }' \
    | sed 's, *,,g' \
    | sort -u \
    | cut -b3- \
    || E_ "P:${PIPESTATUS[*]}"
)

_full_xtrace
exit 101

# <>
:_
#L_

# Duplicate with post-getopts section ?

: 'Ways to find an interpreter if it-s available on disk:'

# Bug: `realpath -e` and `command -V` are redundant?
# Answer: no. `command` is limited to PATH; realpath is limited by
# FS permissions.

# `find` can produce symlinks or actual files
#   # find /usr/sbin -type l | grep resolvconf
#       /usr/sbin/resolvconf
# `command` can produce symlinks
#   # command -V resolvconf
#       resolvconf is /usr/sbin/resolvconf
# `realpath` produces physical paths
#   # realpath -e /usr/sbin/resolvconf
#       /usr/bin/resolvectl

for program in "${a_interpreters[@]}"; do
  : 'command -pV'
  command_o="$(command -pV "${program}" 2>&1)"

  if [[ -n "${command_o}" ]]; then
    realpath_o="$(realpath -e "${command_o}" 2>/dev/null)"

    if [[ -f "${realpath_o}" ]]; then
      a_interps_rps+=("${realpath_o}")
      m="exists on disk"
      break
    fi
  fi
done

# Bug: add "-d ''" to mapfile

# Canonicalize interpreters paths, sort and list each unique binary.
#   Note: new indices starting from 0
mapfile -t a_interps_rps < <(
  S_ realpath -e -- "${a_interpreters[@]}" \
    | sort -u
)

_full_xtrace
exit 101

# <>
L_

# for each interpreter, print it in the 1st 32 bits of a line.

{
  for b in "${!a_interps_rps[@]}"; do

    printf '%-32s' "${a_interps_rps[b]}"

    # use a shell builtin to test for each interpreter's presence on
    # disk, and write to a variable the test's result

    if command -pV "${a_interps_rps[b]}" >/dev/null; then
      m="exists on disk"
    else
      m="DNE on disk"
    fi

    # create a new array of structured data: index, interpreter and
    # test result
    a_interps_disk_repo+=([b]="${b} : ${a_interps_rps[b]} : ${m}")

    # into the next 8 bits of a line, print the test result
    printf '%-8s' "${m}"

    # identify the originating rpm for each interpreter.
    # binary need not be installed.
    # filter for rpm name by CPU type in its filename
    # sort rpms and print each unique
    dnf_po="$(
      S_ dnf provides -- "${a_interps_rps[b]}" \
        | gawk --lint '/x86_64|i686/ { print $1 }' \
        | sort -u
    )"

    # based on whether there was any output,
    # save a result message to variable
    if [[ -n "$dnf_po" ]]; then
      n="exists in repos"
    else
      n="DNE in repos"
    fi

    # in the same array, in a different range of indices,
    # save the index, interpretet name and rpm test result
    a_interps_disk_repo+=([b + 100]="${b} : ${a_interps_rps[b]} : ${n}")

    # print rpm test result to end of line; include a newline
    printf '\t\t\t\t%s\n' "${n}"

    # if any data exists, print the list of originating rpms
    printf '%s\n' "$dnf_po"
    unset dnf_po m n

  done
} | S_ T_ -a -- "${curr_time_ssubd}a_interpreters" >/dev/null
unset b

# <>
#X_; :_;
W_ a_write_path_nms a_interpreters a_interps_rps a_interps_disk_repo
L_

_full_xtrace
exit 101

# SECTION E

: 'CENTRAL TASK, 1 OF 2: Filter the list of crashbangs with the list'
: 'of shells.'

# print one file header

{
  printf '# SC-scrpts-list -- %s\n' "${timecode%-*}"
  printf '# %s\n' "$(D_ a_relevant_search_dirs)"
} | S_ T_ -- "${list_crunchbangs}_SC-scrpts-list" >/dev/null

# filter out interpreters not compatible with shellcheck.
# file $list_crunchbangs is located in $time_dir.
S_ grep -E -- '/bin/'"${SC_shells}"'.*%=%=%=%' "${list_crunchbangs}" \
  | S_ tee -a -- "${list_crunchbangs}_SC-scrpts-list" \
  || E_ "${LINENO}"

# Copy list to /tmp
S_ rsync -ca -- "${list_crunchbangs}_SC-scrpts-list" /tmp \
  || E_ "${LINENO}"

# Backup both lists
B_ "${list_crunchbangs}_SC-scrpts-list" /tmp/*_SC-scrpts-list

# <>
X_
:_
W_ timecode list_crunchbangs SC_shells
L_

_full_xtrace
exit 101

: 'CENTRAL TASK, 2 of 2: with ShellCheck scan each script for errors'

# TODO: keep "$all_files_index" tracked with content all the way through
#   into the "_found_scripts" file
# Bug? line 1 of script could contain percent symbols

: 'A hell world of pipelines'
#   Q: how to translate the correct newlines into nulls to separate the
#   filenames when reading from a file?  awk? files _can_ contain \n-s

# for every line beginning with a crashbang...
grep_o="$(S_ grep ^'#!' -- "${list_crunchbangs}_SC-scrpts-list")"

# get the filename
cut_o="$(cut -d '%' -f5- <<<"${grep_o}")"

# collect the filenames in a single list
mapfile -t a_each_abspath_scriptnm <<<"${cut_o}"

# remove leading whitespace
a_each_abspath_scriptnm=("${a_each_abspath_scriptnm[@]##* }")

# Wk: awk , multi-char delim, remv lead+trail wspc - redef $0 ?, printf

#   grep -Eo | tr

# Bug: rename variable "$c" below
# Bug: why sort by line count? More text, more Bugs? How to prior mult
#   factors?

# count number of newlines in each script
wc_o="$(S_ wc -l -- "${a_each_abspath_scriptnm[@]}")"

# remove 'totals' line
wc_o="${wc_o%$'\n*'}"

# sort script lengths descending
sort_o="$(sort -gr <<<"${wc_o}")"

# print script names
awko="$(gawk --lint '{ print $2 }' <<<"${sort_o}")"

# create a list of script names sorted by line count descending
mapfile -t a_each_script_list_sorted_by_linect \
  <<<"${awko}"

# define file name, including severity and path symbols (target file)
found_scrpts_f="${list_crunchbangs}_found_scripts"
found_scrpts_f+="_${sc_sev_abrv}_${abbrev_rel_search_dirs}"
i=0

# Bug? 1st grep extra?

{

  # for each sorted script
  for sorted_script in "${!a_each_script_list_sorted_by_linect[@]}"; do

    # run shellcheck with selected/default severity
    # remove URL's
    # capture SC error codes with their descriptions
    # truncate descriptions to 64 bytes
    # sort numerically
    # count the number of unique errors
    # sort by the third column: severity
    # collect output in an array
    # on any non-zero exit status, print an error, incuding PIPEFAIL
    # array, and exit the script when filters, etc completes, print
    # a NULL to start a new mapfile index
    mapfile -d '' -t a_each_script_SC_results < <(
      shellcheck -S "${sc_severity}" \
        "${a_each_script_list_sorted_by_linect[sorted_script]}" \
        | grep -Fv 'shellcheck.net' \
        | grep -Eo "SC[0-9]{4}.*" \
        | cut -b -64 \
        | sort -g \
        | uniq -c \
        | sort -k3 \
        || E_ "P:${PIPESTATUS[*]} I: S:" # index and script name
      # end of pipe intended
      printf '\0'
    )

    # if there's any output from shellcheck
    if [[ -n "${a_each_script_SC_results[*]:0:1}" ]]; then

      # Bug: iterator sb $sorted_script ? sorted_script should have

      # print a line header. (as-is:) including a new index number
      # for each script
      printf '\n%-4d%s\n' $((i++)) \
        "${a_each_script_list_sorted_by_linect[sorted_script]}"
      # print all massaged SC results for each script
      printf '%s' "${a_each_script_SC_results[@]}"
    fi
  done
  unset i

  # append each text group to a findings file
} | S_ tee -a -- "${found_scrpts_f}" >/dev/null

: 'Write semi-permanent archives'

# backup the findings file
B_ "${found_scrpts_f}"

# make copies of the findings file and backup those copies
for d in /tmp "${main_d}"; do
  S_ rsync -ca -- "${found_scrpts_f}" "${d}" \
    || E_ "${LINENO}"
  B_ "${d}/${found_scrpts_f##*/}"
done
unset d

# <> Print some variables   for interactive use
z=0
for d in "${curr_time_ssubd}" "${main_d}" /tmp; do
  printf '\n\t data_d_%d=%s\n' $((z++)) "${d}"
done
unset d z

trap - EXIT
exit 00
