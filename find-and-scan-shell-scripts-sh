#!/bin/bash
# find-and-scan-shell-scripts-sh
# Written in bash version 5.1 on Fedora 37
x="${_}"; echo 'x:' "${x}"; exit 101
LC_ALL=C
stty -a | grep -i utf
locale charmap
echo $LANG $LC_TYPE $LANGUAGE
localedef
locale -a
(set;env) | grep -i utf
find / -type f -iname 'rc.local'
exit 101



###  SECTION A  ###
PATH="$( getconf PATH )"':/usr/bin:/usr/sbin' 
#   Note: if executed by a restricted shell, this assignment to PATH will 
# fail with an error message, and will ignore all of the rest of the 
# commands on same script line as the PATH assignment. 
#
  # <>
  #ec=$?
  #: 'path assignment exit:' $ec
  #[[ $ec -ne 0 ]] && 
  #  exit 99
  #exit 101
#
# Implementation-dependent arguments for options parsable by `shellcheck`:
shells='(sh|bash|dash|ksh)'
severity='error'
#
#
# Variables
time="$( builtin printf '%(%F_%H%M%S)T' )"
#fstype_regexp='(binfmt_misc|bpf|cgroup2|configfs|debugfs|devpts|devtmpfs|efivarfs|fusectl|hugetlbfs|iso9660|mqueue|proc|pstore|rpc_pipefs|securityfs|selinuxfs|sysfs|tmpfs|tracefs)'
#
# Functions
#   Note: cat doesn't need sudo from a regular user acct in this case,
# for some odd reason, however, using '< "$1"' into `tee` fails,  as 
# it does also into `sudo tee`.
_bak(){ 
  # shellcheck disable=SC2002
  cat "${1}" | tee --output-error=exit "${1}" "${1}".bak > \
      /dev/null 2>&1 ||
    _erx '_\bak' "${1}"
}
_erx(){ 
  local ec="${?}"
  echo Error: "${@}" 
  return "${ec}"
}
_num(){ 
  local -n array="$1" 
  echo "${#array[@]}"
}
# Usage:  _usage [exit-code]
_usage(){
  cat <<-\EOF
    SCF - Shell Check Find, version 1.0 (redhat-linux)
    Find and scan shell scripts depending on severity level. 
        Usage:  ./find-and-scan-shell-scripts-sh [-ehiw]
                -e error          -i info
                -h help           -w warning
        Only the first option is processed.
    SCF homepage: https://github.com/wileyhy/scf/
EOF
  exit "${1}"
}
#
# Option parsing
if [[ "${#}" -gt 0 ]]; then
  first_two_chars="${1:0:2}"
  case "${first_two_chars}" in
    --) printf '\n\tHappy Easter!\n\n'
          exit 0;;
    -e) severity='error';;
    -i) severity='info';;
    -w) severity='warning';;
    -h) _usage 0;;
    *)  _usage 1;;
  esac
fi
#
  # <> Debug
  #set -x
#
#
# Create the data directories
sudo -v
#
#   In case of large log files, programatically select a save directory, 
# attached to the local disk, where any output can be saved; prefer USB 
# flash drives. This particular `df` command will output three alpha-
# numeric strings separated by whitespace on a single line. `sort` the 
# output by descending size. With `awk`, take the device with the most 
# available space and get its mountpoint with `findmnt`. If there is no 
# output, then set 'mountpoint' according to environment variables. 
mapfile -d '' -t usb_drives < <(
  sudo find /run/media -mindepth 2 -maxdepth 2 -type d -print0 )
mapfile -t df_o < <(
  sudo df --sync --local --output='fstype,avail,source' --block-size=1 \
      "${usb_drives[@]}" |
    grep --extended-regexp --invert-match '^Type[[:space:]]*Avail' )
device="$( 
  printf '%s\n' "${df_o[@]}" |
    sort --general-numeric-sort --reverse --key=2 |
    awk 'NR == 1 { print $3 }' )"
mountpoint="$( 
  findmnt --canonicalize --output=target --noheadings "${device}" )"
#
  # <> Bug work: maintenance issue! Compound command
  #   Note: `df` isn't portable per `info df`
  #declare -p usb_drives df_o device mountpoint
  #exit 101
# 
    # <> works
    #mountpoint="$(
    #  findmnt --canonicalize --output=target --noheadings "$(
    #    find /run/media -mindepth 2 -maxdepth 2 -type d |
    #      df --sync --local --output='fstype,avail,source' --block-size=1 |
    #      grep --extended-regexp --invert-match '^Type[[:space:]]*Avail' |
    #      grep --extended-regexp --invert-match ^"$fstype_regexp" |
    #      sort --general-numeric-sort --reverse --key=2 |
    #      awk 'NR == 1 { print $3 }'
    #  )"
    #)"
#
[[ -z "${mountpoint}" ]] &&
  mountpoint="${TEMPDIR:="${HOME}"}"
datadir="${mountpoint}/scf.d/latest"
timedir="${datadir}/t_${time}"
datafile="${timedir}/crunchbangs"
unlisted="${timedir}/unlisted"
umask 077
#
if [[ ! -d "${datadir}" ]]; then
  sudo mkdir --parents "${datadir}" ||
    _erx "${LINENO}"
  fi
#
# Label the current data as "latest."
mapfile -d '' -t previous < <( 
  find "${datadir}" -mindepth 1 -maxdepth 1 -type d \
    -name 't_*' -print0 2> /dev/null )
if [[ -n "${previous[*]:0:1}" ]]; then
  sudo mv "${previous[@]}" "${mountpoint}/scf.d/" ||  
    _erx "${LINENO}"
fi
if [[ ! -d "${timedir}" ]]; then
  sudo mkdir --parents "${timedir}" ||
    _erx "${LINENO}"
fi
#
  # <>
  #exit 101
  #set -x
#
#
# Gather filenames from local attached disk storage.
# shellcheck disable=SC2034
mapfile -d '' -t relevant_search_dirs < <(
  find / -mindepth 1 -maxdepth 1 -type d \
    \( \! -name proc -a \! -name sys \) -print0 )
#
# DEBUG: "${relevant_search_dirs[@]}" OR '/usr/sbin' OR /usr/{,s}bin
mapfile -d '' -t all_files < <( 
  find "${relevant_search_dirs[@]}" \
    -type f -print0 2> /dev/null )
#
  # <> ##############################################################
  #declare -p all_files relevant_search_dirs previous mountpoint \
  #  {data,time}dir datafile unlisted device df_o usb_drives \
  #    first_two_chars severity shells PATH
  #declare -pf _bak _erx _num _usage
  #exit 101
  set -x


###  SECTION B  ###
# Add some brevity, and get the most recent tx number from `dnf history` 
f="${datafile}"
dnf_history_number="$( 
  dnf history info 0 | 
    awk '/^Transaction ID/ { print $4 }' ||
      _erx "${LINENO}" )"

  # <>
  #declare -p f dnf_history_number endianness
  #exit 101
  set -x

# Functions for this section
# Note: this function can take 30-90 minutes!
_scan_local_disks(){
  # Sort out the scripts, ie, any file beginning with a crashbang ('#!'), 
  # from the rest of the files.
  for i_1 in "${!all_files[@]}"; do
    unset nextfile od_o shabang_with_interpreter tr_o 
    nextfile="${all_files[${i_1}]}"

    # File must exist and have a size greater than zero.
    #   Note: builtin `[[` fails due to lack of permissions
    if ! sudo command test -s "${nextfile}"; then 
      unset 'all_files[$i_1]'; 
      continue; 
    fi

    # Bug, inordinately long interpreter paths are rare, but do occur.
    # Read from disk in binary the first two bytes of each file in 
    # the list and output it in hexadecimal.
    #   Note: POSIX `od` doesn't have GNU's '--strings' option, so use 
    #   the `strings` command separately.
    od_o="$( 
      sudo od -Ax -j0 -N2 -tx2z "${nextfile}" ||
        _erx "${LINENO}" )" # POSIX

    mapfile -d '' -t tr_o < <(
      tr --squeeze-repeats ' \n\t' '\0' <<< "${od_o}" )
			
        # <>
        #declare -p {od,tr}_o 
        exit 101
    
    # If 'tr_o' contains some non-zero data, as it should, compare the 
    # hexidecimal representations to find any crashbangs.
    if [[ -z "${tr_o[*]:0:1}" ]]; then
      _erx "${LINENO}"
	
    elif
      [[ "${tr_o[1]}" == '2123' ]]; then

      # When a crashbang's found, use `strings` to filter out any non-
      # printable data, to protect `head` from garbage input, and to 
      # get the full crashbang string in ASCII. 
      #   Note: `strings` does not remove newlines.
      dd_of_file="$( dd bs=1 iflag=nonblock,noatime count=$(( 2 ** 13 )) if="${nextfile}" iflag=noatime skip=0 || 
        _erx "${LINENO}" )"
      
      # --print-file-name; try wo --radix
      strings_o="$( 
        strings --all --bytes=1 --include-all-whitespace \
            --output-separator '\0' "${nextfile}" || 
            _erx "${LINENO}" )"
          
      shabang_with_interpreter="$( 
        head --lines=1 --zero-terminated \
            <<< "${shabang_with_interpreter}" || 
          _erx "${LINENO}" )"

        # <>
        echo 'dd_of_file, length of element value:' "${#dd_of_file}"
        declare -p strings_o shabang_with_interpreter
        exit 101

      # Make a record of the filenames and their crashbangs in RAM.
      shell_scripts+=( [${i_1}]="$(
        printf '%-50s <%s>\n' "${shabang_with_interpreter}" "${nextfile}" )" )
      unset 'all_files[$i_1]'

        # <>
        #((++z))
        #if [[ $z == 10 ]]; then
          #declare -p shell_scripts shabang_with_interpreter nextfile
          #printf '%s\n' "${shell_scripts[@]}"
          #exit 101
        #fi
    fi
  done
}

# Bug: last line only has a crashbang
# Bug: restructured since last testing

# Open a timestamped file & append into it the list of filenames and 
# their crashbangs. 
_create_LT_datafile(){
  local dnf_o awk_o
  dnf_o="$( 
    dnf history info 0 ||
      _erx "${LINENO}" )"
  awk_o="$( 
    awk '/^Transaction ID/ { print $4 }' <<< "${dnf_o}" ||
      _erx "${LINENO}" )"
  
  printf '# crunchbangs\n' | 
    sudo tee "${f}" ||
      _erx "${LINENO}"
  printf '%s\n' "${shell_scripts[@]}" |
    sudo tee -a "${f}" ||
      _erx "${LINENO}"
  
  _bak "${f}"
  printf '\n#%%dnf%% %d\n' "${awk_o}" | 
    sudo tee -a ~/"${f##*/}" ||
      _erx "${LINENO}"
  
}


# if a long-term datafile, i.e., a crashbang/filename list, exists...
if [[ -f ~/"${f##*/}" ]]; then 
  
  # ...and if it has the same tx number as `dnf history` currently shows...
  tx_no="$( awk '/^#%dnf%/ { print $2 }' ~/"${f##*/}" || 
    _erx "${LINENO}" )"
  
  if [[ "${tx_no}" == "${dnf_history_number}" ]]
  then

    # ...then don't scan the HDD.
    :

  # Otherwise, erase the existing long-term datafile, do scan the HDD...
  else
    _bak ~/"${f##*/}"
    rm -f ~/"${f##*/}"
    _scan_local_disks

    # ...and create a new long-term datafile
    _create_LT_datafile
  fi

# and if a long-tern crashbang file DNE, then do scan the HDD
else
  _scan_local_disks

  # and create a long-term datafile
  _create_LT_datafile
fi




    
    
###  SECTION C  ###    

  # <>
  #declare -p shell_scripts
  #printf '%s\n' "${shell_scripts[@]}"
  #exit 101
  #set -x


# Make the data readable and useable.

# backup the original data file and make a long-term
# copy, for speed of debugging.
_bak "${f}"
rsync -ca "${f}" ~/"${f##*/}"
printf '#%%dnf%% %d\n' "$( 
  dnf history info 0 | 
    awk '/^Transaction ID/ { print $4 }' )" >> ~/"${f##*/}" ||
      _erx "${LINENO}"

  # <>
  #exit 101

# Alterations

# Alteration 0
# Do all of the interpreters exist on disk?
#mapfile -d '' -t interpreters < <(
# sudo head /run/media/root/15_Mar_2023/scf.d/latest/t_2023-03-21_102504/crunchbangs | grep ^'#!' | sed -e 's,#!,,g' -e 's,<.*,,g' -e 's,[[:space:]]*$,,g' -e 's, -.*,,g'| cat -Aen  

  ## Bug work: why remove spaces?
  ## Alteration 1: in the data file, fix the crashbangs that have spaces in
  ## them. ## works
  #_test_1(){
  #  sudo grep --quiet --extended-regexp ^'#! /' "$1" # ere_1
  #}
  #if _test_1 "$f"; then
  #  sudo sed --in-place 's,^#! /,#!/,g' "$f" # ere_1
  #  _test_1 "$f" && 
  #    _erx $LINENO
  #fi
  ## Note: most distros replace certain commands, such as `cp`, with 
  ## aliases.
  #command -p cp --archive "$f" "${f}_hashbangs-spaces-deleted"
  #_bak "${f}_hashbangs-spaces-deleted"
  # <>
  #exit 101
  #set -x

# Alteration 2: fix the odd extra data segments in the middles of the rows. 
# Requires using 'relevant_search_dirs' in the above `find` path. ## works
ere_2='>?[[:space:]]{3,}<?/?[[:alnum:]].*>?[[:space:]]{3,}<?'
# Bug? is opt -n necc?
_test_2(){
  sudo grep --extended-regexp --line-number "${ere_2}" "${1}" # ere_2
}
if _test_2 "${f}"; then
  sudo sed --in-place "s=${ere_2}=    =g" "${f}" # ere_2
  _test_2 "${f}" &&
    _erx "${LINENO}"
fi
command -p cp --archive "${f}" "${f}_extra-data-removed"
_bak "${f}_extra-data-removed"

  # <>
  ls -l "${f}"*
  wc "${f}"*
  exit 101
  set -x

# Question: do all of the interpreters exist on disk?

# Q: does #! accept relative paths?

# Q: will '#! /bin/env perl -T -w' fail? env -vS
# Bug: high disk io, slow

# Alteration 3: Apply grep-style line numbers, ie, in-file indices. These 
# are necessary for section 'Extra,' however, can only be applied prior 
# to the full list having been subdivided. 
grep --extended-regexp --line-number '.' "${f}" > "${f}_all-indexed"
_bak "${f}_all-indexed"


# CENTRAL TASK, 1 OF 2: Filter the list of crashbangs with the list 
# of shells.
#ere_3=^'[0-9]{1,7}:#! ?(/usr)?/bin/(env|(sh|bash|dash|ksh)?) *<?(/usr)?(/bin/)?(sh|bash|dash|ksh) ?>? *'
# Bug likely: ere3
ere_3=^"[0-9]{1,7}:#! ?(/usr)?/bin/(env|${shells}?) *<?(/usr)?(/bin/)?${shells} ?>? *"

grep --extended-regexp "${ere_3}" "${f}_all-indexed" > \
  "${f}_SC-scrpts-list" # ere_3
_bak "${f}_SC-scrpts-list"

  # <>
  ls -l "${f}"*
  wc "${f}"*
  exit 101
  set -x

  # Bug: Why?

  ## DEBUG: Invert the previous `grep` command, i.e.,
  ##   { NOT (sh|bash|dash|ksh) == (tclsh|zsh|tcsh) }
  #grep --extended-regexp --invert-match "${ere_3}" "${f}_all-indexed" |
  #sed --regexp-extended 's=[<>]=-----------------------------------------------------=g' |
  #sed 's=[[:space:]]==g' |
  #cut --characters -64 |
  #grep -F 'sh' > "${f}_addl-shells" # ere_3, at 1st grep
  #_bak "${f}" '_addl-shells'
  # <>
  #ls -l "${f}"*
  #cat "${f}_addl-shells"
  #wc "${f}"*


# EXTRA: get the list of files with crashbangs that aren't relevant 
# shell scripts.
unset full_index shells_subindx verify_subindx

# Bug: sb?: =( {0.."$( wc --lines "${f}_all-indexed" )" )
# Extra, array 1: get the full set of indices as a contiguous array. The number of indices 
# in full_index should equal `wc --lines` of "${f}_all-indexed"
mapfile -t -O 1 full_index < <( 
  cut --delimiter=':' --fields=1 "${f}_all-indexed" )

# Bug? cut this codeblock?
if ! [[ "${#full_index[@]}" == "$( 
  wc --lines "${f}_all-indexed" | 
    cut --delimiter=' ' --fields=1 )" ]]
then
  _erx "${LINENO}"
fi

  # <>
  _num full_index
  declare -p full_index | 
    less --LINE-NUMBERS --RAW-CONTROL-CHARS

# Bug? Is printing indices really necc?

# Array 2: get the partial set of indices, i.e., ; a sparse array, 
# which signify only the relevant scripts. number of indices in 
# shells_subindx should equal
# `wc -l` of "${f}_SC-scrpts-list".
mapfile -t -O 1 shells_subindx < <( 
  cut '-d:' -f1 "${f}_SC-scrpts-list" )

if ! [[ "${#shells_subindx[@]}" == "$( 
  wc --lines "${f}_SC-scrpts-list" | 
    cut --delimiter=' ' --fields=1 )" ]]
then
  _erx "${LINENO}"
fi

  # <>
  declare -p shells_subindx | 
    less --LINE-NUMBERS --RAW-CONTROL-CHARS
  _num shells_subindx
  wc "${f}"*

# Array 3: partial set of indices for only *irrelevant* scripts; also 
# a sparse array.
unset f b verify_subindx shells_dup
shells_dup=( "${shells_subindx[@]}" )

for x in "${full_index[@]}"; do

  for b in "${!shells_subindx[@]}"; do

    if [[ "${x}" -gt "${shells_subindx[${b}]}" ]]; then
      unset 'shells_subindx[$b]'
      continue 1

    elif [[ "${x}" = "${shells_subindx[${b}]}" ]]; then
      continue 2

    else
      verify_subindx+=( "${x}" )
      continue 2
    fi
  done
done

  # <>
  declare -p full_index shells_dup verify_subindx | 
    less --LINE-NUMBERS --RAW-CONTROL-CHARS

# the counts should equal
if [[ $(( "$( 
  _num shells_dup )" + "$( 
    _num verify_subindx )" )) -eq "$( 
    _num full_index )" ]]
then
  _erx "${LINENO}"
fi

# Bug: can sed do this loop in one fork?
for v in "${verify_subindx[@]}"; do
  sed --quiet "${v}p" "${f}_post-test2" >> "${unlisted}"
done
_bak "${unlisted}.bak"


# MAIN TASK, 2 of 2: with ShellCheck scan each script for errors
for i_2 in "${!shell_scripts[@]}"; do 
  script="${shell_scripts[${i_2}]}"

  # Run `shellcheck on the script and count the number of each issue's ID.
  mapfile -t careful < <( 
    shellcheck --severity "${severity}" "${script}" || 
      _erx "${LINENO}" )
  mapfile -t errs < <( 
    grep --fixed-strings --invert-match 'shellcheck.net' \
        <<< "${careful[@]}" | 
      grep --extended-regexp --only-matching 'SC[0-9]{4}' | 
      sort --general-numeric-sort | 
      uniq --count |
      sed 's,^[[:space:]]*,,g' || 
        _erx "${LINENO}" )

  # Bug: formatting

  # If shellcheck found any issues, then open & append some 
  # prioritized work lists with indices
  if [[ -n "${errs[*]:0:1}" ]]; then 
		
    printf '<idx:%d>  %%  <%s>\n' "${i_2}" "${script}" >> \
      "${f}_found_scripts_with_indices"

    for each_error in "${errs[@]}"; do
      printf '%s %% <idx:%d>\n' "${each_error//$'\n'/}" "${i_2}" >> \
        "${f}_found_errors_with_indices_unsorted"
    done
  fi
  unset errors script 'shell_scripts[$i_2]'
done

_bak "${f}_found_scripts_with_indices"
_bak "${f}_found_errors_with_indices_unsorted"

exit 0

