#!/bin/bash
# find-and-scan-shell-scripts-sh
# Written in bash version 5.1 on Fedora 37


###  SECTION A  ###
PATH="$( getconf PATH )"':/usr/bin:/usr/sbin'
LC_ALL=C

# Implementation-dependent arguments for options parsable by `shellcheck`:
severity='error'
shells='(sh|bash|dash|ksh)'

# Variables
fstype_regexp='(autofs|binfmt_misc|bpf|cgroup2|configfs|debugfs|devpts|devtmpfs|efivarfs|fusectl|fuse.portal|hugetlbfs|iso9660|mqueue|proc|pstore|rpc_pipefs|securityfs|selinuxfs|sysfs|tmpfs|tracefs)'
time="$( builtin printf '%(%F_%H%M%S)T' )"

# Functions
_bak(){ 
  # shellcheck disable=SC2002
  cat "${1}" |
    tee --output-error='exit' "${1}".bak > /dev/null 2>&1 ||
      _erx '_\bak' "${1}"
}
_erx(){ 
  local ec="${?}"
  echo Error: "$@" 
  return "${ec}"
}
_num(){ 
  local -n array="$1" 
  echo "${#array[@]}"
}
# Usage:  _usage [exit-code]
_usage(){
  cat <<-\EOF
    SCF - Shell Check Find, version 1.0 (redhat-linux)
    Find and scan shell scripts depending on severity level. 
        Usage:  ./find-and-scan-shell-scripts-sh [-ehiw]
                -e error          -i info
                -h help           -w warning
    Only the first option is processed.
EOF
  exit "${1}"
}

# Option parsing
if [[ "${#}" -gt 0 ]]; then
  first_two_chars="${1:0:2}"
  case "${first_two_chars}" in
    --) printf '\n\tHappy Easter!\n\n'
          exit 0;;
    -e) severity='error';;
    -i) severity='info';;
    -w) severity='warning';;
    -h) _usage 0;;
    *)  _usage 1;;
  esac
fi


# Create the data directories
sudo -v

#   In case of large log files, programatically select a save directory, 
# attached to the local disk, where any output can be saved; prefer USB 
# flash drives. This particular `df` command will output three alpha-
# numeric strings separated by whitespace on a single line. `sort` the 
# output by descending size. With `awk`, take the device with the most 
# available space and get its mountpoint with `findmnt`. If there is no 
# output, then set 'mountpoint' according to environment variables. 
mountpoint="$( 
  findmnt --canonicalize --output=target --noheadings "$( 
    sudo find /run/media -mindepth 2 -maxdepth 2 -type d |
      df --sync --local --output='fstype,avail,source' --block-size=1 |
      grep --extended-regexp --invert-match '^Type[[:space:]]*Avail' |
      grep --extended-regexp --invert-match ^"$fstype_regexp" |
      sort --general-numeric-sort --reverse --key=2 |
      awk 'NR == 1 { print $3 }'
  )"
)"

[[ -z "${mountpoint}" ]] &&
  mountpoint="${TEMPDIR:="${HOME}"}"
datadir="${mountpoint}/scf.d/latest"
timedir="${datadir}/t_${time}"
datafile="${timedir}/crunchbangs"
unlisted="${timedir}/unlisted"
umask 077

if ! sudo command test -d "${datadir}"; then
  sudo mkdir --parents "${datadir}" ||
    _erx "${LINENO}"
fi

# Label the current data as "latest."
mapfile -d '' -t previous < <( 
  sudo find "${datadir}" -mindepth 1 -maxdepth 1 -type d \
    -name 't_*' -print0 2> /dev/null )
if [[ -n "${previous[*]:0:1}" ]]; then
  sudo mv "${previous[@]}" "${mountpoint}/scf.d/" ||  
    _erx "${LINENO}"
fi
if ! sudo command test -d "${timedir}"; then
  sudo mkdir --parents "${timedir}" ||
    _erx "${LINENO}"
fi

# Gather filenames from local attached disk storage, of files with 
# size not equal to 0 bytes.
# shellcheck disable=SC2034
mapfile -d '' -t relevant_search_dirs < <(
  find / -mindepth 1 -maxdepth 1 -type d \! -empty \
    \( \! -name proc -a \! -name sys -a \! -iname 'scf.d' \) -print0 )

# DEBUG: "${relevant_search_dirs[@]}" OR '/usr/sbin' OR /usr/{,s}bin
mapfile -d '' -t all_files < <( 
  sudo find \
    /usr/sbin \
      -type f \! -empty -print0 2> /dev/null )
    #/usr/sbin /usr/bin \
    #/usr/sbin \
    #"${relevant_search_dirs[@]}" \

  # <> ##############################################################
  sudo touch "${timedir}/A_vars" "${datafile}_a-all_files" ||
    _erx "${LINENO}"
  {
    declare -p PATH LC_ALL severity shells fstype_regexp time
    declare -pf _bak _erx _num _usage
    declare -p first_two_chars mountpoint datadir timedir datafile unlisted 
    declare -p previous relevant_search_dirs 
    declare -p all_files
  } | 
    sudo tee --output-error='exit' "${timedir}/A_vars" \
        > /dev/null 2>&1 ||
      _erx "${LINENO}"
  declare -p all_files | 
    sudo tee --output-error='exit' \
        /tmp/"${datafile##*/}_a-all_files" "${datafile}_a-all_files" \
          > /dev/null 2>&1 ||
      _erx "${LINENO}"
  _bak "${timedir}/A_vars"
  _bak "${datafile}_a-all_files"
  _bak /tmp/"${datafile##*/}_a-all_files"
  #exit 101
  #set -x





###  SECTION B  ###
# Add some brevity, and write the completed arrays to disk
c="${#all_files[@]}"
f="${datafile}"
unset IFS

# Functions for this section
#   Note: this function can take 30-90 minutes!
_scan_local_disks(){
  # Sort out the scripts, ie, any file beginning with a crashbang ('#!'), 
  # from the rest of the files.
  for i_1 in "${!all_files[@]}"; do
    
    unset X od_o line_1

    # Bug, inordinately long interpreter paths are rare, but do occur.
    # Read from disk in binary the first two bytes of each file in 
    # the list and output it in hexadecimal.
    #   Note: POSIX `od` doesn't have GNU's '--strings' option, so use 
    # the `strings` command separately, if necessary.
    #   Note: `od` command is POSIX compliant
    # shellcheck disable=SC2034
    builtin read -r X od_o X < <( 
      sudo od -N2 -x "${all_files[${i_1}]}" ||
        _erx "${LINENO}" ) 
   
    # If 'od_o' contains some non-zero data, as it should, 
    if [[ -z "${od_o}" ]]; then
      _erx "${LINENO}"
	
    # compare the hexidecimal representations to find any crashbangs.
    elif [[ "${od_o}" == '2123' ]]; then
      
      # Use 'read', and hope there won't be any non-printable characters.
      IFS= builtin read -r line_1 < "${all_files[${i_1}]}" ||
          _erx "${LINENO}"

      # Make a record of the filenames and their crashbangs in RAM.
      shell_scripts+=( [${i_1}]="$( 
        printf '%-50s   %% %% %% %%   %s\n' "${line_1}" \
          "${all_files[${i_1}]}" )" )
      unset 'all_files[$i_1]'
    else
      all_other_files+=( [${i_1}]="${all_files[${i_1}]}" )
      unset 'all_files[$i_1]'
    fi

    printf '%d of %d\r' "${i_1}" "${c}"
  done
}

# Open a timestamped file & append into it the list of filenames and 
# their crashbangs. 
_create_datafile(){
  # create the original datafile
  printf '# crunchbangs -- %s \n' "${time}" | 
    sudo tee --output-error='exit' "${f}" /tmp/"${f##*/}" \
        > /dev/null 2>&1 ||
      _erx "${LINENO}"
  printf '%s\n' "${shell_scripts[@]}" |
    sudo tee --append --output-error='exit' "${f}" /tmp/"${f##*/}" \
        > /dev/null 2>&1 ||
      _erx "${LINENO}"
  _bak "${f}"
  _bak /tmp/"${f##*/}"
}

# run the functions 
_scan_local_disks
_create_datafile

  # <> ##############################################################
  sudo touch "${timedir}/B_vars" "${f}_a-all_other_files" ||
    _erx "${LINENO}"
  
  {
  declare -p f i_1 od_o X line_1 c
  declare -pf _scan_local_disks _create_datafile
  declare -p shell_scripts all_other_files
  } |
    sudo tee --append --output-error='exit' "${timedir}/B_vars" \
        > /dev/null 2>&1 ||
      _erx "${LINENO}"
  
  declare -p all_other_files | 
    sudo tee --append --output-error='exit' "${f}_a-all_other_files" \
        > /dev/null 2>&1 ||
      _erx "${LINENO}"

  #printf '\n' |
    #sudo tee --append --output-error='exit' "${timedir}/B_vars" \
        #"${f}_a-all_other_files" > /dev/null 2>&1 ||
      #_erx "${LINENO}"

  _bak "${timedir}/B_vars"
  _bak "${f}_a-all_other_files"

  exit 101
  set -x




    
###  SECTION C  ###    

# Make the data readable and useable.

# Alterations

# Alteration 2: fix the odd extra data segments in the middles of the rows. 
# Requires using 'relevant_search_dirs' in the above `find` path. ## works
ere_2='>?[[:space:]]{3,}<?/?[[:alnum:]].*>?[[:space:]]{3,}<?'
# Bug? is opt -n necc?
_test_2(){
  sudo grep --extended-regexp --line-number "${ere_2}" "${1}" # ere_2
}
if _test_2 "${f}"; then
  sudo sed --in-place "s=${ere_2}=    =g" "${f}" # ere_2
  _test_2 "${f}" &&
    _erx "${LINENO}"
fi
command -p cp --archive "${f}" "${f}_extra-data-removed"
_bak "${f}_extra-data-removed"

  # <>
  ls -l "${f}"*
  wc "${f}"*
  sudo sha256sum "${f}.bak" "${f}_extra-data-removed"
  
  exit 101
  set -x


# Bug: high disk io, slow

# Alteration 3: Apply grep-style line numbers, ie, in-file indices. These 
# are necessary for section 'Extra,' however, can only be applied prior 
# to the full list having been subdivided. 
grep --extended-regexp --line-number '.' "${f}" > "${f}_all-indexed"
_bak "${f}_all-indexed"


# CENTRAL TASK, 1 OF 2: Filter the list of crashbangs with the list 
# of shells.
#ere_3=^'[0-9]{1,7}:#! ?(/usr)?/bin/(env|(sh|bash|dash|ksh)?) *<?(/usr)?(/bin/)?(sh|bash|dash|ksh) ?>? *'
# Bug likely: ere3
ere_3=^"[0-9]{1,7}:#! ?(/usr)?/bin/(env|${shells}?) *<?(/usr)?(/bin/)?${shells} ?>? *"

grep --extended-regexp "${ere_3}" "${f}_all-indexed" > \
  "${f}_SC-scrpts-list" # ere_3
_bak "${f}_SC-scrpts-list"

  # <>
  ls -l "${f}"*
  wc "${f}"*
  exit 101
  set -x



# MAIN TASK, 2 of 2: with ShellCheck scan each script for errors
for i_2 in "${!shell_scripts[@]}"; do 
  script="${shell_scripts[${i_2}]}"

  # Run `shellcheck on the script and count the number of each issue's ID.
  mapfile -t careful < <( 
    shellcheck --severity "${severity}" "${script}" || 
      _erx "${LINENO}" )
  mapfile -t errs < <( 
    grep --fixed-strings --invert-match 'shellcheck.net' \
        <<< "${careful[@]}" | 
      grep --extended-regexp --only-matching 'SC[0-9]{4}' | 
      sort --general-numeric-sort | 
      uniq --count |
      sed 's,^[[:space:]]*,,g' || 
        _erx "${LINENO}" )

  # Bug: formatting

  # If shellcheck found any issues, then open & append some 
  # prioritized work lists with indices
  if [[ -n "${errs[*]:0:1}" ]]; then 
		
    printf '<idx:%d>  %%  <%s>\n' "${i_2}" "${script}" >> \
      "${f}_found_scripts_with_indices"

    for each_error in "${errs[@]}"; do
      printf '%s %% <idx:%d>\n' "${each_error//$'\n'/}" "${i_2}" >> \
        "${f}_found_errors_with_indices_unsorted"
    done
  fi
  unset errors script 'shell_scripts[$i_2]'
done

_bak "${f}_found_scripts_with_indices"
_bak "${f}_found_errors_with_indices_unsorted"

exit 0

