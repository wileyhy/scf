#!/bin/bash
# Q: name sb scfi ? scf ?
# Written in bash version 5.1 on Fedora 37

# Note: Keep your goal in mind.

# SECTION A
:
: 'Regular users only'
:
if [[ "${UID}" == 0 ]]; then
  printf '\n\t Must be a regular user and use sudo. \n\n'
  exit 1
else
  sudo -v \
    || exit 1
fi
:
: 'Implementation-dependent arguments for opts parsable by -shellcheck-'
:
severity=error
# shellcheck disable=SC2034
shells='(sh|bash|dash|ksh)'
:
: 'Variables that lend themselves to some customization' # AJAX
:
repo_nm=scrfi
script_dirnm="${repo_nm}.d"
script_nm=find-and-scan-shell-scripts-sh
script_proper_nm='Script Finder'
script_version=1.0
a_poss_proces_lock_dirs=([0]="${XDG_RUNTIME_DIR}" [1]="${HOME}"
  [2]="${TMPDIR}" [3]=/tmp [4]=/var/tmp)
umask 117
a_relevant_search_dirs=( /usr/sbin ); abbrev_rel_search_dirs=s
#a_relevant_search_dirs=( /usr/sbin /usr/bin ); abbrev_rel_search_dirs=sb
#a_relevant_search_dirs=( /usr/sbin /usr/bin /etc ); abbrev_rel_search_dirs=sbe
#a_relevant_search_dirs=( /usr/sbin /usr/bin /etc /var ); abbrev_rel_search_dirs=sbev
#a_relevant_search_dirs=(/usr/sbin /usr/bin /etc /var /root); abbrev_rel_search_dirs=sbevr
#abbrev_rel_search_dirs=all
:
: 'Aliases'
:
shopt -s expand_aliases
alias :_=':;: "<>"' \
      B_='fn_bak ' \
      D_='declare -p ' \
      I_='fn_erx "${LINENO}" ' \
      L_='exit "${LINENO}"' \
      N_='fn_num ' \
      S_='sudo ' \
      T_='tee --output-error=exit ' \
      U_='fn_usage ' \
      V_='fn_write_vars ' \
      W_='fn_write_arrays ' \
      X_='set -x'
:
: 'Environment variables'
:
unset LC_ALL
LC_COLLATE="C.UTF-8"     # for predictable sorting
LC_CTYPE="C.UTF-8"       #  "   "           "
LC_NUMERIC="en_US.UTF-8" # for commas in large numbers
:
PATH="$(/usr/bin/command -p getconf PATH):/usr/bin:/usr/sbin:${PATH}" \
  || L_
export LC_COLLATE LC_CTYPE LC_NUMERIC PATH

:
: 'Check for Process Locks'
:
for d in "${a_poss_proces_lock_dirs[@]}"; do
  if [[ -d "${d}" ]]; then
    
    mapfile -d '' -t lkds < <( 
      S_ find "${d}" -type d -empty -name ".${repo_nm}.[0-9a-zA-Z_-]*.lock" \
        -print0 2> /dev/null)
    :
    : 'lkds, count:' "${#lkds[@]}"
    :
    for l in "${lkds[@]}"; do
      if [[ -d "${l}" ]]; then
        if [[ -v delete_locks ]]; then
          rmdir -v "${l}"
        else
          printf '\n\t A process lock exists for this script. Exiting '
          printf 'now.\n\n'
          L_
        fi
      fi
    done
  fi
done
[[ -v delete_locks ]] \
  && L_
:
: 'Functions'
:
fn_bak() {
  : fn_bak

  # for each of multiple input files
  for loc_filename_a in "${@}"; do

    # test verifying existence of input
    if S_ test -f -- "${loc_filename_a}"; then

      # if the destination (.bak) file already exists,
      # then age it first.
      if [[ -f "${loc_filename_a}.bak" ]]; then
        
        if [[ -s "${loc_filename_a}.bak" ]]; then
          return
        else
          S_ rm -f -- "${loc_filename_a}.bak"
        fi
      fi

      # write a new .bak file
      S_ rsync -acq -- "${loc_filename_a}"{,.bak} \
        || I_

    # if input file DNE, then print an error and exit
    else
      { 
        echo WARNING: file DNE "${loc_filename_a}"
        return
      }
    fi
  done
  : 'END OF fn_bak'
  :
}
fn_erx() {
  # this assignment must be the first command
  local loc_exit_code="${?}"
  : fn_erx

  # print an error message and exit with the correct exit code
  echo -e Error: "${@}"
  : 'END OF fn_erx'
  :
  exit "${loc_exit_code}"
}
fn_num() {
  # Usage: N_ [raw arrays names]
  : fn_num

  # for each of multiple input array names
  for loc_unquotd_array_nm_a in "${@}"; do

    # set a local name reference variable
    local -n loc_nameref_a="${loc_unquotd_array_nm_a}"

    # and use the nameref to print the number of indices in the input array
    echo ${#loc_nameref_a[@]}
  done
  : 'END OF fn_num'
  :
}
fn_usage() {
  # Usage:  U_ [exit-code]
  : fn_usage

  # print a usage message and exit with a pre-determined exit code
  cat <<-EOF
    ${repo_nm} - ${script_proper_nm}, version ${script_version} (for 
      redhat-linux)
    Find and scan shell scripts depending on severity level. 
        Usage:  ${script_nm} [-ehiw]
                -e error          -i info
                -h help           -w warning
    Only the first option is processed.

EOF
  : 'END OF fn_usage'
  :
  # shellcheck disable=SC2086
  exit "${1}"
}
fn_write_arrays() {
  # Usage: W_ [arrays]
  :
  : fn_write_arrays: Write each array to a file on disk.

  loc_write_d_b="${curr_time_ssubd}arrays"

  if [[ ! -d "${loc_write_d_b}" ]]; then
    S_ mkdir -p -- "${loc_write_d_b}" \
      || I_
  fi

  # for each of multiple input array names
  for loc_unquotd_array_nm_b in "${@}"; do
    
    # create local variables, for use as both array and string
    local -n loc_nameref_b="${loc_unquotd_array_nm_b}"
    loc_array_nm="${loc_unquotd_array_nm_b}"
    loc_write_f_b="${loc_write_d_b}/_${severity:0:1}"
    loc_write_f_b="${loc_write_f_b}_${abbrev_rel_search_dirs}_${loc_array_nm}"

    # solved?  BUG: mixing variable and array. sb a nameref

    # Bug? When array correctly is empty. 'declare -p ... > /dev/null ||' ?

    # if the input array holds any data
    if [[ ! -v loc_nameref_b[@] ]]; then

      # if input array holds no data, then print an error and exit
      loc_nameref_b=([0]='Empty array')
      :
    fi
    :
    # then write a data file to disk
    declare -p "${loc_array_nm}" \
      | S_ T_ -- "${loc_write_f_b}" > /dev/null

    # write a backup of the new data file
    :
    B_ "${loc_write_f_b}"
  done
  : 'END OF fn_write_arrays'
  :
}
fn_write_vars() {
  # Usage: V_ [loc_script_section_nm] [raw variable names]

  # first pos-parm is string used for differentiating filename
  : fn_write_vars
  loc_script_section_nm="${1}"
  loc_write_f_a="${curr_time_ssubd}/${loc_script_section_nm}_vars"
  shift

  # if the destination file already exists, then age it first
  [[ -e "${loc_write_f_a}" ]] \
    && return

  # write a new data file
  declare -p "${@}" 2>/dev/null \
    | S_ T_ -- "${loc_write_f_a}" >/dev/null

  # and write a .bak file
  :
  B_ "${loc_write_f_a}"
  : END OF fn_write_vars
  :
}
:
: Use -sudo-
if ! S_ -v; then
  printf '\n\tValidation failed of user\x27s \x60sudo\x60 timestamp; '
  printf 'exiting.\n\n'
  L_
fi
:
# Set up a trap on signals "exit", "term" and "int"
# shellcheck disable=SC2154
trap '
  #set -
  :
  # [Trap] Delete all possible process directories, if they exist. 
  for poss_lk_d in "${a_poss_proces_lock_dirs[@]}"; do 
    :
    # [Trap] Abbreviate var, then test and delete lock dirs.
    pl="${poss_lk_d}/${proc_lk_f_nm}"
    :
    if [[ -d "${pl}" ]] && [[ ! -L "${pl}" ]]; then 
      S_ rm -rf -- "${pl}" \
        || L_
    fi
  done
  :
  # [Trap] Remove any script-s ACL-s based on whether the canary variables
  # exist.
  if [[ -v acl_execd_setfacl ]]; then 
    : 
    if [[ -v acl_abs_path ]]; then 
      S_ setfacl -R -x "u:${UID}" -- "${acl_abs_path}" ||
        echo Error: setfacl failed, line "${LINENO}"
      :
    # bug? Should this var be main_d ?
      :
    elif [[ -v mountpoint ]]; then
      S_ setfacl -R -x "u:${UID}" -- "${mountpoint}" ||
        echo Error: setfacl failed, line "${LINENO}"
    fi
  fi
  :
  trap - EXIT TERM INT
  kill -s INT $$
' EXIT TERM INT
:
#:_; X_
:
: 'Process lock'
:
# define basename and absolute path of the lock directory
random_n="${RANDOM}"
proc_lk_f_nm=".${repo_nm}.${$}${random_n}.lock"
:
#:_; D_ a_poss_proces_lock_dirs
:
# from among the poosible dirnames
for poss_lk_d in "${a_poss_proces_lock_dirs[@]}"; do
  :
  # use the first one that fulfills certain requirements
  if [[ -d "${poss_lk_d}" ]] \
    && [[ ! -L "${poss_lk_d}" ]] \
    && [[ -w "${poss_lk_d}" ]]; then
    :
    # define the lock directory
    process_lock_d="${poss_lk_d}/${proc_lk_f_nm}"
    break
  fi
done
:
# create the lock directory
if ! mkdir -m 0000 "${process_lock_d}" 2>/dev/null; then
  {
    printf '\n\tCannot acquire process lock: <%s>.\n' "${process_lock_d}"
    printf '\tID: %s\n' "${USER}"
    printf 'Exiting.\n\n'
  } 1>&2
  L_
fi
:
#:_; D_ process_lock_d; S_ namei -xl -- "${process_lock_d}"; L_
:
: User variables
timecode="$(builtin printf '%(%F_%H%M%S)T')"
:
: Option parsing
if [[ ${#} -gt 0 ]]; then
  cli_input="${1:0:2}"
  :
  # shellcheck disable=SC2034
  case "${cli_input}" in
    --)
      printf 0a09486170707920456173746572210a0a \
        | xxd -r -p
      exit 0
      ;;
    -e) severity=error ;;
    -i) severity=info ;;
    -v)
      printf 0a09224920776f756c642068617665206d61646520746869732073686f727465722c206275742049206469646e27742068617665207468652074696d652e220a09092d2d204d61726b20547761696e0a0a \
        | xxd -r -p
      exit 0
      ;;
    -w) severity=warning ;;
    -h)
      :
      U_ 0
      ;;
    *)
      :
      U_ 1
      ;;
  esac
fi
:
# SECTION B
:
#:_
#X_
:
: 'Assign varnames and paths for the data directories'
mountpoint=/run/media/root/29_Mar_2023
main_d="${mountpoint}/${script_dirnm}"
data_subd="${main_d}/latest_data"
curr_time_ssubd="${data_subd}/t_${timecode}/"
list_crunchbangs="${curr_time_ssubd}/crunchbangs"
found_scrpts_f="${list_crunchbangs}_found_scripts_${severity:0:1}_${abbrev_rel_search_dirs}"
:
: 'data files'
a_write_path_nms=("${list_crunchbangs:=crunchbangs}" "/tmp/${list_crunchbangs##*/}")
:
: 'Reduce use of sudo'
if [[ ! -r "${main_d}" ]]; then
  :
  mapfile -d / -t a_acl_name_indiv_dir <<<"${main_d}"
  :
  a_acl_name_indiv_dir[0]=/
  a_acl_name_indiv_dir[-1]="${a_acl_name_indiv_dir[-1]//$'\n'/}"
  :
  acl_each_dir=${#a_acl_name_indiv_dir[@]}
  :
  for ((iterator_1 = 0; iterator_1 < acl_each_dir; iterator_1++)); do
    acl_abs_path+="/${a_acl_name_indiv_dir[iterator_1]}"
    acl_realpath="$(realpath -e "${acl_abs_path}")"
    :
    if S_ test -e -- "${acl_realpath}"; then
      : 'test succeeded: acl_realpath exists '
    else
      :
      : 'test failed: acl_realpath DNE'
      :
      if [[ ! -d "${acl_abs_path}" ]]; then
        :
        S_ mkdir -p -- "${main_d}" \
          || I_
      fi
      :
      acl_realpath="$(realpath -e "${acl_abs_path}" 2>/dev/null)"
      :
      #:_
      #S_ namei -xl -- "${acl_realpath}"
      :
    fi
    :
    if [[ -r "${acl_realpath}" ]]; then
      : 'test succeeded: acl_realpath is readable'
    else
      :
      : 'test failed: acl_realpath is not readable'
      :
      acl_execd_setfacl=y
      export acl_execd_setfacl # SC2034, while trap-s setfacl blk is #-d
      :
      # readable up to the main_d
      S_ chmod -R 750 -- "${acl_realpath}" \
        || I_
        :
      S_ setfacl -d -m "${USER}:r-x" -- "${acl_realpath}" \
        || I_
        :
      S_ setfacl -m "${USER}:r-x" -- "${acl_realpath}" \
        || I_
        :
      #:_
      #id "${USER}"
      #groups "${USER}"
      #S_ namei -xl -- "${acl_realpath}"
      #S_ getfacl -- "${acl_realpath}"
      :
      [[ -r "${acl_realpath}" ]] \
        || I_
    fi
  done
  :
  # writeable within the main_d
  S_ setfacl -d -m "${USER}:rwx" -- "${main_d}" \
    || I_
    :
  S_ setfacl -R -m "${USER}:rwx" -- "${main_d}" \
    || I_
    :
  #:_
  #id "${USER}"
  #groups "${USER}"
  #S_ namei -xl -- "${main_d}"
  #S_ getfacl -- "${main_d}"
  :
fi
:
: 'make sure -data_subd- is a directory OR create the -data_subd- dir '
: 'if necessary'
[[ -d "${data_subd}" ]] \
  || mkdir "${data_subd}" # as liveuser
  :
#:_
#S_ namei -xl -- "${data_subd}"
:
: Label the current data as -latest.-
# shellcheck disable=SC2312
mapfile -d '' -t a_previous_time_dirs < <(
  find "${data_subd}" -mindepth 1 -maxdepth 1 -type d -a \! -type l \
    -name 't_*' -print0
)
:
: if -prev_time_ssubd- is empty, delete it, otherwise -mv- it out
: of the -latest- dir
for prev_time_ssubd in "${a_previous_time_dirs[@]}"; do
  rmdir --ignore-fail-on-non-empty "${prev_time_ssubd}"
  :
  : of previous prev_time_ssubd
  if [[ -d "${prev_time_ssubd}" ]] && [[ ! -L "${prev_time_ssubd}" ]]; then
    S_ mv -- "${a_previous_time_dirs[@]}" "${main_d}"
  else
    continue
  fi
done
:
: of curr_time_ssubd
if [[ ! -d "${curr_time_ssubd}" ]]; then
  S_ mkdir -p -- "${curr_time_ssubd}" \
    || I_
fi
:
#:_
#S_ namei -xl -- "${curr_time_ssubd}"
:
# SECTION C
:
: 'Gather filenames from local attached disk storage'
:
if [[ "${abbrev_rel_search_dirs}" == all ]]; then
  :
  : 'in any event, create a new record for a_relevant_search_dirs and..'
  # shellcheck disable=SC2312
  mapfile -d '' -t a_relevant_search_dirs < <(
    S_ find / -mindepth 1 -maxdepth 1 -type d \! -empty \
      \( \! -name proc -a \! -name sys -a \! -iname "${script_dirnm}*" \) \
      -print0 2>/dev/null
  )
  :
fi
:
: 'Find all files on disk. Even the empty ones.'
# shellcheck disable=SC2312
mapfile -d '' -t a_all_files < <(
  S_ find "${a_relevant_search_dirs[@]}" -mindepth 1 -type f \
    -print0 2>/dev/null
)
:
: 'Sort the original array and test it.'
# shellcheck disable=SC2312
mapfile -d '' -t a_all_files_sorted < <(
  printf '%s\0' "${a_all_files[@]}" \
    | sort -z
)
:
# SECTION D
:
# Bug? Can more indices and fewer files be used?
:
: Add some brevity, and write the completed arrays to disk
# shellcheck disable=SC2034
total_count="$(printf "%'d" "${#a_all_files_sorted[@]}")"
unset IFS
:
[[ -f /tmp/"${list_crunchbangs##*/}" ]] \
  && S_ rm -f -- "/tmp/${list_crunchbangs##*/}"
:
# BUG: the search dirs must be the same, as well as the dnf tx number
:
: 'if the full list exists -- of files on disk which begin with'
: 'crashbangs -- skip the 30-90 minute search phase.'
if [[ ! -f "/tmp/${list_crunchbangs##*/}" ]] \
  || [[ -L "/tmp/${list_crunchbangs##*/}" ]]
then
  :
  : 'Sort out the scripts, ie, any file beginning with a crashbang from'
  : 'the rest of the files'
  for all_files_index in "${!a_all_files_sorted[@]}"; 
  do
    :
    : 'Loop'
    :
    loop_idx="$(printf "%'d" $((all_files_index + 1)))"
    printf '%s of %s files\r' "${loop_idx}" "${total_count}"
    :
    : 'file must exist'
    each_sorted_f="${a_all_files_sorted[all_files_index]}"
    :
    if [[ ! -e "${each_sorted_f}" ]]; 
    then
      a_file_DNE+=([all_files_index]="${each_sorted_f}")
      continue
    fi
    :
    : 'list of empties'
    if [[ ! -s "${each_sorted_f}" ]]; 
    then
      a_empty_files+=([all_files_index]="${each_sorted_f}")
      continue
    fi
    :
    : '-file- magic'
    printf '+ %-8d: ' "${all_files_index}" \
      | S_ tee -a -- "${curr_time_ssubd}file_out" > /dev/null
      :
    file_o="$(S_ file -pk -- "${each_sorted_f}" 2>&1)"
    file_o="${file_o%%64-bit LSB *}"
    a_bin_file_output+=([all_files_index]="${file_o}")
    :
    if [[ -n "${file_o}" ]]; 
    then
      S_ tee -a -- "${curr_time_ssubd}file_out" <<< "${file_o}" > /dev/null
    else
      err_msg="WARNING: -file- produced 0 output:  <${each_sorted_f}>"
      S_ tee -a -- "${curr_time_ssubd}file_out" <<< "${err_msg}" > /dev/null
    fi
    :
    # Bug: keep `od` output in an array
    # Bug: avoid as many disk writes as possible.
    # Bug: use indices to reference each type?
    :
    : 'two bytes each'
      :
      #X_
      :_
    od_o="$(S_ od -j 0 -N 2 -t x1z -v -- "${each_sorted_f}"\
      | tr -s ' ' \
      | awk '{ print $2, $3, $4 }' \
      | tr -d '\n' \
      || I_ "P:${PIPESTATUS[*]} I:${all_files_index} ${each_sorted_f}")"
      :
      #D_ od_o
      :
    [[ -n "${od_o}" ]] \
      || I_ "I:${all_files_index} ${each_sorted_f}"
      :
    a_bin_od_output+=([all_files_index]="${od_o}")
      :
      #D_ a_bin_od_output
      :
    read -r byte_0 byte_1 printable_chars <<< "${od_o}" 
      :
      #D_ byte_0 byte_1 printable_chars a_all_other_files; L_;
      :
    export printable_chars # SC2034
      :
    : '-od_o- non-zero'
    if [[ -z "${byte_0}" ]]; 
    then
      I_ "I:${all_files_index} <${each_sorted_f}>" \
        '*unreachable code*'
        :
    : 'compare hexadecimals'
    elif [[ "${byte_0}" == @(23|21) ]]; 
    then
      :
      : 'endianness'
      if [[ "${byte_0}${byte_1}" == 2123 ]]; 
      then
        a_incorrect_endianness+=([all_files_index]="${each_sorted_f}")
        :
        # BUG: expect non-printable characters
      else
        :
        : 'Crunchbangs'
        strings_o="$(strings -n1 < "${each_sorted_f}" \
          | head -n1 \
          | cut -b -$((2**14)) \
          || I_ "P:${PIPESTATUS[*]} I:${all_files_index} ${each_sorted_f}")"
          :
        IFS= read -r first_line_printable <<< "${strings_o}" \
          || I_ "I:${all_files_index} ${each_sorted_f}"
          :
        : '-#!comment-'
        if [[ "${first_line_printable}" =~ ^'#!comment' ]]; 
        then
          a_crunches_with_hashbang_comments+=(
            [all_files_index]="${each_sorted_f}")
          continue
        fi
        :
        #D_ strings_o first_line_printable all_files_index each_sorted_f; L_;
        :
        #   Note: with only /bin/sbin, this if-fi block doesn't execute
        :
        : 'outside of rpm'
        if ! rpm -qf "${each_sorted_f}" 2>/dev/null 1>&2; 
        then
          :
          : 'user or system'
          if [[ "${each_sorted_f}" = /@(root|home|run/media)/* ]]; 
          then
            a_non_rpm_user_crunches+=([all_files_index]="${each_sorted_f}")
            continue
          else
            a_non_rpm_system_crunches+=(
              [all_files_index]="${each_sorted_f}")
            continue
          fi
        fi
      fi
      :
      #X_; :_
      :
      : 'Make an array of the relevant filenames and their crashbangs.'
      a_shell_scripts+=([all_files_index]="$(printf \
        "%'-12d %%=%%=%%=%% %-50s %%=%%=%%=%% %s\n" \
          "${all_files_index}" "${first_line_printable}" \
          "${each_sorted_f}")"
        )
      :
      #:_; D_ a_shell_scripts all_files_index first_line_printable each_sorted_f; L_
    else
      :
      : 'all others'
      a_all_other_files+=([all_files_index]="$(printf \
        "%'-12d %%=%%=%%=%% %s\n" "${all_files_index}" \
          "${each_sorted_f}")"
        )
    fi
  done
  :
  #X_; :_; D_ a_shell_scripts all_files_index first_line_printable each_sorted_f; L_
  
  :
  : 'Open a timestamped file and append into it the list of filenames' 
  : 'and their crashbangs.'
  :
  : 'Exporting is necessary of the array names from the above scan'
  a_arrays=( a_all_files a_all_files_sorted a_file_DNE a_empty_files a_bin_file_output a_bin_od_output a_incorrect_endianness a_crunches_with_hashbang_comments a_non_rpm_user_crunches a_non_rpm_system_crunches a_shell_scripts a_all_other_files a_write_path_nms )
  export  "${a_arrays[@]}"
  :
  W_ "${a_arrays[@]}"; 
  B_ "${curr_time_ssubd}/file_out"; 
  #L_;
  :
  : 'if any data files already exist, keep them'
  for any_existing_f in "${a_write_path_nms[@]}"; do
    :
    if [[ -f "${any_existing_f}" ]] && [[ ! -L "${any_existing_f}" ]]; then
      S_ mv -- "${any_existing_f}" "${any_existing_f}.${$}.${random_n}" \
        || I_
    fi
  done
  :
  : 'create the original list_crunchbangs'
  S_ touch -- "${a_write_path_nms[@]}"
  :
  : 'write a file header'
  {
    printf '# crunchbangs -- %s\n' "${timecode%-*}"
    printf '# %s\n' "$(declare -p a_relevant_search_dirs)"
  } | S_ T_ -- "${a_write_path_nms[@]}" > /dev/null
  :
  : 'printing contents of a_shell_scripts array, with backup'
  printf '%s\n' "${a_shell_scripts[@]}" \
    | S_ T_ -a -- "${a_write_path_nms[@]}" > /dev/null
  B_ "${a_write_path_nms[@]}"
  :
else
  :
  # the time_dir needs a copy of the crunchbangs file, also.  copy it in
  # from the hopefully correct backup in /tmp
  if [[ ! -f "${list_crunchbangs}" ]]; 
  then
    S_ rsync -ca -- "/tmp/${list_crunchbangs##*/}" "${list_crunchbangs}" \
      || I_
  fi
fi
:
W_ a_write_path_nms; 
:
#X_; :_; 
S_ head -- "/tmp/${list_crunchbangs##*/}"; 
#L_;
:

:
: 'Verify inter^preters'
:
: 'Get the list of interpreters from the list of crunchbangs.'
#   Note: new indices starting from 0
# shellcheck disable=SC2016
mapfile -t a_interpreters < <( 
  S_ awk 'BEGIN { FS = "%=%=%=%" } ; /#!/ { print $2 }' -- \
    "/tmp/${list_crunchbangs##*/}" \
    | awk 'BEGIN { FS = " -" } ; { print $1 }' \
    | sed 's, *,,g' \
    | sort -u \
    | cut -b3- \
    || I_ "P:${PIPESTATUS[*]}"
  )
:
:_; D_ a_interpreters; 
#L_
:
: 'Ways to find an interpreter if it-s available on disk:'
:
# Bug: `realpath -e` and `command -v` are redundant
:
for program in "${a_interpreters[@]}"; do
  : 'command -pv'
  command_o="$(command -pv "${program}" 2>&1)"
  
  if [[ -n "${command_o}" ]]; then 
    realpath_o="$(realpath -e "${command_o}" 2> /dev/null)"
    
    if [[ -f "${realpath_o}" ]]; then 
      a_interps_rps+=("${realpath_o}")
      m="exists on disk"; 
      break
    fi
  fi
done  

#   Note: new indices starting from 0
mapfile -t a_interps_rps < <(
  S_ realpath -e -- "${a_interpreters[@]}" \
    | sort -u
  )
:
D_ a_interps_rps; L_
{
for b in "${!a_interps_rps[@]}"; do 
  printf '%-32s' "${a_interps_rps[b]}"; 
  :
  if command -pv "${a_interps_rps[b]}" > /dev/null; then 
    m="exists on disk"; 
  else 
    m="DNE on disk"; 
  fi; 
  :
  a_interps_disk_repo+=([b]="${b} : ${a_interps_rps[b]} : ${m}")
  printf '%-8s' "${m}"; 
  :
  dnf_po="$( S_ dnf provides -- "${a_interps_rps[b]}" \
    | awk '/x86_64|i686/ { print $1 }' \
    | sort -u 
    )"; 
    :
  if [[ -n "$dnf_po" ]]; then 
    m="exists in repos"; 
  else 
    m="DNE in repos"; 
  fi;
  :
  a_interps_disk_repo+=([b+100]="${b} : ${a_interps_rps[b]} : ${m}")
  printf '\t\t\t\t%s\n' "${m}"; 
  printf '%s\n' "$dnf_po"; 
  unset dnf_po; 
  :
done
} | S_ T_ -a -- "${curr_time_ssubd}a_interpreters" > /dev/null
:
#X_; :_; 
W_ a_write_path_nms a_interpreters a_interps_rps a_interps_disk_repo
L_
:

:
# SECTION E
:
: 'CENTRAL TASK, 1 OF 2: Filter the list of crashbangs with the list'
: 'of shells.'
:
: 'file header'
{
  printf '# SC-scrpts-list -- %s\n' "${timecode%-*}"
  printf '# %s\n' "$(D_ a_relevant_search_dirs)"
} | S_ T_ -- "${list_crunchbangs}_SC-scrpts-list" > /dev/null
:
# pulls from time_dir
S_ grep -E -- '/bin/'"${shells}"'.*%=%=%=%' "${list_crunchbangs}" \
  | S_ tee -a -- "${list_crunchbangs}_SC-scrpts-list" \
  || I_
:
B_ "${list_crunchbangs}_SC-scrpts-list" /tmp/*_SC-scrpts-list
:
S_ rsync -ca -- "${list_crunchbangs}_SC-scrpts-list" /tmp \
  || I_
:
B_ "${list_crunchbangs}_SC-scrpts-list" /tmp/*_SC-scrpts-list
:
X_; :_; W_ timecode list_crunchbangs shells 
L_
:

:
: 'CENTRAL TASK, 2 of 2: with ShellCheck scan each script for errors'
:
# TODO: keep "$all_files_index" tracked with content all the way through
#   into the "_found_scripts" file
# Bug? line 1 of script could contain percent symbols
:
: 'A hell world of pipelines'
#   Q: how to translate the correct newlines into nulls to separate the 
#   filenames when reading from a file?  awk? files _can_ contain \n-s
:
grep_o="$(S_ grep ^'#!' -- "${list_crunchbangs}_SC-scrpts-list")"
:
cut_o="$(cut -d '%' -f5- <<< "${grep_o}")"
:
mapfile -t a_each_abspath_scriptnm <<< "${cut_o}"
:
a_each_abspath_scriptnm=("${a_each_abspath_scriptnm[@]##* }")
:
# Wk: awk , multi-char delim, remv lead+trail wspc - redef $0 ?, printf
#   grep -Eo | tr
# Bug: rename variable "$c" below
# Bug: why sort by line count? More text, more bugs? How to prior mult
#   factors?
:
wc_o="$(S_ wc -l -- "${a_each_abspath_scriptnm[@]}")"
:
wc_o="${wc_o%$'\n*'}" # Remove 'totals' line.
:
sort_o="$(sort -gr <<< "${wc_o}")"
:
awk_o="$(awk '{ print $2 }' <<< "${sort_o}")"
:
mapfile -t a_each_script_list_sorted_by_linect <<< "${awk_o}" # ie properly
:
found_scrpts_f="${list_crunchbangs}_found_scripts_${severity:0:1}_${abbrev_rel_search_dirs}"
iterator_2=0
:
# Bug? 1st grep extra?
:
{
  :
  for sorted_script in "${!a_each_script_list_sorted_by_linect[@]}"; do
    :
    mapfile -d '' -t a_each_script_SC_results < <(
      shellcheck -S "${severity}" \
        "${a_each_script_list_sorted_by_linect[sorted_script]}" \
        | grep -Fv 'shellcheck.net' \
        | grep -Eo "SC[0-9]{4}.*" \
        | cut -b -64 \
        | sort -g \
        | uniq -c \
        | sort -k3 \
        || I_ "P:${PIPESTATUS[*]} I: S:" # index and script name
              # end of pipe intended 
      printf '\0'
    )
    :
    if [[ -n "${a_each_script_SC_results[*]:0:1}" ]]; then
      printf '\n%-4d%s\n' $((iterator_2++)) \
        "${a_each_script_list_sorted_by_linect[sorted_script]}"
      printf '%s' "${a_each_script_SC_results[@]}"
    fi
  done
} | S_ tee -a -- "${found_scrpts_f}" > /dev/null
:
: 'Write semi-permanent archives'
:
B_ "${found_scrpts_f}"
S_ rsync -ca -- "${found_scrpts_f}" "${main_d}" \
  || I_
S_ rsync -ca -- "${found_scrpts_f}" /tmp \
  || I_
  :
B_ "${main_d}/${found_scrpts_f##*/}"
:
B_ "/tmp/${found_scrpts_f##*/}"
:
: 'Print some usable variables'
z=0
for d in "${curr_time_ssubd}" "${main_d}" /tmp; do 
  printf '\n\t data_d_%d=%s\n' $((z++)) "${d}"
done
:
trap - EXIT
exit 00

