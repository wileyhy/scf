#!/bin/bash -x
# find-and-scan-shell-scripts-sh
# Written in bash version 5.1 on Fedora 37


###  SECTION A  ###

:;: 'Implementation-dependent arguments for opts parsable by -shellcheck-'
severity='error'
shells='(sh|bash|dash|ksh)'

:;: 'Environment variables'
PATH="$( /usr/bin/command -p getconf PATH ):/usr/bin:/usr/sbin:${PATH}"
LC_ALL=C.UTF-8
LC_COLLATE=C

:;: 'Use -sudo-'

  : '<>'
  date

if ! sudo -v; then
  printf '\n\tValidation failed of user-s -sudo- timestamp; ' 
  printf 'exiting.\n\n' 
  exit "$LINENO"
fi

:;: 'Process lock'
random="$RANDOM"
lock_d="${XDG_RUNTIME_DIR:-"${HOME:-/tmp}"}/.${$}.${random}.lock"
trap '
  if [[ -d "$lock_d" ]] && 
    [[ ! -L "$lock_d" ]]; 
  then 
    rm -rf -- "$lock_d"; 
  fi;
  
  # Good code, for final versions
  #if [[ -v execd_setfacl ]]; then 
    #if [[ -v b ]]; then 
      #sudo setfacl -R -x u:"$UID" "$b" ||
        #echo Error: setfacl failed, line $LINENO
    #elif [[ -v mountpoint ]]; then
      #sudo setfacl -R -x u:"$UID" "$mountpoint" ||
        #echo Error: setfacl failed, line $LINENO
    #fi
  #fi

  trap - EXIT TERM INT; 
  kill -s INT "$$"
  ' EXIT TERM INT # for cleaner xtrace output, put on one line 
if ! mkdir "$lock_d" 2> /dev/null; then
  {
    printf '\n\tCannot acquire process lock: <%s>.\n' "$lock_d"
    printf '\tID: %s\n' "$( whoami )"
    printf 'Exiting.\n\n' 
  } 1>&2
  exit "$LINENO"
fi

# BUG: this regex is totally slow.

:;: 'User variables'
fstype_regexp_2='(btrfs|exfat|ext3|ext4|fat32|ntfs|xfs)'

time_date="$( builtin printf '%(%F_%H%M%S)T' )"
export \
  all_files \
  all_files_sorted \
  all_other_files \
  endian_wtf \
  files_from_outside_rpm \
  crunches_with_hashbang_comments \
  non_rpm_system_crunches \
  non_rpm_user_crunches \
  shell_scripts # arrays
export \
  count \
  data_d \
  data_f \
  d_1 \
  file \
  first_two_chars \
  fstype_regexp \
  i_{0..9} \
  LC_ALL \
  line_1 \
  mountpoint \
  n_{0..9} \
  od_o{0,1} \
  PATH \
  previous_time_dirs \
  read_var \
  relevant_search_dirs \
  severity \
  shells \
  time_date \
  time_d

:;: 'Functions'
_age_file(){
  : '_age_file'
  [[ -f "$1" ]] ||
    return 1
  local previous_aged_files new_hash paf new_hash
  local -A paf_hashes
  previous_aged_files=( "${1}"*[0-9] )

  for paf in "${previous_aged_files[@]}"; do 
    if [[ -f "$paf" ]]; then
      paf_hashes["$( md5sum "$paf" | cut -d ' ' -f1 )"]="$paf" 
      new_hash="$( md5sum "$1"  | cut -d ' ' -f1 )"
      [[ -n "${paf_hashes["$new_hash"]}" ]] && 
        : 'END OF _age_file';:
        return 0
    fi
  done

  local old_mtime
  old_mtime="$( stat -c%Y "$1" )"
  mv "${1}" "${1}.${old_mtime}" ||
    _erx _age_file "$1";
  : 'END OF _age_file';:
}
_bak(){ 
  : '_bak'
  [[ "$#" -eq 0 ]] &&
    return 1
  local i_4
  for i_4 in "$@"; do 
    if [[ ! -f "${i_4}" ]]; then 
      : "_bak: target file <${i_4}>> DNE"
      continue
    else 
      : '_bak: target file exists'
    fi
    tee --output-error='exit' "${i_4}.bak" < "$i_4" > /dev/null 2>&1
  done
  : 'END OF _bak';:
}
_create_data_f(){
  : '_create_data_f'
  :;: '_create_data_f: Open a timestamped file & append into it the list' 
  :   ' of filenames and their crashbangs.' 

  :;: '_create_data_f: data_files'
  data=( "${data_f:=crunchbangs}" /tmp/"${data_f##*/}" )
  
  :;: '_create_data_f: if any data files already exist, keep them'
  for i_6 in "${data[@]}"; do
    if [[ -f "$i_6" ]] && [[ ! -L "$i_6" ]]; then
      mv "$i_6" "${i_6}.${$}.${random}" ||
        _erx "$LINENO"
    fi
  done

  :;: '_create_data_f: create the original data_f'
  touch "${data[@]}"

  :;: '_create_data_f: header'
  printf '# crunchbangs -- %s \n' "$time_date" | 
    tee --output-error='exit' "${data[@]}" > /dev/null 2>&1
  
  :;: '_create_data_f: printing contents of shell_scripts array'
  set -
  printf '%s\n' "${shell_scripts[@]}" |
    tee --append --output-error='exit' "${data[@]}" > /dev/null 2>&1
  set -x
  :; _bak "${data[@]}"
  : 'END OF _create_data_f';:
}
_erx(){ 
  : '_erx'
  local ec="$?"
  echo -e Error: "$@" 
  : 'END OF _erx';:
  exit "$ec"
}
_num(){ 
  : '_num'
  local i_7
  for i_7 in "$@"; do
    local -n array="$i_7" 
    echo "${#array[@]}"
  done
  : 'END OF _num';:
}
_scan_local_disks(){
  : '_scan_local_disks'
  :;: '_scan_local_disks: Sort out the scripts, ie, any file beginning' 
  :   'with a crashbang from the rest of the files'
  #   Note: this function can take 30-90 minutes!
  for i_1 in "${!all_files_sorted[@]}"; do

    :;: '_scan_local_disks: LOOP';:
    printf '%d of %d files\r' "$i_1" "$count"
    unset file read_var od_o{0,1} line_1 
    file="${all_files_sorted[${i_1}]}"
    
    # BUG: the arrays and vars are messy; clean up the lists.

    :;: '_scan_local_disks: file must exist'
    if [[ ! -e "$file" ]]; then
      set -x
      file_DNE+=( "$file" )
      unset 'all_files_sorted[$i_1]'
      continue
      set -
    fi

    # TODO: check for empty files, make a list of them

    :;: '_scan_local_disks: run -file- (and -stat-?) on each file'
    { 
      printf '+ %-8d: ' "$i_1"; 
      sudo file -pk "$file";
    } | 
      tee -a "${time_d}/file_out"
    
    :;: '_scan_local_disks: Read from disk in binary the first two bytes' 
    :   'of each file in the list and output it in hexadecimal.'
    #   Note: inordinately long interpreter paths are rare, but do occur.
    #   Note: `od` command is POSIX compliant
    read -r read_var od_o0 od_o1 read_var < <( 
      sudo od -j 0 -N 2 -t x1z -v "$file" || 
        _erx "$LINENO" "$i_1" "$file" )
    unset read_var
    
    :;: '_scan_local_disks: If -od_o- contains some non-zero data, as it'
    :   ' should,'
    if [[ -z "$od_o0" ]]; then
      _erx "L:$LINENO I:$i_1 <${file}>" '*theoretically unreachable code*';

    :;: '_scan_local_disks: compare the hexidecimal representations to' 
    :   'find any crashbangs.'
    elif [[ "${od_o0}${od_o1}" == @(2321|2123) ]]; then

      :;: '_scan_local_disks: Issue: a big endian file format, possibly'
      :   ' a DB file, etc.'
      if [[ "${od_o0}${od_o1}" == '2123' ]]; then
        endian_wtf+=( [$i_1]="$file" )
        unset 'all_files_sorted[$i_1]'

      # BUG: expect non-printable characters

      :;: '_scan_local_disks: Crunchbang found. Use -read-, and hope'
      :   'there won`t be any non-printable characters.'
      else
        IFS= read -r line_1 < "$file" ||
          _erx "$LINENO" "$i_1" "$file";

        :;: '_scan_local_disks: Issue: the files with -#!comment- as the'
        :   'initial bytes. These aren-t scripts, so restart the loop.'
        if [[ "$line_1" =~ ^'#!comment' ]]; then
          crunches_with_hashbang_comments+=( [${i_1}]="$file" )
          unset 'all_files_sorted[$i_1]'
          continue
        fi

        :;: '_scan_local_disks: Issue: crashbang files which originate'
        :   'outside of the rpm package manager'
        #   Note: with only /bin/sbin, this if-fi block doesn't execute
        if ! rpm -qf "$file" 2> /dev/null 1>&2; then

          :;: '_scan_local_disks: user and system files from outside -rpm-'
          if [[ "$file" = /@(root|home|run/media)/* ]]; then
            non_rpm_user_crunches+=( [${i_1}]="$file" )
            unset 'all_files_sorted[$i_1]'
            continue

          else
            non_rpm_system_crunches+=( [${i_1}]="$file" )
            unset 'all_files_sorted[$i_1]'
            continue
          fi
        fi
      fi
      
      :;: '_scan_local_disks: Make a record in RAM of the relevant'
      :   'filenames and their crashbangs.'
      shell_scripts+=( [$i_1]="$( \
        printf '%-50s   %% %% %% %%   %s\n' "$line_1" "$file" )" )
      unset 'all_files_sorted[$i_1]'

    else
      all_other_files+=( [$i_1]="$file" )
      unset 'all_files_sorted[$i_1]'
    fi
  done
  :; _bak "${time_d}"/{file,stat}_out
  : 'END OF _scan_local_disks';:
}
_usage(){
  : '_usage'
  # Usage:  _usage [exit-code]
  cat <<-\EOF
    SCF - Shell Check Find, version 1.0 (redhat-linux)
    Find and scan shell scripts depending on severity level. 
        Usage:  ./find-and-scan-shell-scripts-sh [-ehiw]
                -e error          -i info
                -h help           -w warning
    Only the first option is processed.
EOF
  exit "${1}"
  : 'END OF _usage';:
}
_write_arrays(){
  : '_write_arrays'
  # Usage: _write_arrays [one target-dir] [arrays]
  :;: '_write_arrays: Default directory is -time_d-.'
  local d_1 i_8 target_f
  : '_write_arrays: is function-pos-parm number 1 a directory?'
  if [[ -d "$1" ]]; then
    d_1="$1"
    shift
  fi

  :;: '_write_arrays: Write each array to disk.'
  #   Note: `tee` without '-a' will overwrite an existing file
  for i_8 in "$@"; do 
    local target_f
          target_f="${d_1:-"${time_d}"}/a_${i_8}"
    declare -p "$i_8" | 
      tee --output-error='exit' "$target_f" > /dev/null 2>&1
    :; _bak "$target_f"
    unset target_f
  done
  : 'END OF _write_arrays';:
}
# Usage: _write_vars [section] [raw variable names]
_write_vars(){
  : '_write_vars'
  local section target_f
        section="$1"
        target_f="${time_d}/${section}_vars"
  shift
  declare -p "$@" 2> /dev/null |
    tee --output-error='exit' "$target_f" > /dev/null 2>&1
  :; _bak "$target_f"
  : 'END OF _write_vars';:
}
export -f \
  _age_file \
  _bak \
  _create_data_f \
  _erx \
  _num \
  _scan_local_disks \
  _usage \
  _write_arrays \
  _write_vars


:;: 'Option parsing'
if [[ "$#" -gt 0 ]]; then
  first_two_chars="${1:0:2}"

  case "${first_two_chars}" in
    --) printf '\n\tHappy Easter!\n\n'
          exit "$LINENO";;
    -e) severity='error';;
    -i) severity='info';;
    -w) severity='warning';;
    -h) :; _usage 0;;
    *)  :; _usage 1;;
  esac
fi


:;: 'Assign varnames and paths for the data directories'

# BUG? `findmnt` has a '--df' option

#   Note: In case of large log files, programatically select a save di-
# rectory, attached to the local disk, where any output can be saved; 
# prefer USB flash drives. This particular `df` command will output three 
# alphanumeric strings separated by whitespace on a single line. `sort` the 
# output by descending size. With `awk`, take the device with the most 
# available space and get its mountpoint with `findmnt`. If there is no 
# output, then set 'mountpoint' according to environment variables. 
mapfile -t df_o < <( 
  sudo df --sync --local --output='fstype,avail,source' --block-size=1 | grep --extended-regexp --invert-match '^Type[[:space:]]*Avail' | grep --extended-regexp -e ^"$fstype_regexp_2" -e 'live-rw'$ | sort --general-numeric-sort --reverse --key=2 )
export df_o

read -r fstype read_var device < <( 
  printf '%s\n' "${df_o[@]}" | head -n 1 )
unset read_var

mountpoint="$( 
  findmnt --canonicalize --output=target --noheadings "$device" )"

# BUG: needs a test for whether or not there are any unmounted USB drives. 
# automatically using '/' as mountpoint is, in this case, ie, on a live usb,
# not so good of an idea.

[[ -z "${mountpoint}" ]] &&
  mountpoint="${lock_d:-"${TMPDIR:-/tmp}"}"
scripts_d="${mountpoint}/scf.d"
data_d="${scripts_d}/latest_data"
meta_d="${scripts_d}/current_meta"
time_d="${data_d}/t_${time_date}"
data_f="${time_d}/crunchbangs"
umask 077

:;: 'reduce use of -sudo- in this script by setting up ACL-s'
case "$fstype" in
  'xfs')      true;;
  ext[2-4])   tune2fs -l "$device" | 
                grep -i 'acl'
              _erx "$LINENO" TODO;;
  *)          _erx "$LINENO" TODO;;
esac
  
:;: 'on XFS'

# Nearly all of the `sudo` commands below are allowing rw access, of  
# this script's data_d, so simply using ACL's will reduce the overuse 
# of `sudo`. This section takes the "$mountpoint" variable, portions
# each subdirectory name into an array index, and tests each subdi-
# rectory from the FS root up for readability by the user running
# this script (ie, a regular user). As the absolute path is recon-
# structed, when a non-readable directory is found, a recursive "r-x" 
# ACL is written, and then a recursive "rwx" is written for the 
# "$scripts_d". 
if [[ ! -r "$scripts_d" ]]; then
  mapfile -d '/' -t a <<< "${mountpoint}"; 
  export a
  a[0]='/'
  a[-1]="${a[-1]//$'\n'}"
  d=${#a[@]}; 
  for ((i=0;i<d;i++)); do 
    b+="/${a[$i]}"; 
    b="$( realpath -e "$b" )"; 
    if [[ ! -r "$b" ]]; then 
      execd_setfacl='y'
      export execd_setfacl
      sudo setfacl -R -m "$USER":r-x "$b" || 
        break
      sudo mkdir --parents "$scripts_d" ||
        _erx "$LINENO"
      sudo setfacl -R -m "$USER":rwx "$scripts_d" || 
        { 
          : 'setfacl failed'
          break 
        }
      : 'setfacl succeeded'
      break
    fi ; 
  done; 
fi

:;: 'make sure -conf_d- is a directory OR create the -conf_d- dir '
: 'if necessary'
for conf_d in "$data_d" "$meta_d"; do
  [[ -d "$conf_d" ]] ||
    mkdir "$conf_d" 
done

:;: 'Label the current data as -latest.-'
#   Note: `find` sees dirs and symlinks as separate things 
mapfile -d '' -t previous_time_dirs < <( 
  find "${data_d}" -mindepth 1 -maxdepth 1 -type d -a \! -type l \
    -name 't_*' -print0 )
export previous_time_dirs

:;: 'if -t_dir- is empty, then delete it; otherwise -mv- it out'
:   ' of the -latest- dir'
for t_dir in "${previous_time_dirs[@]}"; do 
  if rmdir --ignore-fail-on-non-empty "$t_dir"; then
    : '-rmdir- succeeded'
  else
    : '-rmdir- failed'
  fi
  
    : '<>'
    test ! -e "$t_dir" &&
      : 't_dir DNE' 

  : 'of previous time_d' 
  #   Note: with `test`, dirs and symlinks can refer to the same inode
  if [[ -e "$t_dir" ]] &&
    [[ ! -L "$t_dir" ]]; 
  then
    mv "${previous_time_dirs[@]}" "$scripts_d"
  else
    continue
  fi
done

: 'of current time_d'
if [[ ! -d "${time_d}" ]]; then
  mkdir "${time_d}" ||
    _erx "${LINENO}"
fi

# BUG:  Reduce Search Time  ==  RST

:;: 'Gather filenames from local attached disk storage'

# If a prior record of the relevant_search_dirs array exists, and 
# if that prior record matches the new record, then it's possible the 
# all_files list would be the same, too. So if the new relevant_\
# search_dirs list is new, then do the full all_files search again.
# But if they're the same, then ...

:;: 'Variables for array -relevant_search_dirs-'
array='relevant_search_dirs'
rst="${meta_d}/a_${array}" 

:;: 'if the relevant_search_dirs record file exists and is not a symlink'
if [[ -f "$rst" ]] &&
  [[ ! -L "$rst" ]];
then

  :;: 'Keep existing data'
  :; _age_file "${rst}".bak
  :; _bak "$rst"

  :;: 'For whether or not to do the full scan of relevant_search_dirs'
    : 'get the hash of the prior array'
    hash_old="$( md5sum "$rst" )"

    :;: 'get the prior count of indices'
    # shellcheck disable=SC1090
    source "$rst"
    array_count_old="$( _num "$array" )"
    unset "$array"
fi

:;: 'then create a new record for array relevant_search_dirs and...'
mapfile -d '' -t "$array" < <(
  sudo find / -mindepth 1 -maxdepth 1 -type d \! -empty \( \! -name proc -a \! -name sys -a \! -iname 'scf*' \) -print0 )
export "${array?}"
:; _write_arrays "$meta_d" "$array"

:;: 'if the pre-processing block ran, then exec this block also'
if [[ -v array_count_old ]]; then 
  : '<>: variable -array_count_old- exists'

  :;: 'these newer files were written just milliseconds ago'
  :; _age_file "${rst}".bak
  :; _bak "$rst"

  :;: 'For whether or not to run -find- for the all_files array'
    : 'get the hash of the new array' 
    hash_new="$( md5sum "$rst" )"

    :;: 'get the new count of indices, and do some comparisons'
    array_count_new="$( _num "$array" )"

    if [[ "${hash_old%% *}" != "${hash_new%% *}" ]] ||
      [[ "$array_count_old" != "$array_count_new" ]]; 
    then 
      must_find_all_files='y'
    fi
fi
  
:;: 'Variables for array -all_files-'
unset array rst hash_old hash_new array_count_old array_count_new
array='all_files'
rst="${meta_d}/a_${array}" 

:;: 'if the record for the array all_files exists and isnt a symlnk'
if [[ -f "$rst" ]] &&
  [[ ! -L "$rst" ]];
then

  :;: 'Keep existing data'
  :; _age_file "${rst}".bak
  :; _bak "$rst"

  :;: 'For whether or not to do the full scan of relevant_search_dirs'
    : 'get the hash of the prior array'
    hash_old="$( md5sum "$rst" )"

    :;: 'get the prior count of indices'
    : 'set -; source -rst-'; 
    set -
    source "$rst"
    set -x
    array_count_old="$( _num "$array" )"
    unset "$array"

  :;: 'For whether or not to run -find- for the all_files array'
  if [[ "$must_find_all_files" != 'y' ]]; then

    :;: 'get byte count of record file'
    byte_count="$( wc -c "$rst" )"
    [[ "${byte_count%% *}" -lt 500 ]] && 
      must_find_all_files='y'

    :;: 'get delta of mtime to now'
    mtime_age_in_hours=$(( $(( $( date +%s ) - \
      $( stat -c%Y "$rst" ) )) / 60 / 60 ))
    [[ "$mtime_age_in_hours" -gt 72 ]] &&
      must_find_all_files='y'
  fi
fi

:;: 'If we must run -find- for array all_files.'
if [[ ! -v all_files ]] ||
  [[ "$must_find_all_files" = 'y' ]]; 
then
  
    : '<>'
    date
    #relevant_search_dirs=( /usr/sbin )
    relevant_search_dirs=( /usr/sbin /usr/bin )
    #relevant_search_dirs=( /usr/sbin /usr/bin /etc )
    #relevant_search_dirs=( /usr/sbin /usr/bin /etc /var )
  
  :;: 'Find all relevant files on disk.'
  mapfile -d '' -t "$array" < <( 
    sudo find "${relevant_search_dirs[@]}" -mindepth 1 -type f -print0 \
      2> /dev/null )
  export "${array?}"
  :; _write_arrays "$meta_d" "$array"
  
  :;: 'these newer files were written just milliseconds ago'
  :; _age_file "${rst}".bak
  :; _bak "$rst"
fi

:;: 'For whether or not to do the full scan for all_files'
if [[ -v hash_old ]]; then
  : '<>: variable -hash_old- exists'

  :;: 'get the hash of the new array'
  hash_new="$( md5sum "$rst" )"

  :;: 'get the prior count of indices; this array was re-assigned'
  : 'a few milliseconds ago'
  array_count_new="$( _num "$array" )"

  :;: 'Do the comparisons' 
  if [[ "${hash_old%% *}" != "${hash_new%% *}" ]] ||
    [[ "$array_count_old" != "$array_count_new" ]]; 
  then 
    
    # BUG: as of yet unused variable
    
    must_scan_relevant_dirs='y'
  fi
fi

:;: 'Sort the original array and test it.'
  : '<>'
  set -; 

printf 'printf -all_files_sorted- array\n'
mapfile -d '' -t all_files_sorted < <(
  printf '%s\0' "${all_files[@]}" |
    sort --zero-terminated )

  : '<>'
  set -x; 
  : 'set -x'

:;: 'Do the second comparison.' 
[[ "$( _num all_files )" -eq "$( _num all_files_sorted )" ]] ||
  _erx "${LINENO}"

  # <> 
  :; _write_arrays all_files_sorted all_files 
  :; _write_vars 'A' PATH LC_ALL severity shells fstype_regexp time_date \
    first_two_chars mountpoint data_d time_d data_f \
    previous_time_dirs relevant_search_dirs n_0 n_7

  #: '<>'
  #exit "$LINENO"
  #set -x


###  SECTION B  ::  SCANNING  ###

:;: 'Add some brevity, and write the completed arrays to disk'
count="${#all_files_sorted[@]}"
unset IFS

:;: 'if the full list exists (of files on disk which begin with crash-'
:   ' bangs), then skip the 30-90 minute search phase.'
if [[ ! -f /tmp/"${data_f##*/}" ]] || 
  [[ -L /tmp/"${data_f##*/}" ]]; 
then
  :; _scan_local_disks
  :; _create_data_f
fi

  # <>
  :; _write_arrays shell_scripts crunches_with_hashbang_comments \
    files_from_outside_rpm all_other_files endian_wtf \
    non_rpm_system_crunches non_rpm_user_crunches 
  :; _write_vars 'B' file data_f i_1 od_o{0,1} X line_1 count

  : '<>'
  exit "$LINENO"
  #set -x

    
###  SECTION C  ###    

# Make the data readable and useable.

:;: 'CENTRAL TASK, 1 OF 2: Filter the list of crashbangs with the list' 
:   '  of shells.'
grep --extended-regexp '/bin/'"${shells}"'.*% % % %' \
  "${data_f}" > "${data_f}_SC-scrpts-list" ||
    _erx "$LINENO"
:; _bak "${data_f}_SC-scrpts-list"
rsync -ca "${data_f}_SC-scrpts-list" /tmp ||
  _erx "$LINENO"

  : '<>'
  ls -l "${data_f}"*
  wc "${data_f}"*
  exit "$LINENO"
  #set -x

:;: 'MAIN TASK, 2 of 2: with ShellCheck scan each script for errors'
  
:;: 'A hell world of pipelines:'
mapfile -d '' -t cut_sed_o < <( 
  cut -d '%' -f5- "${data_f}_SC-scrpts-list" | 
    sed 's,^ *,,' | 
    tr '\n' '\0' )

  : '<>'
  exit "$LINENO"
  set -x

mapfile -t wc_sort_o < <( 
  for c in "${cut_sed_o[@]}"; do 
    wc -l "$c"; 
  done | 
    sort -gr | 
    awk '{ print $2 }' )

  : '<>'
  exit "$LINENO"
  set -x

i=0; 
{
  for s in "${!wc_sort_o[@]}"; do 
    unset output; 
    mapfile -t output < <( 
      shellcheck -S error "${wc_sort_o[$s]}" | 
        grep --fixed-strings --invert-match 'shellcheck.net' | 
        grep --extended-regexp -o "SC[0-9a-zA-Z\ \t():,.'-$&#\!]*" | 
        cut -b -64 | 
        sort --general-numeric-sort | 
        uniq --count ); 
    if [[ -n "${output[*]:0:1}" ]]; then 
      printf '\n%-4d%s\n' $((i++)) "${wc_sort_o[$s]}"; 
      printf '%s' "${output[@]}"; 
    fi; 
  done;
} | tee -a "${data_f}_found_scripts_with_indices"

  : '<>'
  exit "$LINENO"
  set -x

:; _bak "${data_f}_found_scripts_with_indices"
rsync -ca "${data_f}_found_scripts_with_indices" "$scripts_d" ||
  _erx "$LINENO"
rsync -ca "${data_f}_found_scripts_with_indices" /tmp ||
  _erx "$LINENO"

exit "$LINENO"


# scan 'all_other_files' for anything that isn't an ELF file
# . /run/media/*/*/scf.d/latest_data/t_*/a_all_other_files
# for f in "${all_other_files[@]}"; do sudo file -pk "$f" | grep -v 'ELF 64-bit LSB '; done

# scan 'all_files_sorted' for proper sorting
# . /run/media/*/*/scf.d/latest_data/t_*/a_all_files_sorted
# _num all_files_sorted
# sudo command -p printf '' | sudo tee ./all_files_sorted_printed; for g in "${all_files_sorted[@]}"; do sudo -p command printf '%s\n' "$g" | sudo tee -a ./all_files_sorted_printed ; done

# check 'file_out' for anything odd
# grep -v 'ELF 64-bit' ./scf.d/latest_data/t_2023-04-03_084130/file_out | grep 'read permission'
# grep -v 'ELF 64-bit' ./scf.d/latest_data/t_2023-04-03_084130/file_out | grep -v 'read permission' | grep -v 'script text exec'

# 
