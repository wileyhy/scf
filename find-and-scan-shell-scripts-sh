#!/bin/bash -x
# Written in bash version 5.1 on Fedora 37 & 38

# Note: Keep your goal in mind.

# SECTION A

: 'Regular users only'

if [[ "${UID}" == 0 ]]; then
  printf '\n\t Must be a regular user and use sudo. \n\n'
  exit 1
else
  sudo -v \
    || exit 1
fi

: 'Environment variables'

unset LC_ALL
FUNCNEST=8
GREP_COLORS='mt=01;43'
export GREP_COLORS
LC_COLLATE="C.UTF-8"     # for predictable sorting
LC_CTYPE="C.UTF-8"       #  "   "           "
LC_NUMERIC="en_US.UTF-8" # for commas in large numbers
getconf_o="$(/usr/bin/command -p getconf PATH)"
PATH="${getconf_o}:/usr/bin:/usr/sbin:${PATH}" \
  || "${Halt_PATH:?}" # Causes an immediate halt of caller
PS4='+${BASH_SOURCE[0]}:${LINENO}:${FUNCNAME[0]}: '
export FUNCNEST GREP_COLORS LC_COLLATE LC_CTYPE LC_NUMERIC PATH PS4

# define filenames for the lock directory and temp files
repo_nm=scf
random_n="${RANDOM}"
unique_string="${repo_nm}.${$}.${random_n}"
proc_lk_f_nm="${unique_string}.lock"
mktemp_sfx=".${unique_string}.txt"
a_poss_proces_lock_dirs=([0]="${XDG_RUNTIME_DIR}" [1]="${HOME}"
  [2]="${TMPDIR:-/tmp}" [3]=/tmp [4]=/var/tmp)

: '<> Aliases'

shopt -s expand_aliases
alias :_=':;: "<>"'
alias D_='declare -p '
alias L_='exit "${LINENO}"'
alias M_='sudo namei -xl '
alias R_='rm --one-file-system --preserve-root=all '
alias S_='sudo '
alias T_='tee --output-error=exit '
alias X_='set -x'
alias awk='gawk --lint '


: 'Traps'

# shellcheck disable=SC2154
trap '
  trap - DEBUG

  # Delete all possible existing process _lock_directories_. 
  for poss_lk_d in "${a_poss_proces_lock_dirs[@]}"; do 

    # Abbreviate variable
    pl="${poss_lk_d}/${proc_lk_f_nm}"

    [[ "${pl}" =~ "$$"*.lock ]] \
      || continue

    # test and delete lock directories.
    if [[ -d "${pl}" ]] && [[ ! -L "${pl}" ]]; then 
      echo S_ R_ -rf -- "${pl}" \
        || L_
    fi
  done

    # <>
    #: "${Halt_trap:?}"

  # Remove any script-s ACL-s based on canary variables
  if [[ -v acl_execd_setfacl ]]; then 

    if [[ -v acl_abs_path ]]; then 
      
      # Manual (non-alias/function) error handling reqd wi traps
      S_ setfacl -R -x "u:${UID}" -- "${acl_abs_path}" ||
        echo Error: trap: setfacl failed, line "${LINENO}"

    # bug? Should this var be main_d \/ ? Sb erx ^ ?

    elif [[ -v mountpoint ]]; then
      S_ setfacl -R -x "u:${UID}" -- "${mountpoint}" ||
        echo Error: trap: setfacl failed, line "${LINENO}"
    fi
  fi

  trap - EXIT INT TERM
  kill -s INT "$$"
' EXIT INT TERM

: 'Table of traps' # Learning about how `bash` uses signals  

# trap 'set -x; echo SIGEXIT;   trap SIGEXIT;   kill -s INT $$'  EXIT   # 0
  trap 'set -x; echo SIGHUP;    trap SIGHUP;    kill -s 2   $$'  HUP    # 1
# trap 'set -x; echo SIGINT;    trap 2;         kill -s 2   $$'  2      # INT # ^C 
  trap 'set -x; echo SIGQUIT;   trap SIGQUIT;   kill -s 2   $$'  QUIT   # 3   
  trap 'set -x; echo SIGILL;    trap SIGILL;    kill -s 2   $$'  ILL    # 4   
  trap 'set -x; echo SIGTRAP;   trap SIGTRAP;   kill -s 2   $$'  TRAP   # 5   
  trap 'set -x; echo SIGABRT;   trap SIGABRT;   kill -s 2   $$'  ABRT   # 6   
  trap 'set -x; echo SIGBUS;    trap SIGBUS;    kill -s 2   $$'  BUS    # 7   
  trap 'set -x; echo SIGFPE;    trap SIGFPE;    kill -s 2   $$'  FPE    # 8   
# trap 'set -x; echo SIGKILL;   trap SIGKILL;   kill -s 2   $$'  KILL   # 9   # cannot be caught, per `shellcheck`
  trap 'set -x; echo SIGUSR1;   trap SIGUSR1;   kill -s 2   $$'  USR1   # 10    
  trap 'set -x; echo SIGSEGV;   trap SIGSEGV;   kill -s 2   $$'  SEGV   # 11  
  trap 'set -x; echo SIGUSR2;   trap SIGUSR2;   kill -s 2   $$'  USR2   # 12  
  trap 'set -x; echo SIGPIPE;   trap SIGPIPE;   kill -s 2   $$'  PIPE   # 13  
  trap 'set -x; echo SIGALRM;   trap SIGALRM;   kill -s 2   $$'  ALRM   # 14  
# trap 'set -x; echo SIGTERM;   trap SIGTERM;   kill -s 2   $$'  TERM   # 15  
  trap 'set -x; echo SIGSTKFLT; trap SIGSTKFLT; kill -s 2   $$'  STKFLT # 16  
# trap 'set -x; echo SIGCHLD;   trap SIGCHLD;   kill -s 2   $$'  CHLD   # 17  # triggered by returning command substitution
  trap 'set -x; echo SIGCONT;   trap SIGCONT;   kill -s 2   $$'  CONT   # 18
# trap 'set -x; echo SIGSTOP;   trap SIGSTOP;   kill -s 2   $$'  STOP   # 19  # cannot be caught, per `shellcheck`
  trap 'set -x; echo SIGTSTP;   trap SIGTSTP;   kill -s 2   $$'  TSTP   # 20
  trap 'set -x; echo SIGTTIN;   trap SIGTTIN;   kill -s 2   $$'  TTIN   # 21
  trap 'set -x; echo SIGTTOU;   trap SIGTTOU;   kill -s 2   $$'  TTOU   # 22
  trap 'set -x; echo SIGURG;    trap SIGURG;    kill -s 2   $$'  URG    # 23
  trap 'set -x; echo SIGXCPU;   trap SIGXCPU;   kill -s 2   $$'  XCPU   # 24
  trap 'set -x; echo SIGXFSZ;   trap SIGXFSZ;   kill -s 2   $$'  XFSZ   # 25
  trap 'set -x; echo SIGVTALRM; trap SIGVTALRM; kill -s 2   $$'  VTALRM # 26
  trap 'set -x; echo SIGPROF;   trap SIGPROF;   kill -s 2   $$'  PROF   # 27
  trap 'set -x; echo SIGWINCH;  trap SIGWINCH;  kill -s 2   $$'  WINCH  # 28
  trap 'set -x; echo SIGIO;     trap SIGIO;     kill -s 2   $$'  IO     # 29
  trap 'set -x; echo SIGPWR;    trap SIGPWR;    kill -s 2   $$'  PWR    # 30
  trap 'set -x; echo SIGSYS;    trap SIGSYS;    kill -s 2   $$'  SYS    # 31
  trap 'set -x; echo SIGRTMIN;  trap SIGRTMIN;  kill -s 2   $$'  RTMIN  # 32

: '<> XTrace'
funclvl=0
fence=' ++++++++++++++++++++++++++++++++++++++++++++ '
# If xtrace was previously on, then on first execution of this function,
# turn xrtrace off, and on second execution, turn xtrace back on and
# forget about this function's settings. If xtrace was previously off,
# then leave it off.

_xtrace_duck() {
  : '_xtrace_duck BEGINS' "$((++funclvl))" "${fence}"
  local hyphen="$-"

  # If xtrace is on...
  if [[ "${hyphen}" =~ x ]]; then

    # ...then record its state
    local -g xtrace_prev
    export xtrace_prev

    # and turn xtrace off
    set -

  # but if xtrace is off...
  else
    # ...then if xtrace was previously on...
    if [[ -n "${xtrace_prev}" ]]; then

      # ...then restore xtrace and unset its variable
      set -x
      unset xtrace_prev

    # but if xtrace is off and was previously off...
    fi
  fi
  : '_xtrace_duck ENDS  ' "$((--funclvl))" "${fence}"
}

export setenv_prev setenv_now setenv_delta env_prev env_now env_delta
_mk_setenv_prev() {
  : '_mk_setenv_prev BEGINS' "$((++funclvl))" "${fence}"
  if [[ -n "${setenv_now}" ]]; then

    if [[ -n "${setenv_prev}" ]]; then
      R_ -f -- "${setenv_prev}"
    fi
    setenv_prev="${setenv_now}"
  fi
  : '_mk_setenv_prev ENDS  ' "$((--funclvl))" "${fence}"
}

_mk_setenv_now() {
  : '_mk_setenv_now BEGINS' "$((++funclvl))" "${fence}"
  setenv_now="$(mktemp --suffix="${mktemp_sfx}")"
  set \
    |& tee -- "${setenv_now}" >/dev/null
  env \
    |& tee -a "${setenv_now}" >/dev/null
  : '_mk_setenv_now ENDS  ' "$((--funclvl))" "${fence}"
}

_mk_setenv_delta() {
  : '_mk_setenv_delta BEGINS' "$((++funclvl))" "${fence}"
  if [[ -n "${setenv_now}" ]] && [[ -n "${setenv_prev}" ]]; then

    if [[ -n "${setenv_delta}" ]]; then
      R_ -f -- "${setenv_delta}" 
      # [line 1] rm --one-file-system --preserve-root=all -f -- \
      #   /tmp/tmp.HjN8ow8GHi.scf.32869.15382.txt
      wait -f
    else
      setenv_delta="$(mktemp --suffix="${mktemp_sfx}")" # 
    fi

    {
      diff -y --suppress-{common-lines,blank-empty} --color=never \
        "${setenv_prev}" "${setenv_now}" \
        |& grep -v setenv \
        | grep --color=always -E '.*'
    } \
      |& tee -- "${setenv_delta}" 
      # [line 2] tee -- /tmp/tmp.HjN8ow8GHi.scf.32869.15382.txt

    {
      diff --suppress-{common-lines,blank-empty} --color=always \
        --palette="ad=1;3;38;5;190:de=1;3;38;5;129" \
        "${setenv_prev}" "${setenv_now}" \
        | grep -ve BASH_LINENO -e BASH_COMMAND -e BASH_SOURCE \
        -e setenv_ -Fe '---'
    } \
      |& tee -a "${setenv_delta}"

    GREP_COLORS='mt=01;104'
    export GREP_COLORS
    wc "${setenv_delta}" \
      | grep --color=always -E '.*'
    GREP_COLORS='mt=01;43'
    export GREP_COLORS
  fi
  : '_mk_setenv_delta ENDS  ' "$((--funclvl))" "${fence}"
}

_mk_deltas() {
  : '_mk_deltas BEGINS' "$((++funclvl))" "${fence}"
  _xtrace_duck
  _mk_setenv_prev
  _mk_setenv_now
  _mk_setenv_delta
  _xtrace_duck
  : '_mk_deltas ENDS  ' "$((--funclvl))" "${fence}"
}

# ? what of BASH_LINENO

_debug_prompt() {
  : '_debug_prompt BEGINS' "$((++funclvl))" "${fence}"
  _mk_deltas
  read -rp "[${BASH_SOURCE[0]}:${LINENO}] ${BASH_COMMAND[0]}?" _
  : '_debug_prompt ENDS  ' "$((--funclvl))" "${fence}"
}

_full_xtrace() {
  : '_full_xtrace BEGINS' "$((++funclvl))" "${fence}"
  #set -o functrace
  trap '_debug_prompt "$_";' DEBUG
  set -x
  : '_full_xtrace ENDS  ' "$((--funclvl))" "${fence}"
}

#exit 101
#_full_xtrace

: 'Implementation dependent arguments for options parsable by -shellcheck-'

sc_severity=error
# shellcheck disable=SC2034
SC_shells='(sh|bash|dash|ksh)'

: 'Variables more likely to be manually chaged'

script_dirnm="${repo_nm}.d"
protected_git_dir_1="${HOME}/MYPROJECTS"
protected_git_dir_2="${HOME}/OTHERSPROJECTS"
script_nm=find-and-scan-shell-scripts-sh
script_proper_nm='Script Finder'
script_version=1.0

# <>
abbrev_rel_search_dirs=/

# to search dirs...
: Option parsing
if [[ $# -gt 0 ]]; then
  cli_input=("${@}")
fi

#exit 101
_full_xtrace

# Variables re getopts
bash_path_orig="${PATH}"
bash_path="${bash_path_orig}"

find_exclude_optargs_default=(
  [0]='(' [1]='!' [2]='-name' [3]='proc' [4]='-a' [5]='!'
  [6]='-name' [7]='sys' [8]='-a' [9]='!' [10]='-iname'
  [11]="${script_dirnm}*" [12]='-a' [13]='!' [14]='-ipath'
  [15]="${protected_git_dir_1}" [16]='-a' [17]='!' [18]='-ipath'
  [19]="${protected_git_dir_2}" [20]='-a' [21]='!' [22]='-path'
  [23]='*/git/*' [24]=')'
)
find_exclude_optargs=("${find_exclude_optargs_default[@]}")

IFS=':' read -ra find_path <<<"${bash_path}"
memory_usage=temp_files
sc_sev_abrv="${sc_severity:0:1}"

search_methods_descend=no
search_methods_path=('as-is')
search_methods_prog=bin_bash
search_methods_scan_excluded=no
search_methods_symlinks=with

fn_usage() {
  : 'fn_usage BEGINS' "$((++funclvl))" "${fence}"
  # Usage:  fn_usage [exit-code]
  : fn_usage

  # print a usage message and exit with a pre-determined exit code
  {
    cat <<-EOF
  ${repo_nm} - ${script_proper_nm}, version ${script_version}
    Find and scan shell scripts depending on severity level. 
    Options are parsed by bash's builtin "getopts".
  Usage:
    ./${script_nm} -H[b|p|l] -P[ac|as|bi|bo|ge|sb|pr|sy]
        -R[DIRECTORY] -S[e|i|s|w] -V -X[r|p|t] -h|? -p[ba|cp|cv|fi|ty] 
        -q[c|i|p] -r[d|y|n] -s[s|y|n

      H:  Follow symlinks         M:  Memory usage
       *[b]ash                      [r]   RAM only
        [p]hysical                  [p]   Persistent storage
        [l]ogical                  *[t]   Temporary files
      P:  Path                    h   Help message
        [ac]  Actually all        p:  Progam and method
       *[as]  As-is                *[ba]  "bash" binary
        [bi]  /bin only             [cp]  builtin "command -pV"
        [bo]  Both /{,s}bin only    [cv]  builtin "command -V"
        [ge]  Getconf PATH only     [fi]  "find" binary
        [sb]  /sbin only            [ty]  builtin "type -a"
        [pr]  Add /proc           q:  Validate information
        [sy]  Add /sys              [a]cls
      R:  Path                      [c]rashbangs
        [STRING]  Add search dir    [d]acs
      S:  Severity level            [i]nterpreters
       *[e]rror                     [p]ath
        [i]nfo                    r:  Recurse into dirs
        [s]tyle                     [d|y] Yes   *[n] No
        [w]arning                 s:  Scan excluded dirs
      V   Version                   [s|y] Yes   *[n] No 
EOF
  } | more -e
  : 'END OF fn_usage'

  # shellcheck disable=SC2086
  exit "${1}"
  : 'fn_usage ENDS  ' "$((--funclvl))" "${fence}"
}

exit 101
_full_xtrace

while getopts "AH:M:P:R:S:Vhp:q:r:s:" cli_input; do
  declare -p OPTIND OPTARG

  # Parse command line options
  case "${cli_input}" in
    # Easter egg
    A)
      printf '%s%s%s' 'CgkiSSB3b3VsZCBoYXZlIG1hZGUgdGhpcyBzaG9y' \
        'dGVyLCBidXQgSSBkaWRuJ3QgaGF2ZSB0aGUg' \
        'dGltZS4iCgkJLS0gTWFyayBUd2FpbgoK' \
        | base64 -d
      exit 0
      ;;
    # Follow symlinks
    #   `bash` always follows symlinks, therefore to not follow any
    # symlinks requires `find` and is a clobbering setting, ie,
    # selecting either '-h P' or '-h L' will also select the use of
    # `find`. The 'P' and 'L' refer to `find`s first argument, which
    # by default is assumed (by `find`) to be '-P'. `find -H` is not
    # implemented in this script.
    H)
      # Input validation: make upper case letters lower case, and truncate all but first letter. this code block repeats below.
      OPTARG="${OPTARG,,[A-Z]}"
      OPTARG="${OPTARG:0:1}"

      # Parse option arguments
      case "${OPTARG}" in
        # Bash
        b)
          search_methods_symlinks=bash # default
          search_methods_prog=bin_bash # default
          ;;
        # Physical
        p)
          search_methods_symlinks=physical
          search_methods_prog=bin_find
          # side effect: setting '-H p' also clobbers this variable. side effects such as these are marked below as "clobber."
          find_sym_opt='-P'
          ;;
        # Logical
        l)
          search_methods_symlinks=logical
          search_methods_prog=bin_find # clobber
          find_sym_opt='-L'
          ;;
        # this parameter expansion, ':?', when a parameter is null or unset, causes the shell to immediately halt, ignoring any trap on EXIT.
        *)
          "${arg_wrong__h:?}"
          ;;
      esac
      ;;
    # Whether and how to save data.
    M)
      # Input validation
      OPTARG="${OPTARG,,[A-Z]}"
      OPTARG="${OPTARG:0:1}"

      # Parse option arguments
      case "${OPTARG}" in
        r) memory_usage=RAM_only ;;
        p) memory_usage=persistent_storage ;;
        t) memory_usage=temp_files ;; # default

        # Error handling
        *) "${arg_wrong__X:?}" ;;
      esac
      ;;
    # PATH (array) - Part 1 - Options with no args . ('-P /usr/share' is an option with an argument.)
    #   For scanning '/proc' or '/sys', see also option 's'.
    P)
      # Part 1.A -- clobbering settings
      OPTARG="${OPTARG,,[A-Z]}"
      OPTARG="${OPTARG:0:2}"
      case "${OPTARG}" in

        # Multiple abbreviations accepted
        ac | aa)
          unset find_path search_methods_path
          search_methods_path=(actually_all)
          bash_path='/'

          # For consistency, find_path is always defined after bash_path, regardless of which one is used.
          IFS=':' read -ra find_path <<<"${bash_path}"
          search_methods_prog=bin_find
          ;;
        as | ai)
          unset find_path search_methods_path
          search_methods_path=('as-is')
          bash_path="${bash_path_orig}"
          IFS=':' read -ra find_path <<<"${bash_path}"
          ;;
        bi | b)
          unset find_path search_methods_path
          search_methods_path=(bin_only)
          bash_path='/usr/bin'
          IFS=':' read -ra find_path <<<"${bash_path}"
          ;;
        bo | bs)
          unset find_path search_methods_path
          search_methods_path=(both_bin_sbin_only)
          bash_path='/usr/bin:/usr/sbin'
          IFS=':' read -ra find_path <<<"${bash_path}"
          ;;
        ge | g)
          unset find_path search_methods_path
          search_methods_path=(getconf_PATH_only)
          bash_path="${getconf_o}"
          IFS=':' read -ra find_path <<<"${bash_path}"
          ;;
        sb | so | s)
          unset find_path search_methods_path
          search_methods_path=(sbin_only)
          bash_path='/usr/sbin'
          IFS=':' read -ra find_path <<<"${bash_path}"
          ;;
          # Part 1.B -- additive PATH settings, but the Program
          #   setting gets clobbered
        pr | p | pa)
          unset find_path
          search_methods_path+=(add_proc)
          bash_path+=':/proc'
          IFS=':' read -ra find_path <<<"${bash_path}"
          search_methods_prog=bin_find
          ;;
        sy | sa)
          unset find_path
          search_methods_path+=(add_sys)
          bash_path+=':/sys'
          IFS=':' read -ra find_path <<<"${bash_path}"
          search_methods_prog=bin_find
          ;;
          # Part 1.C - handle erroneous input
        *) "${arg_wrong__P:?}" ;;
      esac
      ;;
    # PATH (array) - Part 2 - options with args
    R)
      # Input validation, more thorough. Remove unprintable strings.
      OPTARG="$(strings -n1 <<<"${OPTARG}")"

      # Bug: sb a printf one liner
      # for i in DECIMALS; do printf '%b' "\\${i}"; done #...

      # List unsafe ASCII characters
      bad_strings=([0]="|" [1]="&" [2]=";" [3]="(" [4]=")" [5]="<"
        [6]=">" [7]=" " [8]=$'\t' [9]=$'\n' [10]="||" [11]="&&"
        [12]=";;" [13]=";&" [14]=";;&" [15]="|&" [16]="!" [17]="{"
        [18]="}" [19]="[" [20]="]" [21]="[[" [22]="]]" [23]="\$"
        [24]="=")

      # Remove unsafe characters
      new_optarg="${OPTARG//["${bad_strings[@]}"]/}"

      # If any ASCII characters were removed, print an error and exit
      if [[ "${new_optarg}" != "${OPTARG}" ]]; then
        printf '\n\tError: option -R: directory name includes '
        printf 'an illegal character\n\n'
      fi

      # Canonicalize path
      new_optarg="$(realpath -e "${new_optarg}")"

      $ Value must be a directory
      if [[ ! -d "${new_optarg}" ]]; then
        "${arg_wrong__R:?}"
      fi
      unset find_path
      new_optarg="${new_optarg//\//_}"
      search_methods_path+=("add_dir__${new_optarg}")

      # Append dirname to PATH
      bash_path+="${new_optarg}"

      # load directories of PATH into an array
      IFS=':' read -ra find_path <<<"${bash_path}"
      ;;
    # ShellCheck's '-S' setting, ie, severity level
    S)
      # Mis-spellings allowed
      OPTARG="${OPTARG,,[A-Z]}"
      OPTARG="${OPTARG:0:1}"
      case "${OPTARG}" in
        e) sc_severity=error ;; # default
        i) sc_severity=info ;;
        s) sc_severity=style ;;
        w) sc_severity=warning ;;
        *) "${arg_wrong__S:?}" ;;
      esac
      ;;

    # Bug: hardcoded info: license
    V)
      printf '\n\t%s, version %s. Apache 2 license.\n\n' \
        "${script_proper_nm}" "${script_version}"
      ;;
    # Help message
    h | \?)
      fn_usage 0
      ;;
    # Program to search with (variable) -- all settings clobber
    p)
      OPTARG="${OPTARG,,[A-Z]}"
      OPTARG="${OPTARG:0:2}"
      case "${OPTARG}" in
        ba | b)
          search_methods_prog=bin_bash # default
          ;;
        cp)
          search_methods_prog=bash_command_pV
          ;;
        cv)
          search_methods_prog=bash_command_V
          ;;
        fi | f)
          search_methods_prog=bin_find
          ;;
        ty | t)
          search_methods_prog=bash_type_a
          ;;
        *)
          "${arg_wrong__p:?}"
          ;;
      esac
      ;;
    # What information to verify -- none are enabled by defaulted
    q)
      # ALSO: verify DACs and ACLs is written below!

      OPTARG="${OPTARG,,[A-Z]}"
      OPTARG="${OPTARG:0:2}"
      case "${OPTARG}" in
        a | ac) verify+=(acls) ;;
        c | cr) verify+=(crashbangs) ;;
        d | da) verify+=(dacs) ;;
        i | in) verify+=(interpreters) ;;
        p | pa) verify+=(path) ;;
        u | un) unset verify ;;
        *) "${arg_wrong__X:?}" ;;
      esac
      ;;
    # Descend into dirs (recurse)
    #   `bash`s path search cannot descend into dirs; for `find` the
    # default is to 'do descend' into dirs. For this script, the default
    # for descending follows `bash`, and selecting this setting switches
    # the search program to `find`. `find`s '-mindepth' and '-maxdepth'
    # are not implemented.
    r)
      OPTARG="${OPTARG,,[A-Z]}"
      OPTARG="${OPTARG:0:1}"
      case "${OPTARG}" in
        # recurse|descend|yes
        r | d | y)
          search_methods_descend=yes
          search_methods_prog=bin_find # clobber
          unset bash_path
          ;;
        # no_descend
        n)
          search_methods_descend=no    # default
          search_methods_prog=bin_bash # clobber
          unset find_path
          ;;
        *)
          "${arg_wrong__r:?}"
          ;;
      esac
      ;;
    # Scan excluded dirs
    #   By default, this script assumes for `find` a set of automatic-
    # ally excluded search directories that often prove to be somewhat
    # problematic: '/proc', '/sys', and anything with a find '-path'
    # of either '*/git/*' or this script's repo's name. With a default 
    # PATH setting, `bash` usually also skips these directories, so 
    # enabling this option indicates the wish to use `find`, and so 
    # clobbers `bash`. To add '/proc' or '/sys' to `find`s search path, 
    # see option 'P', 'add_proc' and 'add_sys'.
    s)
      OPTARG="${OPTARG,,[A-Z]}"
      OPTARG="${OPTARG:0:1}"
      case "${OPTARG}" in
        # scan_excluded|yes
        s | y)
          search_methods_scan_excluded=yes
          search_methods_prog=bin_find
          find_exclude_optargs=()
          ;;
        # no_scan_excluded
        n)
          search_methods_scan_excluded=no # default
          search_methods_prog=bin_find
          find_exclude_optargs=("${find_exclude_optargs_default[@]}")
          ;;
        *)
          "${arg_wrong__s:?}"
          ;;
      esac
      ;;
    *)
      fn_usage 1
      ;;
  esac
done
set -
{

  # <>
} |& grep -v default 2>/dev/null
: 'find_exclude_optargs:' "${find_exclude_optargs[@]}"
exit 101

# Verify PATH
#   (...before running the builtins [type and command], or they'll
# print dups)
if [[ "${verify[*]}" =~ path ]]; then

  # for Verify PATH

  # Get constituent dirs from PATH
  unset path path_2 p
  IFS=':' read -ra path <<<"${PATH}" # this

  # get the cannonicalized paths of each such dir
  for p in "${!path[@]}"; do path[p]="$(realpath -e "${path[p]}" 2>/dev/null)"; done
  unset p # this

  # if the index is empty, then unset it
  for p in "${!path[@]}"; do if [[ -z "${path[p]}" ]]; then unset 'path[p]'; fi; done
  unset p # this

  # remove any duplicates while preserving order of dirs
  for p in "${!path[@]}"; do if [[ "${path_2[*]}" =~ ${path[p]} ]]; then unset 'path[p]'; else path_2+=("${path[p]}"); fi; done
  unset p # this

  # reset indices of path_2 and print results
  path_2=("${path_2[@]}")

  # reset PATH
  PATH="$(
    printf '%s' "${path_2[0]}"
    unset 'path_2[0]'
    printf ':%s' "${path_2[@]}"
  )"
fi
exit 101

# Bug: greps. parse full outputs of type and command

# Process value of search_methods_prog
if [[ "${search_methods_prog}" = @(bash_command_pV|bash_command_V|bash_type_a) ]]; then

  # create a single array of all commands found by each kind of search.
  # to do this...

  # search for commands with odd yet permitted-by-Linux initial
  # characters, such as \n \t \c or \l

  # create a dictionary list of each possible initial character
  unset allchr char i all_commands real_dirs re

  for i in 8 9 10 11 12 13 {32..127}; do allchr+=(["$i"]="$(printf '%b' "\\$(printf %03o "$i")")"); done
  allchr[10]=$'\n'
  unset i

  for i in "${!allchr[@]}"; do mapfile -O $((i * 1000)) -t all_commands < <(compgen -c "${allchr[i]}"); done
  unset i

  mapfile -t real_dirs < <(sudo find / -maxdepth 1 -mindepth 1 -type d \! -empty | sort)

  re="$(
    printf '(%s' "${real_dirs[0]#/}"
    unset 'real_dirs[0]'
    printf '|%s' "${real_dirs[@]#/}"
    printf ')\n'
  )"

  #search_methods_prog=bash_type_a; for i in "${!all_commands[@]}"; do if [[ "${search_methods_prog}" = bash_type_a ]]; then type -a "${all_commands[i]}" ; fi; done

  # Bug: the tests for search_methods_prog need to be at the top level of
  # logic structure

  for i in "${!all_commands[@]}"; do

    # For anywhere in PATH: BASH_type_a
    if [[ "${search_methods_prog}" = *bash_type_a ]]; then
      type -a "${all_commands[i]}" \
        | grep -E 'is /'"${re}"
    fi

    # For `command -pV` (usually only '/usr/bin'): BASH_command_pV
    if [[ "${search_methods_prog}" = *bash_command_pV ]]; then
      command -pV "${all_commands[i]}" \
        | grep -E 'is /'"${re}"
    fi

    # For `command -V` (usually includes '/usr/sbin'): BASH_command_V
    if [[ "${search_methods_prog}" = *bash_command_V ]]; then
      command -V "${all_commands[i]}" \
        | grep -E 'is /'"${re}"
    fi

  done \
    | sudo tee all_commands

elif [[ "${search_methods_prog}" = *bin_bash ]]; then
  command -v bash > /dev/null 2>& \
    || exit "${LINENO}"

elif [[ "${search_methods_prog}" = *bin_find ]]; then
  command -v find > /dev/null 2>& \
    || exit "${LINENO}"

else
  echo error
fi

# <>
[[ -f ./all_commands ]] \
  && ls ./all_commands
exit 101

# delete? re-work?

abbrev_rel_search_dirs=all
#
# To search some specific directories, uncomment them; to search
# all of the common dirs or FULL DISK instead # --really-- --slow--
#
declare -A A_rsd
A_rsd=(
  # useful for testing
  #[usr_bin]='/bin'
  #[usr_lib]='/lib'
  #[usr_lib64]='/lib64'
  [usr_sbin]='/sbin'
  # common search dirs on Fedora, ie, "all"
  #[boot]='/boot'
  #[dev]='/dev'
  #[etc]='/etc'
  #[home]='/home'
  #[root]='/root'
  #[run]='/run'
  #[tmp]='/tmp'
  #[usr]='/usr'
  #[var]='/var'
  # usually empty
  #[afs]='/afs'
  #[lost+found]='/lost+found'
  #[media]='/media'
  #[mnt]='/mnt'
  #[opt]='/opt'
  #[srv]='/srv'
  # usually quite difficult to parse; rarely any shell scripts
  #[proc]='/proc'
  #[sys]='/sys'
)

# for actually_all
umask 117

get_rel_search_dirs() {
  : 'get_rel_search_dirs BEGINS' "$((++funclvl))" "${fence}"
  mapfile -d '' -t "${1}" < <(
    sudo find / -mindepth 1 -maxdepth 1 -type d \! -empty \
      \( \! -name proc -a \! -name sys \
      -a \! -iname "${script_dirnm:- scf.d}" \
      -a \! -iname "${protected_git_dir_1:- ~}" \
      -a \! -iname "${protected_git_dir_2:- tmp}" \
      \) -print0 2>/dev/null
  )
  : 'get_rel_search_dirs ENDS  ' "$((--funclvl))" "${fence}"
}
get_rel_search_dirs a_relevant_search_dirs

# for memory usage persistent storage
# take each found dir and convert abs path [of sym, okay] to a string
# usable for directory names
unset index element calc

# for each dirname /  directory in search path
for index in "${!A_rsd[@]}"; do
  element="${A_rsd["$index"]}"
  calc="$(realpath -e "$element")"
  calc="${calc//\//_}"
  calc="${calc#_}"
  printf 'element: %-12s index: %-12s calc: %s \n' \
    "$element" "$index" "$calc"
  if [[ "$index" != "$calc" ]]; then
    echo wrong
    exit
  fi
done
get_mountpoint() {
  : 'get_mountpoint BEGINS' "$((++funclvl))" "${fence}"
  unset d dir
  d="$(realpath -e "$1")"
  mapfile -t dir < <(
    namei -xl "$d" \
      | tac \
      | grep -A100 ^D \
      | grep -E ^'[Dd]' \
      | awk '{ print $4 }'
  )
  unset j x i
  j="${#dir[@]}"
  for ((i = j; i > 0; i--)); do
    x+="${dir[$i - 1]}"/
  done
  x="$(realpath -e "$x")"
  echo "$x"
  : 'get_mountpoint ENDS  ' "$((--funclvl))" "${fence}"
}
get_mountpoint /sbin

# <>
exit 101

# check DAC's,
namei_o="$(
  for d in "${path_2[@]}"; do
    namei -xl "$(
      realpath -e "$d" 2>/dev/null
    )"
  done \
    | grep -v ^'f:' \
    | awk '$2 !~ /root/ || $3 !~ /root/ { print }'
)"
if [[ -n "${namei_o}" ]]; then
  echo 'A directory in PATH is not fully owned by root (DAC).'
  echo "${namei_o}"
  exit "${LINENO}"
fi

# check ACL's

# Variables, this section
unset end_dirname full_dir_list ext_array dir sub_dir num_sub_dirs N n \
  extglob_pattern ext_first ext_last getfacl_o grep_o
end_dirname=/
declare -A full_dir_list
ext_array=()

# for each actual directory in PATH
for dir in "${path_2[@]}"; do

  # limit the number of loops to the number of constituent directory
  # inodes. safely split each directory into its constituent directory
  # names, ie, by using NULL's in place of '/'s
  unset sub_dir
  num_sub_dirs="$(tr '/' '\0' <<<"$dir" \
    | awk -F'\0' '{ print NF }')"
  N=$((num_sub_dirs - 1))

  # read the ACLs of each dir and sub_dir
  for ((n = N; n >= 0; --n)); do

    # Assign a value to $sub_dir as necessary
    : "${sub_dir:="${dir}"}"

    # If the sub_dir is already listed in the extglob_pattern, then
    # move on to the next small loop
    # shellcheck disable=SC2053
    if [[ "${sub_dir}" = ${extglob_pattern} ]]; then
      sub_dir="$(dirname "${sub_dir:="${dir}"}")"

      # If the sub_dir is '/', then move on to the next big loop
      if [[ "${sub_dir}" = "${end_dirname}" ]]; then
        break
      fi
      continue
    fi

    # Use an Associative array to filter out duplicate entries.
    # (With associative arrays, duplicate assignments are indempotent.)
    full_dir_list["${sub_dir}"]+="${n},"

    # create a list of directories and subdirectories that have been
    # tested so far. This section concatenates directories as strings
    # into a variable that the shell will later interpret as an
    # extglob.
    ext_array=("${!full_dir_list[@]}")
    ext_first="${ext_array[0]}"
    [[ -n "${ext_first}" ]] \
      && unset 'ext_array[0]'
    # shellcheck disable=SC2124
    ext_last="${ext_array[@]: -1:1}"
    [[ -n "${ext_last}" ]] \
      && unset "ext_array[${#ext_array[@]}]"
    # index math can be a little weird

    # create the exglob_pattern
    if [[ -n "${ext_first}" ]]; then
      extglob_pattern="$(printf '@(%s' "${ext_first}")"
      [[ "${#ext_array[@]}" -gt 0 ]] \
        && extglob_pattern+="$(printf '|%s' "${ext_array[@]}")"
      if [[ -n "${ext_last}" ]]; then
        extglob_pattern+="$(printf '|%s)' "${ext_last}")"
      else
        extglob_pattern+="$(printf ')')"
      fi
    fi

    # look for any ACL's on the directory
    getfacl_o="$(getfacl -enp -- "${sub_dir}" 2>/dev/null)"
    grep_o="$(grep -ve '^#' -e ^'user::' -e ^'group::' -e ^'other::' \
      <<<"${getfacl_o}")"

    # If found, halt the script and inform the user
    if [[ -n "${grep_o}" ]]; then
      printf '\n%s: ACL defined for this directory:\n\t%s\n\n' \
        "${script_nm}" "${sub_dir}"
      echo "${getfacl_o}"
      printf '\n\tThis command will remove all ACL\x27s from the '
      printf 'specified directory:\n\n\t\tsetfacl -b %s\n\n' "${sub_dir}"
      exit 1

    # otherwise, move on to the next big loop
    else
      if [[ "${sub_dir}" = "${end_dirname}" ]]; then
        break
      fi
    fi

    sub_dir="$(dirname "${sub_dir:="${dir}"}")"
  done
done
unset end_dirname full_dir_list ext_array dir sub_dir num_sub_dirs \
  N n extglob_pattern ext_first ext_last getfacl_o grep_o

# check MAC's

exit 101

: 'Functions -- for brevity during debugging'
set -v
function B_() { 
  : 'B_ BEGINS' "$((++funclvl))" "${fence}"
  fn_bak "$@"; 
  : 'B_ ENDS  ' "$((--funclvl))" "${fence}"
}
function I_() { 
  : 'I_ BEGINS' "$((++funclvl))" "${fence}"
  fn_erx "${LINENO}"; 
  : 'I_ ENDS  ' "$((--funclvl))" "${fence}"
}
#function N_() { 
#  : 'N_ BEGINS' "$((++funclvl))" "${fence}"
#  fn_num "$@";
#  : 'N_ ENDS  ' "$((--funclvl))" "${fence}"
#};
#function V_() { 
#  : 'V_ BEGINS' "$((++funclvl))" "${fence}"
#  fn_write_vars "$@";
#  : 'V_ ENDS  ' "$((--funclvl))" "${fence}"
#};
function W_() { 
  : 'W_ BEGINS' "$((++funclvl))" "${fence}"
  fn_write_arrays "$@"; 
  : 'W_ ENDS  ' "$((--funclvl))" "${fence}"
}
set +v

: 'Check for Process Locks'

for d in "${a_poss_proces_lock_dirs[@]}"; do
  if [[ -d "${d}" ]]; then
    mapfile -d '' -t lkds < <(
      S_ find "${d}" -type d -empty -name ".${repo_nm}.[0-9a-zA-Z_-]*.lock" \
        -print0 2>/dev/null
    )

    : 'lkds, count:' "${#lkds[@]}"

    for l in "${lkds[@]}"; do
      if [[ -d "${l}" ]]; then
        if [[ -v delete_locks ]]; then
          rmdir -v -- "${l}"
        else
          printf '\n\t A process lock exists for this script. Exiting '
          printf 'now.\n\n'
          L_
        fi
      fi
    done
  fi
done
[[ -v delete_locks ]] \
  && L_

: 'Functions'

fn_bak() {
  : 'fn_bak BEGINS' "$((++funclvl))" "${fence}"
  : fn_bak

  # for each of multiple input files
  for loc_filename_a in "${@}"; do

    # test verifying existence of input
    if S_ test -f "${loc_filename_a}"; then

      # BUG: Why does this ^ test req sudo when this test \/ doesnt?

      # if the destination (.bak) file already exists,
      # then age it first.
      if [[ -f "${loc_filename_a}.bak" ]]; then

        if [[ -s "${loc_filename_a}.bak" ]]; then
          return
        else
          S_ R_ -f -- "${loc_filename_a}.bak"
        fi
      fi

      # write a new .bak file
      S_ rsync -acq -- "${loc_filename_a}"{,.bak} \
        || I_

    # if input file DNE, then print an error and exit
    else
      {
        echo WARNING: file DNE "${loc_filename_a}"
        return
      }
    fi
  done
  : 'END OF fn_bak'
  : 'fn_bak ENDS  ' "$((--funclvl))" "${fence}"
}

fn_erx() {
  : 'fn_erx BEGINS' "$((++funclvl))" "${fence}"
  # this assignment must be the first command
  local loc_exit_code="${?}"
  : fn_erx

  # print an error message and exit with the correct exit code
  echo -e Error: "${@}"
  : 'END OF fn_erx'

  exit "${loc_exit_code}"
  : 'fn_erx ENDS  ' "$((--funclvl))" "${fence}"
}

#fn_num() {
#  : 'fn_num BEGINS' "$((++funclvl))" "${fence}"
#  # Usage: N_ [raw arrays names]
#  : fn_num
#
#  # for each of multiple input array names
#  for loc_unquotd_array_nm_a in "${@}"; do
#
#    # set a local name reference variable
#    local -n loc_nameref_a="${loc_unquotd_array_nm_a}"
#
#    # and use the nameref to print the number of indices in the input array
#    echo ${#loc_nameref_a[@]}
#  done
#  : 'END OF fn_num'
#  : 'fn_num ENDS  ' "$((--funclvl))" "${fence}"
#}

fn_usage() {
  : 'fn_usage BEGINS' "$((++funclvl))" "${fence}"
  # Usage:  fn_usage [exit-code]
  : fn_usage

  # print a usage message and exit with a pre-determined exit code
  cat <<-EOF
    ${repo_nm} - ${script_proper_nm}, version ${script_version}
    Find and scan shell scripts depending on severity level. 
        Usage:  ${script_nm} [-ehiw]
                -e error          -i info
                -h help           -w warning
    Only the first option is processed.

EOF
  : 'END OF fn_usage'

  # shellcheck disable=SC2086
  exit "${1}"
  : 'fn_usage ENDS  ' "$((--funclvl))" "${fence}"
}

# Write each array to a file on disk.
fn_write_arrays() {
  : 'fn_write_arrays BEGINS' "$((++funclvl))" "${fence}"
  # Usage: W_ [arrays]

  loc_write_d_b="${curr_time_ssubd}arrays"

  if [[ ! -d "${loc_write_d_b}" ]]; then
    S_ mkdir -p -- "${loc_write_d_b}" \
      || I_
  fi

  # for each of multiple input array names
  for loc_unquotd_array_nm_b in "${@}"; do

    # create local variables, for use as both array and string
    local -n loc_nameref_b="${loc_unquotd_array_nm_b}"
    loc_array_nm="${loc_unquotd_array_nm_b}"
    loc_write_f_b="${loc_write_d_b}/_${sc_sev_abrv}"
    loc_write_f_b="${loc_write_f_b}_${abbrev_rel_search_dirs}_${loc_array_nm}"

    # solved?  BUG: mixing variable and array. sb a nameref

    # Bug? When array correctly is empty. 'declare -p ... > /dev/null ||' ?

    # if the input array holds no data, then populate it
    if [[ ! -v loc_nameref_b[@] ]]; then
      loc_nameref_b=([0]='fn_write_arrays: Empty array')

    fi

    # then write a data file to disk
    declare -p "${loc_array_nm}" \
      | S_ T_ -- "${loc_write_f_b}" >/dev/null

    # write a backup of the new data file
    B_ "${loc_write_f_b}"
  done
  : 'END OF fn_write_arrays'
  : 'fn_write_arrays ENDS  ' "$((--funclvl))" "${fence}"
}

#fn_write_vars() {
#  : 'fn_write_vars BEGINS' "$((++funclvl))" "${fence}"
#  # Usage: V_ [loc_script_section_nm] [raw variable names]
#
#  # first pos-parm is string used for differentiating filename
#  : fn_write_vars
#  loc_script_section_nm="${1}"
#  loc_write_f_a="${curr_time_ssubd}/${loc_script_section_nm}_vars"
#  shift
#
#  # if the destination file already exists, then return from FN
#  [[ -e "${loc_write_f_a}" ]] \
#    && return
#
#  # write a new data file
#  declare -p "${@}" 2>/dev/null \
#    | S_ T_ -- "${loc_write_f_a}" >/dev/null
#
#  # and write a .bak file
#
#  B_ "${loc_write_f_a}"
#  : END OF fn_write_vars
#  : 'fn_write_vars ENDS  ' "$((--funclvl))" "${fence}"
#}

: 'Use -sudo-'

if ! S_ -v; then
  printf '\n\tValidation failed of user\x27s \x60sudo\x60 timestamp; '
  printf 'exiting.\n\n'
  L_
fi

#X_; :_

: 'Process lock'

# from among the possible dirnames
for poss_lk_d in "${a_poss_proces_lock_dirs[@]}"; do

  # use the first one that fulfills certain requirements
  if [[ -d "${poss_lk_d}" ]] \
    && [[ ! -L "${poss_lk_d}" ]] \
    && [[ -w "${poss_lk_d}" ]]; then

    # define the lock directory
    process_lock_d="${poss_lk_d}/${proc_lk_f_nm}"
    break
  fi
done

# create the lock directory
if ! mkdir -m 0000 "${process_lock_d}" 2>/dev/null; then
  {
    printf '\n\tCannot acquire process lock: <%s>.\n' "${process_lock_d}"
    #printf '\tID: %s\n' "${USER}" # why?
    printf 'Exiting.\n\n'
  } 1>&2
  L_
fi

: User variables
timecode="$(builtin printf '%(%F_%H%M%S)T')"

# SECTION B

#:_
#X_

# BUGs: Hardcoded $mountpoint

: 'Assign varnames and paths for the data directories'
mountpoint=/run/media/root/29_Mar_2023
main_d="${mountpoint}/${script_dirnm}"
data_subd="${main_d}/latest_data"
curr_time_ssubd="${data_subd}/t_${timecode}/"
list_crunchbangs="${curr_time_ssubd}/crunchbangs"

: 'data files'
a_write_path_nms=("${list_crunchbangs:=crunchbangs}" "/tmp/${list_crunchbangs##*/}")

# TODOs: grep scripts for 'todo's
#   - grep for 'shellcheck disable'
#   - This section seems buggy.

: 'Reduce use of sudo'
if [[ ! -r "${main_d}" ]]; then

  mapfile -d / -t a_acl_name_indiv_dir <<<"${main_d}"

  a_acl_name_indiv_dir[0]=/
  a_acl_name_indiv_dir[-1]="${a_acl_name_indiv_dir[-1]//$'\n'/}"

  acl_each_dir="${#a_acl_name_indiv_dir[@]}"

  for ((iterator_1 = 0; iterator_1 < acl_each_dir; iterator_1++)); do
    acl_abs_path+="/${a_acl_name_indiv_dir[iterator_1]}"
    acl_realpath="$(realpath -e "${acl_abs_path}")"

    # Bug: why sudo? \/

    if S_ test -e -- "${acl_realpath}"; then
      : 'test succeeded: acl_realpath exists '
    else

      : 'test failed: acl_realpath DNE'

      if [[ ! -d "${acl_abs_path}" ]]; then

        S_ mkdir -p -- "${main_d}" \
          || I_
      fi

      acl_realpath="$(realpath -e "${acl_abs_path}" 2>/dev/null)"

      #:_

      # TODO: use alias w namei

      #M_ -- "${acl_realpath}"

    fi

    if [[ -r "${acl_realpath}" ]]; then
      : 'test succeeded: acl_realpath is readable'
    else

      : 'test failed: acl_realpath is not readable'

      acl_execd_setfacl=y
      export acl_execd_setfacl # SC2034, while trap-s setfacl blk is #-d # this comment means what?

      # readable up to the main_d
      S_ chmod -R 750 -- "${acl_realpath}" \
        || I_

      S_ setfacl -d -m "${USER}:r-x" -- "${acl_realpath}" \
        || I_

      S_ setfacl -m "${USER}:r-x" -- "${acl_realpath}" \
        || I_

      #:_
      #id "${USER}"
      #groups "${USER}"
      #M_ -- "${acl_realpath}"
      #S_ getfacl -- "${acl_realpath}"

      [[ -r "${acl_realpath}" ]] \
        || I_
    fi
  done

  # writeable within the main_d
  S_ setfacl -d -m "${USER}:rwx" -- "${main_d}" \
    || I_

  S_ setfacl -R -m "${USER}:rwx" -- "${main_d}" \
    || I_

  #:_
  #id "${USER}"
  #groups "${USER}"
  #M_ -- "${main_d}"
  #S_ getfacl -- "${main_d}"

fi

: 'make sure -data_subd- is a directory OR create the -data_subd- dir '
: 'if necessary'
[[ -d "${data_subd}" ]] \
  || mkdir "${data_subd}" # as liveuser

#:_
#M_ -- "${data_subd}"

: Label the current data as -latest.-
# shellcheck disable=SC2312
mapfile -d '' -t a_previous_time_dirs < <(
  find "${data_subd}" -mindepth 1 -maxdepth 1 -type d -a \! -type l \
    -name 't_*' -print0
)

: if -prev_time_ssubd- is empty, delete it, otherwise -mv- it out
: of the -latest- dir
for prev_time_ssubd in "${a_previous_time_dirs[@]}"; do
  rmdir --ignore-fail-on-non-empty -- "${prev_time_ssubd}"

  : of previous prev_time_ssubd
  if [[ -d "${prev_time_ssubd}" ]] && [[ ! -L "${prev_time_ssubd}" ]]; then
    S_ mv -- "${a_previous_time_dirs[@]}" "${main_d}"
  else
    continue
  fi
done

: of curr_time_ssubd
if [[ ! -d "${curr_time_ssubd}" ]]; then
  S_ mkdir -p -- "${curr_time_ssubd}" \
    || I_
fi

#:_
#M_ -- "${curr_time_ssubd}"

# SECTION C

: 'Gather filenames from local attached disk storage'

if [[ "${abbrev_rel_search_dirs}" == all ]]; then

  : 'set a value for a_relevant_search_dirs and..'
  # shellcheck disable=SC2312
  mapfile -d '' -t a_relevant_search_dirs < <(
    S_ find / -mindepth 1 -maxdepth 1 -type d \! -empty \
      \( \! -name proc -a \! -name sys -a \! -iname "${script_dirnm}*" \) \
      -print0 2>/dev/null
  )

  for sd in "${a_relevant_search_dirs[@]}"; do

    # assign
    echo "${sd}"
  done

fi

: 'Find all files within the search area. Even the empty ones.'
# shellcheck disable=SC2312
mapfile -d '' -t a_all_files < <(
  S_ find "${a_relevant_search_dirs[@]}" -mindepth 1 -type f \
    -print0 2>/dev/null
)

: 'Sort the original array and test it.'
# shellcheck disable=SC2312
mapfile -d '' -t a_all_files_sorted < <(
  printf '%s\0' "${a_all_files[@]}" \
    | sort -z
)

# SECTION D

# Bug? Can more indices and fewer files be used?

: 'Sort out the scripts, ie, any file beginning with a crashbang from'
: 'the rest of the files'

: 'Get the total number of found files, for the progress indicator'
# shellcheck disable=SC2034
total_count="$(printf "%'d" "${#a_all_files_sorted[@]}")"
unset IFS

[[ -f /tmp/"${list_crunchbangs##*/}" ]] \
  && S_ R_ -f -- "/tmp/${list_crunchbangs##*/}"

# BUG: the search dirs must be the same, as well as the dnf tx number
# BUG: Use of /tmp/crunchbangs as yn on do loop q. Sb a set of file lists
#.   difftd by search dir / search type / etc. See file "priority"

: 'if the full list exists -- of files on disk which begin with'
: 'crashbangs -- skip the 30-90 minute search phase.'
if [[ ! -f "/tmp/${list_crunchbangs##*/}" ]] \
  || [[ -L "/tmp/${list_crunchbangs##*/}" ]]; then

  for all_files_index in "${!a_all_files_sorted[@]}"; do

    : 'Loop'

    loop_idx="$(printf "%'d" $((all_files_index + 1)))"
    printf '%s of %s files\r' "${loop_idx}" "${total_count}"

    : 'file must exist'
    each_sorted_f="${a_all_files_sorted[all_files_index]}"

    if [[ ! -e "${each_sorted_f}" ]]; then
      a_file_DNE+=([all_files_index]="${each_sorted_f}")
      continue
    fi

    : 'list of empties'
    if [[ ! -s "${each_sorted_f}" ]]; then
      a_empty_files+=([all_files_index]="${each_sorted_f}")
      continue
    fi

    : '-file- magic'
    printf '+ %-8d: ' "${all_files_index}" \
      | S_ tee -a -- "${curr_time_ssubd}file_out" >/dev/null

    file_o="$(S_ file -pk -- "${each_sorted_f}" 2>&1)" # Bug: needs erx
    file_o="${file_o%%64-bit LSB *}"
    a_bin_file_output+=([all_files_index]="${file_o}")

    # Bug? Needs tracking index? One array or file, one line per fso,
    #. use symbols or csv to indicate test results, w common indices
    # Bug: [[ -n sb right after exec file

    if [[ -n "${file_o}" ]]; then
      S_ tee -a -- "${curr_time_ssubd}file_out" <<<"${file_o}" >/dev/null
    else
      err_msg="WARNING: -file- produced 0 output:  <${each_sorted_f}>"
      S_ tee -a -- "${curr_time_ssubd}file_out" <<<"${err_msg}" >/dev/null
    fi

    # Bug: keep `od` output in an array
    # Bug: avoid as many disk writes as possible.
    #.  Write out only stats?
    # Bug: use indices to reference each type? Store array diffs btw loop?
    #. Time loss to disk io? Run file in parallel? Read each file once and
    #. use var for both od and file?

    : 'two bytes each'

    #X_; :_

    # fix?: mapfile -d '' -t -O "${all_files_index}" a_od_output

    od_o="$(
      S_ od -j 0 -N 2 -t x1z -v -- "${each_sorted_f}" \
        | tr -s ' ' \
        | awk '{ print $2, $3, $4 }' \
        | tr -d '\n' \
        || I_ "P:${PIPESTATUS[*]} I:${all_files_index} ${each_sorted_f}"
    )"

    [[ -n "${od_o}" ]] \
      || I_ "I:${all_files_index} ${each_sorted_f}"

    a_bin_od_output+=([all_files_index]="${od_o}")

    read -r byte_0 byte_1 printable_chars <<<"${od_o}"

    export printable_chars # SC2034

    : '-od_o- non-zero'
    if [[ -z "${byte_0}" ]]; then
      I_ "I:${all_files_index} <${each_sorted_f}>" \
        '*unreachable code*'
    elif [[ "${byte_0}" == @(23|21) ]]; then
      : 'compare hexadecimals'

      : 'endianness'
      if [[ "${byte_0}${byte_1}" == 2123 ]]; then
        a_incorrect_endianness+=([all_files_index]="${each_sorted_f}")

      else

        : 'Crunchbangs'

        # q, does strings recognize unicode? Color codes? Cr's? Etc
        # test dd vs strings

        strings_o="$(strings -n1 <"${each_sorted_f}" \
          | head -n1 \
          | cut -b -$((2 ** 14)) \
          || I_ "P:${PIPESTATUS[*]} I:${all_files_index} ${each_sorted_f}")"

        IFS= read -r first_line_printable <<<"${strings_o}" \
          || I_ "I:${all_files_index} ${each_sorted_f}"

        : '-#!comment-'
        if [[ "${first_line_printable}" =~ ^'#!comment' ]]; then
          a_crunches_with_hashbang_comments+=(
            [all_files_index]="${each_sorted_f}")
          continue
        fi

        #   Note: with only /bin/sbin, this if-fi block doesn't execute

        # FR: sort also per-rpm, awk script, probably

        : 'outside of rpm'
        if ! rpm -qf "${each_sorted_f}" 2>/dev/null 1>&2; then

          : 'user or system'
          if [[ "${each_sorted_f}" = /@(root|home|run/media)/* ]]; then
            a_non_rpm_user_crunches+=([all_files_index]="${each_sorted_f}")
            continue
          else
            a_non_rpm_system_crunches+=(
              [all_files_index]="${each_sorted_f}")
            continue
          fi
        fi
      fi

      #X_; :_

      # scan non-shell scripts for shell escapes ie sys-bin calls
      # https://www.sans.org/blog/escaping-restricted-linux-shells/

      # Bug, "shell scripts" incls python perl etc

      # how to make IRT lists for each interpreter?

      : 'Make an array of the relevant filenames and their crashbangs.'
      a_shell_scripts+=([all_files_index]="$(printf \
        "%'-12d %%=%%=%%=%% %-50s %%=%%=%%=%% %s\n" \
        "${all_files_index}" "${first_line_printable}" \
        "${each_sorted_f}")"
      )

    else

      : 'all others'
      a_all_other_files+=([all_files_index]="$(printf \
        "%'-12d %%=%%=%%=%% %s\n" "${all_files_index}" \
        "${each_sorted_f}")"
      )
    fi
  done

  # Note, you want to see the full crunchbangs in printed ASCII form

  : 'Open a timestamped file and append into it the list of filenames'
  : 'and their crashbangs.'

  : 'Exporting is necessary of the array names from the above scan'
  a_arrays=(a_all_files a_all_files_sorted a_file_DNE a_empty_files a_bin_file_output a_bin_od_output a_incorrect_endianness a_crunches_with_hashbang_comments a_non_rpm_user_crunches a_non_rpm_system_crunches a_shell_scripts a_all_other_files a_write_path_nms)
  export "${a_arrays[@]}"

  W_ "${a_arrays[@]}"
  B_ "${curr_time_ssubd}/file_out"
  #L_;

  : 'if any data files already exist, keep them'
  for any_existing_f in "${a_write_path_nms[@]}"; do

    if [[ -f "${any_existing_f}" ]] && [[ ! -L "${any_existing_f}" ]]; then
      S_ mv -- "${any_existing_f}" "${any_existing_f}.${$}.${random_n}" \
        || I_
    fi
  done

  : 'create the original list_crunchbangs'
  S_ touch -- "${a_write_path_nms[@]}"

  : 'write a file header'
  {
    printf '# crunchbangs -- %s\n' "${timecode%-*}"
    printf '# %s\n' "$(declare -p a_relevant_search_dirs)"
  } | S_ T_ -- "${a_write_path_nms[@]}" >/dev/null

  : 'printing contents of a_shell_scripts array, with backup'
  printf '%s\n' "${a_shell_scripts[@]}" \
    | S_ T_ -a -- "${a_write_path_nms[@]}" >/dev/null
  B_ "${a_write_path_nms[@]}"

else

  # the time_dir needs a copy of the crunchbangs file, also.  copy it in
  # from the hopefully correct backup in /tmp
  if [[ ! -f "${list_crunchbangs}" ]]; then
    S_ rsync -ca -- "/tmp/${list_crunchbangs##*/}" "${list_crunchbangs}" \
      || I_
  fi
fi

# <> ?
W_ a_write_path_nms

#X_; :_;

S_ head -- "/tmp/${list_crunchbangs##*/}"
#L_;

: 'Verify interpreters'

: 'Get the list of interpreters from the list of crunchbangs.'
#   Note: new indices starting from 0
# use the contrived delimiter to capture entire shebang string
# remove leading whitespace
# sort and print unique
# remove leading ^'#!' from each interpreter
# shellcheck disable=SC2016
mapfile -t a_interpreters < <(
  S_ awk 'BEGIN { FS = "%=%=%=%" } ; /#!/ { print $2 }' -- \
    "/tmp/${list_crunchbangs##*/}" \
    | awk 'BEGIN { FS = " -" } ; { print $1 }' \
    | sed 's, *,,g' \
    | sort -u \
    | cut -b3- \
    || I_ "P:${PIPESTATUS[*]}"
)

# <>
:_
#L_

# Duplicate with post-getopts section ?

: 'Ways to find an interpreter if it-s available on disk:'

# Bug: `realpath -e` and `command -V` are redundant?
# Answer: no. `command` is limited to PATH; realpath is limited by FS permissions.

# `find` can produce symlinks or actual files
#   # find /usr/sbin -type l | grep resolvconf
#       /usr/sbin/resolvconf
# `command` can produce symlinks
#   # command -V resolvconf
#       resolvconf is /usr/sbin/resolvconf
# `realpath` produces physical paths
#   # realpath -e /usr/sbin/resolvconf
#       /usr/bin/resolvectl

for program in "${a_interpreters[@]}"; do
  : 'command -pV'
  command_o="$(command -pV "${program}" 2>&1)"

  if [[ -n "${command_o}" ]]; then
    realpath_o="$(realpath -e "${command_o}" 2>/dev/null)"

    if [[ -f "${realpath_o}" ]]; then
      a_interps_rps+=("${realpath_o}")
      m="exists on disk"
      break
    fi
  fi
done

# Bug: add "-d ''" to mapfile

# Canonicalize interpreters paths, sort and list each unique binary.
#   Note: new indices starting from 0
mapfile -t a_interps_rps < <(
  S_ realpath -e -- "${a_interpreters[@]}" \
    | sort -u
)

# <>
L_

# for each interpreter, print it in the 1st 32 bits of a line.

{
  for b in "${!a_interps_rps[@]}"; do

    printf '%-32s' "${a_interps_rps[b]}"

    # use a shell builtin to test for each interpreter's presence on disk, and write to a variable the test's result

    if command -pV "${a_interps_rps[b]}" >/dev/null; then
      m="exists on disk"
    else
      m="DNE on disk"
    fi

    # create a new array of structured data: index, interpreter and test result
    a_interps_disk_repo+=([b]="${b} : ${a_interps_rps[b]} : ${m}")

    # into the next 8 bits of a line, print the test result
    printf '%-8s' "${m}"

    # identify the originating rpm for each interpreter.
    # binary need not be installed.
    # filter for rpm name by CPU type in its filename
    # sort rpms and print each unique
    dnf_po="$(
      S_ dnf provides -- "${a_interps_rps[b]}" \
        | awk '/x86_64|i686/ { print $1 }' \
        | sort -u
    )"

    # based on whether there was any output,
    # save a result message to variable
    if [[ -n "$dnf_po" ]]; then
      n="exists in repos"
    else
      n="DNE in repos"
    fi

    # in the same array, in a different range of indices,
    # save the index, interpretet name and rpm test result
    a_interps_disk_repo+=([b + 100]="${b} : ${a_interps_rps[b]} : ${n}")

    # print rpm test result to end of line; include a newline
    printf '\t\t\t\t%s\n' "${n}"

    # if any data exists, print the list of originating rpms
    printf '%s\n' "$dnf_po"
    unset dnf_po m n

  done
} | S_ T_ -a -- "${curr_time_ssubd}a_interpreters" >/dev/null
unset b

# <>
#X_; :_;
W_ a_write_path_nms a_interpreters a_interps_rps a_interps_disk_repo
L_

# SECTION E

: 'CENTRAL TASK, 1 OF 2: Filter the list of crashbangs with the list'
: 'of shells.'

# print one file header

{
  printf '# SC-scrpts-list -- %s\n' "${timecode%-*}"
  printf '# %s\n' "$(D_ a_relevant_search_dirs)"
} | S_ T_ -- "${list_crunchbangs}_SC-scrpts-list" >/dev/null

# filter out interpreters not compatible with shellcheck.
# file $list_crunchbangs is located in $time_dir.
S_ grep -E -- '/bin/'"${SC_shells}"'.*%=%=%=%' "${list_crunchbangs}" \
  | S_ tee -a -- "${list_crunchbangs}_SC-scrpts-list" \
  || I_

# Copy list to /tmp
S_ rsync -ca -- "${list_crunchbangs}_SC-scrpts-list" /tmp \
  || I_

# Backup both lists
B_ "${list_crunchbangs}_SC-scrpts-list" /tmp/*_SC-scrpts-list

# <>
X_
:_
W_ timecode list_crunchbangs SC_shells
L_

: 'CENTRAL TASK, 2 of 2: with ShellCheck scan each script for errors'

# TODO: keep "$all_files_index" tracked with content all the way through
#   into the "_found_scripts" file
# Bug? line 1 of script could contain percent symbols

: 'A hell world of pipelines'
#   Q: how to translate the correct newlines into nulls to separate the
#   filenames when reading from a file?  awk? files _can_ contain \n-s

# for every line beginning with a crashbang...
grep_o="$(S_ grep ^'#!' -- "${list_crunchbangs}_SC-scrpts-list")"

# get the filename
cut_o="$(cut -d '%' -f5- <<<"${grep_o}")"

# collect the filenames in a single list
mapfile -t a_each_abspath_scriptnm <<<"${cut_o}"

# remove leading whitespace
a_each_abspath_scriptnm=("${a_each_abspath_scriptnm[@]##* }")

# Wk: awk , multi-char delim, remv lead+trail wspc - redef $0 ?, printf

#   grep -Eo | tr

# Bug: rename variable "$c" below
# Bug: why sort by line count? More text, more bugs? How to prior mult
#   factors?

# count number of newlines in each script
wc_o="$(S_ wc -l -- "${a_each_abspath_scriptnm[@]}")"

# remove 'totals' line
wc_o="${wc_o%$'\n*'}"

# sort script lengths descending
sort_o="$(sort -gr <<<"${wc_o}")"

# print script names
awko="$(awk '{ print $2 }' <<<"${sort_o}")"

# create a list of script names sorted by line count descending
mapfile -t a_each_script_list_sorted_by_linect \
  <<<"${awko}"

# define file name, including severity and path symbols (target file)
found_scrpts_f="${list_crunchbangs}_found_scripts_${sc_sev_abrv}_${abbrev_rel_search_dirs}"
i=0

# Bug? 1st grep extra?

{

  # for each sorted script
  for sorted_script in "${!a_each_script_list_sorted_by_linect[@]}"; do

    # run shellcheck with selected/default severity
    # remove URL's
    # capture SC error codes with their descriptions
    # truncate descriptions to 64 bytes
    # sort numerically
    # count the number of unique errors
    # sort by the third column: severity
    # collect output in an array
    # on any non-zero exit status, print an error, incuding PIPEFAIL array, and exit the script
    # when filters, etc completes, print a NULL to start a new mapfile index
    mapfile -d '' -t a_each_script_SC_results < <(
      shellcheck -S "${sc_severity}" \
        "${a_each_script_list_sorted_by_linect[sorted_script]}" \
        | grep -Fv 'shellcheck.net' \
        | grep -Eo "SC[0-9]{4}.*" \
        | cut -b -64 \
        | sort -g \
        | uniq -c \
        | sort -k3 \
        || I_ "P:${PIPESTATUS[*]} I: S:" # index and script name
      # end of pipe intended
      printf '\0'
    )

    # if there's any output from shellcheck
    if [[ -n "${a_each_script_SC_results[*]:0:1}" ]]; then

      # Bug: iterator sb $sorted_script ? sorted_script should have

      # print a line header. (as-is:) including a new index number for each script
      printf '\n%-4d%s\n' $((i++)) \
        "${a_each_script_list_sorted_by_linect[sorted_script]}"
      # print all massaged SC results for each script
      printf '%s' "${a_each_script_SC_results[@]}"
    fi
  done
  unset i

  # append each text group to a findings file
} | S_ tee -a -- "${found_scrpts_f}" >/dev/null

: 'Write semi-permanent archives'

# backup the findings file
B_ "${found_scrpts_f}"

# make copies of the findings file and backup those copies
for d in /tmp "${main_d}"; do
  S_ rsync -ca -- "${found_scrpts_f}" "${d}" \
    || I_
  B_ "${d}/${found_scrpts_f##*/}"
done
unset d

# <> Print some variables   for interactive use
z=0
for d in "${curr_time_ssubd}" "${main_d}" /tmp; do
  printf '\n\t data_d_%d=%s\n' $((z++)) "${d}"
done
unset d z

trap - EXIT
exit 00
