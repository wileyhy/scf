#! /bin/bash
# find-and-scan-shell-scripts-sh
# Written in bash version 5.1

# Implementation-dependent array of shells parseable by `shellcheck -S`
# (a <w>hitelist in regex).
w='(sh|bash|dash|ksh)'

# Other variables
unset {a..z} {A..Z}
f='(0|1|2|7z|afm|al|aug|bz2|c|cfg|conf|css|ctb|dat|def|desktop|dict|enc|fd|go|gz|h|html|info|ini|jpeg|js|json|lang|ldf|lua|m4|map|mat|md|mf|mim|mld|mo|mod|mp4|msg|nse|otf|page|pdf|pem|pfb|pfm|pl|pm|png|po|pod|ps|py|pyc|pyi|qdocconf|qml|rb|rst|rules|scm|service|so|sqlite|sty|sub|svg|swp|t|tablet|tar|tcl|tex|texi|tfm|tmpl|ttf|txt|typelib|ui|upp|vf|vim|xml|xpi|xpm|xsd|xsl|xz|yaml|yml|zip)' # <f>ilename.suffix
m="${TEMPDIR:="$HOME"}" # <m>ountpoint
r='(binfmt_misc|bpf|cgroup2|configfs|debugfs|devpts|devtmpfs|efivarfs|fusectl|hugetlbfs|iso9660|mqueue|proc|pstore|rpc_pipefs|securityfs|selinuxfs|sysfs|tmpfs|tracefs)' # <r>egex 
t="$( date '+%F_%H%M%S' )" # <t>ime

# Bug? is '/run/media' portable to other distros? 
# a default save directory somewhere off of the local disk
mapfile -d '' -t save_dirs < <( 
  find /run/media -mindepth 2 -maxdepth 2 -type d \
      -exec df --sync -l --output=fstype,avail,source \
      --block-size=1 '{}' ';' | 
    grep -iv avail | 
    tr '\n' '\0' )

# filter out via  <r>egex certain FS types by sorting the <o>utput of `df`
for o in "${!save_dirs[@]}"; do 
  if [[ "${save_dirs[$o]}" =~ ^${r} ]]; then 
    unset 'save_dirs[$o]'; 
  fi; 
done

# take the de<v>ice with the most available space, and get its
# <m>ountpoint, just in case large log files. `awk` can do more here.
if [[ -z "${save_dirs[*]:0:1}" ]]; then
  v="$( printf '%s\n' "${save_dirs[@]}" | 
    sort -grk2 | 
    head -n 1 |
    awk '{ print $3 }' )"
  m="$( mount | 
    awk "\$1 ~ /${v##*/}/ "'{ print $3 }' )"
fi

# Gather filenames from local attached disk storage
mapfile -d '' -t relevant_search_dirs < <(
  find / -mindepth 1 -maxdepth 1 -type d \
    \( \! -name proc -a \! -name sys -a \! \
    -name git \) -print0 )

# DEBUG: "${relevant_search_dirs[@]}" OR '/usr/sbin'
mapfile -d '' -t all_files < <( 
  find "${relevant_search_dirs[@]}" -type f -print0 2> /dev/null )

  # <>
  set -x
  
# Use <i>ndex to sort out the <s>cripts from the rest of the files
for i in "${!all_files[@]}"; do
  unset b n x
  wait -f
	
  # use a <n>ameref (sort of), and one for the e<x>tension also
  n="${all_files[$i]}"
  x="${n##*.}"

  # filter 1: there must be a size of greater than zero
  if [[ ! -s "$n" ]]; then
    unset 'all_files[$i]'
    continue
  fi

  # filter 2: apply a <w>hitelist of shell program names against 
  # filename e<x>tensions
  if [[ "$x" =~ ${w} ]]; then
    
    # using <n>amerefs, make a list in RAM of filenames which are scripts
    shell_scripts+=( "$n" );  
    unset 'all_files[$i]'
    continue
  fi
	
  # skip the obviously irrelevant files (filename extension <f>ilter)
  if [[ "$x" =~ .\.${f}$ ]]; then
    unset 'all_files[$i]'
    continue
  fi	
	
  # read from disk in binary the first two bytes of every file left in 
  # the list, and format it in <h>exadecimal.
  mapfile -d '' -t h < <(  
    od -Ax0 -N2 -x "$n" |
      tr -s ' \n\t' '\0' )

  # compare the <h>exidecimal representations to find any <c>runchbangs
  if [[ "${h[1]}" == '2123' ]]; then
 
    # when a <c>runchbang's found, use `strings` to filter out any non-
    # printable data, to protect `head` from garbage input, and to 
    # get the full <c>runchbang string in ASCII.
    c="$( strings -n 1 "$n" |
      head -n 1 |
      head -c 32 )"; 

    # using <n>amerefs, make a record of the filenames and their 
    # <c>runchbangs, ie, open & append to a <t>imestamped file on disk
    printf '%s \t\t\t %s \n' "$c" "$n" >> "${m}/${t}_crunches"; 
    unset 'all_files[$j]'
  fi; 
done

# output some data for further constructing the blacklist 
declare -p m all_files > "${m}/${t}_remaining_files"

# with ShellCheck scan each <s>cript for <e>rrors, and use index <j>
for j in "${!shell_scripts[@]}"; do 

  # also use, for <s>cripts, a nameref
  declare -n s="${shell_scripts[$j]}"

  e="$( shellcheck -S error "$s" | 
    grep -vFe 'shellcheck.net' | 
    grep -Eoe 'SC[0-9]{4}' | 
    sed -e 's,^[[:space:]]*,,g' \
      -e 's,[[:space:]]$,,g' | 
    sort -gr | 
    uniq -c )";

  if [[ -n "$e" ]]; then 
		
    # open & append some prioritized work lists with indices
    printf '%d  <%s>\n' "$i" "$s" >> \
      "${m}/${t}_found_scripts_with_indices" 
    printf '%s | %d\n' "$e" "$i" >> \
      "${m}/${t}_found_errors_with_indices"
  fi
done
