#!/bin/bash
# find-and-scan-shell-scripts-sh
# Written in bash version 5.1 on Fedora 37


:;: Implementation-dependent arguments for opts parsable by -shellcheck-
severity=error
shells='(sh|bash|dash|ksh)'

:;: Environment variables
PATH="$( /usr/bin/command -p getconf PATH ):/usr/bin:/usr/sbin:${PATH}"
LC_ALL=C.UTF-8
LC_COLLATE=C

:;: Option parsing

fn_usage(){
  : fn_usage
  # Usage:  fn_usage [exit-code]
  cat <<-\EOF
    
    SCF - Shell Check Find, version 1.0 (for redhat-linux)
    Find and scan shell scripts depending on severity level. 
        Usage:  ./find-and-scan-shell-scripts-sh [-ehiw]
                -e error          -i info
                -h help           -w warning
    Only the first option is processed.

EOF
  exit "${1}"
  : END OF fn_usage;:
}

if [[ "$#" -gt 0 ]]; then
  cli_input="${1:0:2}"

  case "${cli_input}" in
    --) printf 0a09486170707920456173746572210a0a | 
          xxd -r -p
        exit 0;;
    -e) severity=error;;
    -i) severity=info;;
    -v) printf 0a09224920776f756c642068617665206d61646520746869732073686f727465722c206275742049206469646e27742068617665207468652074696d652e220a09092d2d204d61726b20547761696e0a0a |
          xxd -r -p
        exit 0;;
    -w) severity=warning;;
    -h) :; fn_usage 0;;
    *)  :; fn_usage 1;;
  esac
fi

:;: Use -sudo-
if ! sudo -v; then
  printf '\n\tValidation failed of user\x27s \x60sudo\x60 timestamp; ' 
  printf 'exiting.\n\n' 
  exit "$LINENO"
fi

:;: Process lock
random_n="$RANDOM"; 
proc_lk_f_nm=".$$.${random_n}.lock"; 
a_poss_proces_lock_dirs=( [0]="$XDG_RUNTIME_DIR" [1]="$HOME" 
  [2]="$TMPDIR" [3]=/tmp [4]=/var/tmp ); 

for poss_lk_d in "${a_poss_proces_lock_dirs[@]}"; do 
  if [[ -d "$poss_lk_d" ]]; then
    process_lock="${poss_lk_d}/${proc_lk_f_nm}"
    break
  fi
done; 

# shellcheck disable=SC2154
trap '
  for poss_lk_d in "${a_poss_proces_lock_dirs[@]}"; do 
    proclock="${poss_lk_d}/${proc_lk_f_nm}"
    if [[ -d "$proclock" ]] && [[ ! -L "$proclock" ]]; then 
      rm -rf -- "$proclock"; 
    fi;
  done

  # Good code, for final versions
  #if [[ -v acl_execd_setfacl ]]; then 
    #if [[ -v acl_abs_path ]]; then 
      #sudo setfacl -R -x u:"$UID" "$acl_abs_path" ||
        #echo Error: setfacl failed, line $LINENO
    #elif [[ -v mountpoint ]]; then
      #sudo setfacl -R -x u:"$UID" "$mountpoint" ||
        #echo Error: setfacl failed, line $LINENO
    #fi
  #fi

  trap - EXIT TERM INT; 
  kill -s INT "$$"
  ' EXIT TERM INT # for cleaner xtrace output, put on one line 

if ! mkdir "$process_lock" 2> /dev/null; then
  { printf '\n\tCannot acquire process lock: <%s>.\n' "$process_lock"
    printf '\tID: %s\n' "$USER"
    printf 'Exiting.\n\n' 
  } 1>&2
  exit "$LINENO"
fi

:;: User variables
fstype_list='btrfs,exfat,ext3,ext4,fat32,ntfs,xfs'
timecode="$( builtin printf '%(%F_%H%M%S)T' )"

:;: Functions
fn_age_file(){
  : fn_age_file

    :;: '<>'
    [[ -f "$1" ]] ||
      return 1

  local -A loc_A_hashes_prev_files
  mapfile -d '' -t loc_a_previous_aged_files < <( 
    find "${1%/*}" -type f -regextype egrep \
      -regex ".*/${1##*/}\.([0-9]){10}" 2> /dev/null ) 

  # if the new hash is already present in the assoc
  # array, then the new file is a dup
  for loc_prevsly_aged in "${loc_a_previous_aged_files[@]}"; do 
    
    if [[ -f "$loc_prevsly_aged" ]]; then
      
      loc_A_hashes_prev_files["$( 
        md5sum "$loc_prevsly_aged" | 
          cut -d ' ' -f1 )"]="$loc_prevsly_aged" 
      
      loc_aging_hash_new="$( 
        md5sum "$1" | 
          cut -d ' ' -f1 )"
      
      [[ -n "${loc_A_hashes_prev_files["$loc_aging_hash_new"]}" ]] && 
        : END OF fn_age_file;:
        return 0
    fi
  done

  loc_aging_mtime="$( stat -c%Y "$1" )"
  mv "${1}" "${1}.${loc_aging_mtime}" ||
    fn_erx fn_age_file "$1";
  : END OF fn_age_file;:
}
fn_bak(){ 
  : fn_bak

    :;: '<>'
    [[ "$#" -eq 0 ]] &&
      return 1

  # test verifying existence of input -- sb unnec, except for debugging
  #local loc_filename_a
  for loc_filename_a in "$@"; do 
    if [[ -f "${loc_filename_a}" ]]; then 
      rsync -acq "${loc_filename_a}"{,.bak} ||
        fn_erx "$LINENO"
    else
      fn_erx "$LINENO" file DNE "${loc_filename_a}" 
    fi
  done
  #declare -p loc_filename_a
  : END OF fn_bak;:
}
fn_erx(){ 
  local loc_exit_code="$?" # this assignment must be the first command
  : fn_erx
  echo -e Error: "$@" 
  : END OF fn_erx;:
  exit "$loc_exit_code"
}
fn_num(){ 
  : fn_num
  #local loc_unquotd_array_nm_a
  for loc_unquotd_array_nm_a in "$@"; do
    local -n loc_nameref="$loc_unquotd_array_nm_a" 
    echo "${#loc_nameref[@]}"
  done
  #declare -p loc_unquotd_array_nm_a >&2
  : END OF fn_num;:
}
fn_write_arrays(){
  : fn_write_arrays
  # Usage: fn_write_arrays [arrays]
  # Note: Default directory is -curr_time_ssubd-.

  :;: fn_write_arrays: Write each array to disk.
  #   Note: `tee` without -a will overwrite an existing file
  for loc_unquotd_array_nm_b in "$@"; do 
    #local loc_write_f_b
     loc_write_f_b="${curr_time_ssubd}/${loc_unquotd_array_nm_b}"
    #[[ -e "$loc_write_f_b" ]] &&
      #fn_age_file "$loc_write_f_b"
    if [[ -v "$loc_unquotd_array_nm_b" ]]; then
      declare -p "$loc_unquotd_array_nm_b" | 
        tee --output-error=exit "$loc_write_f_b" > /dev/null
    else
      fn_erx "$LINENO" VAR "$loc_unquotd_array_nm_b" DNE
    fi
    :; fn_bak "$loc_write_f_b"
    #unset loc_write_f_b
  done
  #declare -p loc_unquotd_array_nm_b loc_write_f_b
  : END OF fn_write_arrays;:
}
# Usage: fn_write_vars [loc_script_section_nm] [raw variable names]
fn_write_vars(){
  : fn_write_vars
  #local loc_script_section_nm loc_write_f_a
  loc_script_section_nm="$1"
  loc_write_f_a="${curr_time_ssubd}/${loc_script_section_nm}_vars"
  shift
  [[ -e "$loc_write_f_a" ]] &&
    fn_age_file "$loc_write_f_a"
  declare -p "$@" 2> /dev/null |
    tee --output-error=exit "$loc_write_f_a" > /dev/null
  :; fn_bak "$loc_write_f_a"
  #declare -p loc_script_section_nm loc_write_f_a 
  : END OF fn_write_vars;:
}
#export -f \
  #fn_age_file \
  #fn_bak \
  #fn_erx \
  #fn_num \
  #fn_usage \
  #fn_write_arrays \
  #fn_write_vars



:;: Assign varnames and paths for the data directories

#   Note: In case of large log files, programatically select a save di-
# rectory, attached to the local disk, where any output can be saved; 
# prefer USB flash drives. This particular `df` command will output three 
# alphanumeric strings separated by whitespace on a single line. `sort` the 
# output by descending size. With `awk`, take the device with the most 
# available space and get its mountpoint with `findmnt`. If there is no 
# output, then set mountpoint according to environment variables. 


# List all SCSI device (major number 8) partitions (ending with [0-9]), 
# and print any which have both any detected filesystem and no detected
# mountpoint.

  #:;: '<>'
  #set -x

# get the list of attached SCSI devices
mapfile -t a_maj8s < <( 
  lsblk --ascii --include 8 --noempty --noheadings --paths --output path --list /dev/sd[b-z][0-9] ); 

  #:;: '<>'
  #declare -p a_maj8s
  #exit "$LINENO"

#a_maj8s_copy=( "${a_maj8s[@]}" )
I=${#a_maj8s[@]}; 
for ((i=0;i<I;i++)); do 
  #echo $i: "${a_maj8s[$i]}"; 

  # get per-device info on fstype, uuid and mountpoints
  # shellcheck disable=SC2016
  read -r 'a_fs[$i]' 'a_uu[$i]' < <( 
    sudo wipefs --no-act --output type,uuid --noheadings \
      --types "$fstype_list" "${a_maj8s[$i]}" )
  # shellcheck disable=SC2016
  read -r 'a_mp[$i]' < <( 
    lsblk --noheadings --output mountpoints "${a_maj8s[$i]}" ); 

    #:;: '<>'
    #declare -p a_{maj8s{,_copy},fs,uu,mp}

  # of the found SCSI devices, if there is no FS, then disregard it...
  [[ -z "${a_fs[$i]}" ]] && 
    unset a_maj8s'[$i]'; 
    
  # ...and if there is a mountpoint, also disregard that
  [[ -n "${a_mp[$i]}" ]] && 
    unset a_maj8s'[$i]'
done

  #:;: '<>'
  #declare -p a_{maj8s,fs,uu,mp} i a_maj8s_copy 
  #exit "$LINENO"
  set -x

# if there arent any available mountpoints, but there are some fs-s
# or if there are some extra fs-s attached which arent mounted
for mp in "${a_mp[@]}"; do [[ -n "$mp" ]] && a_avail_mp+=( "$mp" ); done
for fs in "${a_fs[@]}"; do [[ -n "$fs" ]] && a_avail_fs+=( "$fs" ); done

  declare -p a_avail_mp a_avail_fs

if { 
  [[ "${#a_avail_mp[@]}" -eq 0 ]] && [[ "${#a_avail_fs[@]}" -gt 0 ]];
    } || 
  [[ "${#a_avail_mp[@]}" -lt "${#a_avail_fs[@]}" ]]; 
then
  
  # if there are any partitions left in the 'a_maj8s' array, then...
  # shellcheck disable=SC2154
  if [[ "${#a_maj8s[@]}" -gt 0 ]]; then

    # 
    printf '\n\t There are _%d_ SCSI filesystems ' "${#a_avail_mp[@]}"
    printf 'mounted and _%d_ additional SCSI \n\t file' "${#a_maj8s[@]}" 
    printf 'systems unmounted and available.\n\n'
    printf '\t\t %s \n' "${a_maj8s[@]}"
    printf ' \n'

    # BUG: needs a timeout and a default value. use `read`?

    select mount_exit in Ignore 'Mount all' Exit; do

      case "$mount_exit" in
        Exit) exit 0;;
        Ignore) break;;
        'Mount all')

          # mount the found partitions
          for j in "${!a_maj8s[@]}"; do 

              #:;: '<>'
              #declare -p j

            # create a mountpoint
            a_mp+=( [$j]="/run/media/${USER}/${a_uu[$j]}" )
            sudo mkdir --parents "${a_mp[$j]}" ||
              fn_erx "$LINENO"

            # mount the device
            sudo mount -o nosuid,nodev,noexec,rw \
                "${a_maj8s[$j]}" "${a_mp[$j]}" ||
              fn_erx "$LINENO"
          done
          break
          ;;
        *) fn_erx "$LINENO" '*Unreachable code*'
      esac
    done

      #:;: '<>'
      declare -p mount_exit a_mp 
  fi
elif [[ "${#a_avail_mp[@]}" -eq "${#a_avail_fs[@]}" ]]; then
  true
else
  fn_erx "$LINENO" '*Unreachable code*'
fi
    :;: '<>'
    set -x
    #exit "$LINENO"

# prevent the FS root '/' from becoming the mountpoint
mountpoint="$( 
  for m in "${a_mp[@]}"; do 
    [[ -n "$m" ]] && 
      sudo findmnt --ascii --bytes --canonicalize --df --list \
          --types "$fstype_list" --noheadings --notruncate --nofsroot \
          --output maj:min,size,target --mountpoint "$m"; 
  done | 
    sort -rnk2 | 
    awk 'NR==1 { print $3 }' )"


[[ -n "$mountpoint" ]] ||
  fn_erx "$LINENO"
main_d="${mountpoint}/scf.d"
data_subd="${main_d}/latest_data"
curr_time_ssubd="${data_subd}/t_${timecode}"
list_crunchbangs="${curr_time_ssubd}/crunchbangs"
read -r filesystem_type device < <( 
  sudo findmnt --ascii --bytes --canonicalize --df --list \
    --types "$fstype_list" --noheadings --notruncate --nofsroot \
    --output fstype,source --mountpoint "$mountpoint" )
umask 077

  :;: '<>'
  declare -p process_lock filesystem_type device
  #exit "$LINENO"

:;: 'reduce use of -sudo- in this script by setting up ACL-s'
case "$filesystem_type" in
  'xfs')      true;;
  ext[2-4])   tune2fs -l "$device" | 
                grep -i 'acl'
              fn_erx "$LINENO" TODO;;
  *)          fn_erx "$LINENO" TODO;;
esac
  
:;: 'on XFS'

# Nearly all of the `sudo` commands below are allowing rw access, of  
# this script's data_subd, so simply using ACL's will reduce the overuse 
# of `sudo`. This section takes the "$mountpoint" variable, portions
# each subdirectory name into an array index, and tests each subdi-
# rectory from the FS root up for readability by the user running
# this script (ie, a regular user). As the absolute path is recon-
# structed, when a non-readable directory is found, a recursive "r-x" 
# ACL is written, and then a recursive "rwx" is written for the 
# "$main_d". 
if [[ ! -r "$main_d" ]]; then
  
  mapfile -d '/' -t a_acl_name_indiv_dir <<< "${mountpoint}"; 
  a_acl_name_indiv_dir[0]='/'
  a_acl_name_indiv_dir[-1]="${a_acl_name_indiv_dir[-1]//$'\n'}"
  acl_each_dir=${#a_acl_name_indiv_dir[@]}; 
  
  for (( iterator_1 = 0 ; iterator_1 < acl_each_dir ; iterator_1++ )); do 
    acl_abs_path+="/${a_acl_name_indiv_dir[$iterator_1]}"; 
    acl_abs_path="$( realpath -e "$acl_abs_path" )"; 
    
    if [[ ! -r "$acl_abs_path" ]]; then 
      sudo mkdir --parents "$main_d" ||
        fn_erx "$LINENO"
      acl_execd_setfacl='y'
      export acl_execd_setfacl # SC2034, while trap-s setfacl blk is #-d
      
      if ! sudo setfacl -R -m "$USER":r-x "$acl_abs_path"; then
        fn_erx 'setfacl failed, acl_abs_path:' "$acl_abs_path"
        break
      elif ! sudo setfacl -R -m "$USER":rwx "${main_d%/*}"; then
        fn_erx 'setfacl failed, \x24{maind%/*}:' "${main_d%/*}"
        break 
      fi
    fi 
  done 
fi

:;: 'make sure -data_subd- is a directory OR create the -data_subd- dir '
: 'if necessary'
#for subd_x in "$data_subd" "$meta_subd"; do
  #[[ -d "$subd_x" ]] ||
    #mkdir "$subd_x" 
#done
[[ -d "$data_subd" ]] ||
  mkdir "$data_subd"

:;: 'Label the current data as -latest.-'
#   Note: `find` sees dirs and symlinks as separate things 
mapfile -d '' -t a_previous_time_dirs < <( 
  find "${data_subd}" -mindepth 1 -maxdepth 1 -type d -a \! -type l \
    -name 't_*' -print0 )
#export a_previous_time_dirs

:;: 'if -prev_time_ssubd- is empty, then delete it; otherwise -mv- it out'
:   ' of the -latest- dir'
for prev_time_ssubd in "${a_previous_time_dirs[@]}"; do 
  if rmdir --ignore-fail-on-non-empty "$prev_time_ssubd"; then
    : '-rmdir- succeeded'
  else
    : '-rmdir- failed'
  fi
  
    : '<>'
    test ! -e "$prev_time_ssubd" &&
      : 'prev_time_ssubd DNE' 

  : 'of previous prev_time_ssubd' 
  #   Note: with `test`, dirs and symlinks can refer to the same inode
  if [[ -e "$prev_time_ssubd" ]] &&
    [[ ! -L "$prev_time_ssubd" ]]; 
  then
    mv "${a_previous_time_dirs[@]}" "$main_d"
  else
    continue
  fi
done

: 'of curr_time_ssubd'
if [[ ! -d "${curr_time_ssubd}" ]]; then
  mkdir "${curr_time_ssubd}" ||
    fn_erx "${LINENO}"
fi

  # <> 
  #:; fn_write_vars 'A' LC_ALL LC_COLLATE PATH acl_abs_path acl_each_dir acl_execd_setfacl cli_input curr_time_ssubd data_subd device filesystem_type fstype_list leftover_words_a list_crunchbangs main_d mountpoint prev_time_ssubd process_lock random_n severity shells subd_x timecode
  #:; fn_write_arrays a_acl_name_indiv_dir a_poss_write_devices a_previous_time_dirs
  #:; {
    #declare -fp \
 	    #fn_erx \
 	    #fn_usage; 
    #} | tee "${curr_time_ssubd}/A_functions"
  #exit "$LINENO"
  set -x


###  section  b  ###
# BUG:  Reduce Search Time  ==  RST

:;: 'Gather filenames from local attached disk storage'

# If a prior record of the a_relevant_search_dirs array exists, and 
# if that prior record matches the new record, then it's possible the 
# a_all_files list would be the same, too. So if the new relevant_\
# search_dirs list is new, then do the full a_all_files search again.
# But if they're the same, then ...

#:;: 'Variables for -a_relevant_search_dirs-'
#array='a_relevant_search_dirs'
#list_dirs_search="${curr_time_ssubd}/a_relevant_search_dirs" 

# BUG: in any one execution, as long as time_ssubdr's are used, this
# '[[ -f' test _will_always_fail_, bc there isn't a creation of the redq
# file above this section of the script.  Also, the post-processing
# block also will never execute. 

#:;: 'if the a_relevant_search_dirs record file exists and is not a symlink'
#if [[ -f "$list_dirs_search" ]] &&
  #[[ ! -L "$list_dirs_search" ]];
#then
  #:;: 'Keep existing data'
  #:; fn_age_file "${list_dirs_search}".bak
  #:; fn_bak "$list_dirs_search"
  #:;: 'For whether or not to do the full scan of a_relevant_search_dirs'
    #: 'get the hash of the prior array'
    #hash_old_a="$( md5sum "$list_dirs_search" )"
    #:;: 'get the prior count of indices'
    ## shellcheck disable=SC1090
    #source "$list_dirs_search"
    #array_count_old_a="$( fn_num a_relevant_search_dirs )"
    ##unset a_relevant_search_dirs
#fi

:;: 'in any event, create a new record for a_relevant_search_dirs and...'
mapfile -d '' -t a_relevant_search_dirs < <(
  sudo find / -mindepth 1 -maxdepth 1 -type d \! -empty \
    \( \! -name proc -a \! -name sys -a \! -iname 'scf*' \) \
    -print0 2> /dev/null )
#export a_relevant_search_dirs
:; fn_write_arrays a_relevant_search_dirs

#:;: 'if the pre-processing block ran, then exec this block also'
#if [[ -v array_count_old_a ]]; then 
  #: '<>: variable -array_count_old_a- exists'
  #:;: 'these newer files were written just milliseconds ago'
  #:; fn_age_file "${list_dirs_search}".bak
  #:; fn_bak "$list_dirs_search"
  #:;: 'For whether or not to run -find- for the a_all_files array'
    #: 'get the hash of the new array' 
    #hash_new_a="$( md5sum "$list_dirs_search" )"
    #:;: 'get the new count of indices, and do some comparisons'
    #array_count_new_a="$( fn_num a_relevant_search_dirs )"
    #if [[ "${hash_old_a%% *}" != "${hash_new_a%% *}" ]] ||
      #[[ "$array_count_old_a" != "$array_count_new_a" ]]; 
    #then 
      #must_find_all_files='y'
    #fi
#fi
  
#:;: 'Variables for -a_all_files-'
#unset array list_files_all hash_old_b hash_new_b array_count_old_b array_count_new_b
#array='a_all_files'
#list_files_all="${curr_time_ssubd}/a_all_files"

# BUG: also. this block will never execute

#:;: 'if the record for a_all_files exists and isnt a symlink'
#if [[ -f "$list_files_all" ]] &&
  #[[ ! -L "$list_files_all" ]];
#then
  #:;: 'Keep existing data'
  #:; fn_age_file "${list_files_all}".bak
  #:; fn_bak "$list_files_all"
  #:;: 'For whether or not to do the full scan of a_relevant_search_dirs'
    #: 'get the hash of the prior array'
    #hash_old_b="$( md5sum "$list_files_all" )"
    #:;: 'get the prior count of indices'
    #: 'set -; source -list_files_all-'; 
    #set -
    #source "$list_files_all"
    #set -x
    #array_count_old_b="$( fn_num a_all_files )"
    ##unset a_all_files
  #:;: 'For whether or not to run -find- for the a_all_files array'
  #if [[ "$must_find_all_files" != 'y' ]]; then
    #:;: 'get byte count of record file'
    #byte_count="$( wc -c "$list_files_all" )"
    #[[ "${byte_count%% *}" -lt 500 ]] && 
      #must_find_all_files='y'
    #:;: 'get delta of mtime to now'
    #mtime_age_in_hours=$(( $(( $( date +%s ) - \
      #$( stat -c%Y "$list_files_all" ) )) / 60 / 60 ))
    #[[ "$mtime_age_in_hours" -gt 72 ]] &&
      #must_find_all_files='y'
  #fi
#fi

:;: 'If we must run -find- for a_all_files.'
if [[ ! -v a_all_files ]]; then
  #|| [[ "$must_find_all_files" = 'y' ]]
  
    : '<>'
    date
    a_relevant_search_dirs=( /usr/sbin )
    #a_relevant_search_dirs=( /usr/sbin /usr/bin )
    #a_relevant_search_dirs=( /usr/sbin /usr/bin /etc )
    #a_relevant_search_dirs=( /usr/sbin /usr/bin /etc /var )
  
  :;: 'Find all relevant files on disk.'
  mapfile -d '' -t a_all_files < <( 
    sudo find "${a_relevant_search_dirs[@]}" -mindepth 1 -type f -print0 \
      2> /dev/null )
  #export a_all_files 
  :; fn_write_arrays a_all_files
  
  #:;: 'these newer files were written just milliseconds ago'
  #:; fn_age_file "${list_files_all}".bak # AJAX
  #:; fn_bak "$list_files_all"
fi

# BUG: and neither will this block.

#:;: 'For whether or not to do the full scan for a_all_files'
#if [[ -v hash_old_b ]]; then
  #: '<>: variable -hash_old_b- exists'
  #:;: 'get the hash of the new array'
  #hash_new_b="$( md5sum "$list_files_all" )"
  #:;: 'get the prior count of indices; this array was re-assigned'
  #: 'a few milliseconds ago'
  #array_count_new_b="$( fn_num a_all_files )"
  #:;: 'Do the comparisons' 
  #if [[ "${hash_old_b%% *}" != "${hash_new_b%% *}" ]] ||
    #[[ "$array_count_old_b" != "$array_count_new_b" ]]; 
  #then 
    # BUG: as of yet unused variable
    #must_scan_relevant_dirs='y'
  #fi
#fi

:;: 'Sort the original array and test it.'
  : '<>'
  set -; 

#printf 'printf -a_all_files_sorted- array\n'
mapfile -d '' -t a_all_files_sorted < <(
  printf '%s\0' "${a_all_files[@]}" |
    sort --zero-terminated )

  : '<>'
  set -x; 
  : 'set -x'

:;: 'Do the second comparison.' 
[[ "$( fn_num a_all_files )" -eq "$( fn_num a_all_files_sorted )" ]] ||
  fn_erx "${LINENO}"

  # <> 
  #:; fn_write_vars 'B' array_count_new_a array_count_new_b array_count_old_a array_count_old_b byte_count hash_new_a hash_new_b hash_old_a hash_old_b list_dirs_search list_files_all mtime_age_in_hours must_find_all_files

  #:; fn_write_arrays a_all_files a_all_files_sorted a_relevant_search_dirs

  #: '<>'
  #exit "$LINENO"
  #set -x


###  SECTION c  ::  SCANNING  ###

# Bug? Can more indices and fewer files be used?

:;: 'Add some brevity, and write the completed arrays to disk'
count="${#a_all_files_sorted[@]}"
unset IFS

  :;: '<>'
  [[ -f /tmp/"${list_crunchbangs##*/}" ]] &&
    fn_age_file /tmp/"${list_crunchbangs##*/}"

:;: 'if the full list exists (of files on disk which begin with crash-'
:   ' bangs), then skip the 30-90 minute search phase.'
if [[ ! -f /tmp/"${list_crunchbangs##*/}" ]] || 
  [[ -L /tmp/"${list_crunchbangs##*/}" ]]; 
then
  
#fn_scan_local_disks(){
  #: 'fn_scan_local_disks'
  :;: 'fn_scan_local_disks: Sort out the scripts, ie, any file beginning' 
  :   'with a crashbang from the rest of the files'
  #   Note: this function can take 30-90 minutes!
  for all_files_index in "${!a_all_files_sorted[@]}"; do

    :;: 'fn_scan_local_disks: LOOP';:
    printf '%d of %d files\r' "$all_files_index" "$count"
    #unset each_sorted_f leftover_words_b od_o{0,1} first_line 
    each_sorted_f="${a_all_files_sorted[${all_files_index}]}"
    
    # BUG: the arrays and vars are messy; clean up the lists.

    :;: 'fn_scan_local_disks: each_sorted_f must exist'
    if [[ ! -e "$each_sorted_f" ]]; then
      set -x
      a_file_DNE+=( "$each_sorted_f" )
      #unset 'a_all_files_sorted[$all_files_index]'
      continue
      set -
    fi

    # TODO: check for empty files, make a list of them

    :;: 'fn_scan_local_disks: run -file- on each each_sorted_f'
    { 
      printf '+ %-8d: ' "$all_files_index"; 
      sudo file -pk "$each_sorted_f";
    } | 
      tee -a "${curr_time_ssubd}/file_out"
 
      # Bug: avoid as many disk writes as possible. 
      # Bug: use indices to reference each type? 
      #    RO all files array? 

    :;: 'fn_scan_local_disks: Read from disk in binary the first two bytes' 
    :   'of each each_sorted_f in the list and output it in hexadecimal.'
    #   Note: inordinately long interpreter paths are rare, but do occur.
    #   Note: `od` command is POSIX compliant
    read -r leftover_words_b byte_0 byte_1 leftover_words_b < <( 
      sudo od -j 0 -N 2 -t x1z -v "$each_sorted_f" || 
        fn_erx "$LINENO" "$all_files_index" "$each_sorted_f" )
    export leftover_words_b # SC2034
    
    :;: 'fn_scan_local_disks: If -od_o- contains some non-zero data, as it'
    :   ' should,'
    if [[ -z "$byte_0" ]]; then
      fn_erx "L:$LINENO I:$all_files_index <${each_sorted_f}>" '*theoretically unreachable code*';

    :;: 'fn_scan_local_disks: compare the hexidecimal representations to' 
    :   'find any crashbangs.'
    elif [[ "${byte_0}${byte_1}" == @(2321|2123) ]]; then

      :;: 'fn_scan_local_disks: Issue: a big endian file format, possibly'
      :   ' a DB file, etc.'
      if [[ "${byte_0}${byte_1}" == '2123' ]]; then
        a_incorrect_endianness+=( [$all_files_index]="$each_sorted_f" )
        #unset 'a_all_files_sorted[$all_files_index]'

      # BUG: expect non-printable characters

      :;: 'fn_scan_local_disks: Crunchbang found. Use -read-, and hope'
      :   'there won-t be any non-printable characters.'
      else
        IFS= read -r first_line < "$each_sorted_f" ||
          fn_erx "$LINENO" "$all_files_index" "$each_sorted_f";

        :;: 'fn_scan_local_disks: Issue: the files with -#!comment- as the'
        :   'initial bytes. These aren-t scripts, so restart the loop.'
        if [[ "$first_line" =~ ^'#!comment' ]]; then
          a_crunches_with_hashbang_comments+=( [${all_files_index}]="$each_sorted_f" )
          #unset 'a_all_files_sorted[$all_files_index]'
          continue
        fi

        :;: 'fn_scan_local_disks: Issue: crashbang files which originate'
        :   'outside of the rpm package manager'
        #   Note: with only /bin/sbin, this if-fi block doesn't execute
        if ! rpm -qf "$each_sorted_f" 2> /dev/null 1>&2; then

          :;: 'fn_scan_local_disks: user and system files from outside -rpm-'
          if [[ "$each_sorted_f" = /@(root|home|run/media)/* ]]; then
            a_non_rpm_user_crunches+=( [${all_files_index}]="$each_sorted_f" )
            #unset 'a_all_files_sorted[$all_files_index]'
            continue

          else
            a_non_rpm_system_crunches+=( [${all_files_index}]="$each_sorted_f" )
            #unset 'a_all_files_sorted[$all_files_index]'
            continue
          fi
        fi
      fi
      
      :;: 'fn_scan_local_disks: Make a record in RAM of the relevant'
      :   'filenames and their crashbangs.'
      a_shell_scripts+=( [$all_files_index]="$( \
        printf '%-50s   %% %% %% %%   %s\n' "$first_line" "$each_sorted_f" )" )
      #unset 'a_all_files_sorted[$all_files_index]'

    else
      a_all_other_files+=( [$all_files_index]="$each_sorted_f" )
      #unset 'a_all_files_sorted[$all_files_index]'
    fi
  done
  
  :;: '<>'

  :; fn_bak "${curr_time_ssubd}"/file_out
  #: 'END OF fn_scan_local_disks';:
#}
  #:; fn_scan_local_disks

#fn_createdatafile(){
  #: 'fn_createdatafile'
  :;: 'fn_createdatafile: Open a timestamped file & append into it the list' 
  :   ' of filenames and their crashbangs.' 

  :;: Exporting is necessary of the array names from the above scan 
  export a_all_files_sorted a_file_DNE a_incorrect_endianness  a_crunches_with_hashbang_comments a_non_rpm_user_crunches a_non_rpm_system_crunches a_shell_scripts a_all_other_files a_relevant_search_dirs
  #declare -p a_all_files_sorted a_file_DNE a_incorrect_endianness  a_crunches_with_hashbang_comments a_non_rpm_user_crunches a_non_rpm_system_crunches a_shell_scripts a_all_other_files a_relevant_search_dirs
  #exit "$LINENO"
  
  :;: 'fn_createdatafile: data files'
  a_write_path_nms=( "${list_crunchbangs:=crunchbangs}" /tmp/"${list_crunchbangs##*/}" )
 
    :;: '<>'
    declare -p a_write_path_nms a_shell_scripts

  :;: 'fn_createdatafile: if any data files already exist, keep them'
  for any_existing_f in "${a_write_path_nms[@]}"; do
    if [[ -f "$any_existing_f" ]] && [[ ! -L "$any_existing_f" ]]; then
      mv "$any_existing_f" "${any_existing_f}.${$}.${random_n}" ||
        fn_erx "$LINENO"
    fi
  done

  :;: fn_createdatafile: create the original list_crunchbangs
  touch "${a_write_path_nms[@]}"

  :;: fn_createdatafile: header
  { printf '# crunchbangs -- %s\n' "${timecode%-*}" 
    printf '# %s\n' "$( declare -p a_relevant_search_dirs )" 
  } | 
    tee --output-error='exit' "${a_write_path_nms[@]}"
  
  :;: fn_createdatafile: printing contents of a_shell_scripts array
  #set -
  printf '%s\n' "${a_shell_scripts[@]}" |
    tee --append --output-error=exit "${a_write_path_nms[@]}"
  #set -x
  :; fn_bak "${a_write_path_nms[@]}"
  #: 'END OF fn_createdatafile';:
#}
  #:; fn_createdatafile
fi

  # <>
  #:; fn_write_arrays a_shell_scripts a_crunches_with_hashbang_comments \
    #a_all_other_files a_incorrect_endianness \
    #a_non_rpm_system_crunches a_non_rpm_user_crunches 
  #:; fn_write_vars 'C' each_sorted_f list_crunchbangs all_files_index od_o{0,1} X first_line count

  : '<>'
  #exit "$LINENO"
  #set -x

    
###  SECTION d  ###    

# Make the data readable and useable.

:;: 'CENTRAL TASK, 1 OF 2: Filter the list of crashbangs with the list' 
:   '  of shells.'

:;: central task 1 of 2: header
{ printf '# SC-scrpts-list -- %s\n' "${timecode%-*}" 
  printf '# %s\n' "$( declare -p a_relevant_search_dirs )" 
} | 
  tee --output-error='exit' "${list_crunchbangs}_SC-scrpts-list"
  
grep --extended-regexp '/bin/'"${shells}"'.*% % % %' \
  "${list_crunchbangs}" > "${list_crunchbangs}_SC-scrpts-list" ||
    fn_erx "$LINENO"
rsync -ca "${list_crunchbangs}_SC-scrpts-list" /tmp ||
  fn_erx "$LINENO"
:; fn_bak "${list_crunchbangs}_SC-scrpts-list" /tmp/*_SC-scrpts-list

  : '<>'
  ls -l "${list_crunchbangs}"*
  wc "${list_crunchbangs}"*
  exit "$LINENO"
  #set -x

:;: 'MAIN TASK, 2 of 2: with ShellCheck scan each script for errors'
  
:;: 'A hell world of pipelines:'
# Bug? line 1 of script could contain percent symbols
mapfile -d '' -t a_each_abspath_scriptnm < <( 
  cut -d '%' -f5- "${list_crunchbangs}_SC-scrpts-list" | 
    sed 's,^ *,,' | 
    tr '\n' '\0' )
  # awk , multi-char delim, remv lead+trail wspc - redef $0 ?, printf
  # grep -Eo | tr

  : '<>'
  #exit "$LINENO"
  set -x

# Bug: rename variable "$c" below

# why sort by line count? More text, more bugs? How to prior mult factrs
mapfile -t a_each_script_list_sorted < <( 
  for c in "${a_each_abspath_scriptnm[@]}"; do 
    wc -l "$c"; 
  done | 
    sort -gr | 
    awk '{ print $2 }' )

  : '<>'
  exit "$LINENO"
  set -x

iterator_2=0; 
{
  for sorted_script in "${!a_each_script_list_sorted[@]}"; do 
    #unset a_each_script_SC_results;
    # Bug? 1st grep extra?
    mapfile -d '' -t a_each_script_SC_results < <( 
      shellcheck -S "$severity" \
          "${a_each_script_list_sorted[$sorted_script]}" | 
        grep --fixed-strings --invert-match 'shellcheck.net' | 
        grep --extended-regexp -o "SC[0-9a-zA-Z\ \t():,.'-$&#\!]*" | 
        cut -b -64 | 
        sort --general-numeric-sort | 
        uniq --count ; printf '\0' ); 
    if [[ -n "${a_each_script_SC_results[*]:0:1}" ]]; then 
      printf '\n%-4d%s\n' $((iterator_2++)) "${a_each_script_list_sorted[$sorted_script]}"; 
      printf '%s' "${a_each_script_SC_results[@]}"; 
    fi; 
  done;
} | tee -a "${list_crunchbangs}_found_scripts_with_indices"

  : '<>'
  exit "$LINENO"
  set -x

:; fn_bak "${list_crunchbangs}_found_scripts_with_indices"

:;: 'Write semi-permanent archives'
rsync -ca "${list_crunchbangs}_found_scripts_with_indices" "$main_d" ||
  fn_erx "$LINENO"
rsync -ca "${list_crunchbangs}_found_scripts_with_indices" /tmp ||
  fn_erx "$LINENO"

  :;: '<>'
  :; fn_write_vars 'D' all_files_index any_existing_f byte_0 byte_1 count each_sorted_f first_line iterator_1 iterator_2 leftover_words_b sorted_script loc_aging_hash_new loc_aging_mtime loc_dir_a loc_exit_code loc_filename_a loc_nameref loc_prevsly_aged loc_script_section_nm loc_unquotd_array_nm_a loc_unquotd_array_nm_b loc_write_f_a loc_write_f_b
  :; fn_write_arrays a_all_other_files a_crunches_with_hashbang_comments a_each_script_abs_path_nm a_each_script_list_sorted a_each_script_SC_results a_file_DNE a_incorrect_endianness a_non_rpm_system_crunches a_non_rpm_user_crunches a_shell_scripts a_write_path_nms loc_A_hashes_prev_files loc_a_previous_aged_files

exit "$LINENO"


# scan 'a_all_other_files' for anything that isn't an ELF file
# . /run/media/*/*/scf.d/latest_data/t_*/a_all_other_files
# for f in "${a_all_other_files[@]}"; do sudo file -pk "$f" | grep -v 'ELF 64-bit LSB '; done

# scan 'a_all_files_sorted' for proper sorting
# . /run/media/*/*/scf.d/latest_data/t_*/a_all_files_sorted
# fn_num a_all_files_sorted
# sudo command -p printf '' | sudo tee ./a_all_files_sorted_printed; for g in "${a_all_files_sorted[@]}"; do sudo -p command printf '%s\n' "$g" | sudo tee -a ./a_all_files_sorted_printed ; done


# check 'file_out' for anything odd
# grep -v 'ELF 64-bit' ./scf.d/latest_data/t_2023-04-03_084130/file_out | grep 'read permission'
# grep -v 'ELF 64-bit' ./scf.d/latest_data/t_2023-04-03_084130/file_out | grep -v 'read permission' | grep -v 'script text exec'

# 
