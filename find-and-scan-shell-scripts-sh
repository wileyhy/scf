#!/bin/bash
# find-and-scan-shell-scripts-sh
# Written in bash version 5.1 on Fedora 37


# SECTION A

:;: 'Implementation-dependent arguments for opts parsable by -shellcheck-'
severity=error
# shellcheck disable=SC2034
shells='(sh|bash|dash|ksh)'


:;: Environment variables
#   Note: -bash- doesnt decend subdirs of PATH
#   Note: if executed by a restricted shell, this assignment to PATH will 
# fail with an error message, and will ignore all of the rest of the 
# commands on same script line as the PATH assignment.    
unset LC_ALL
LC_COLLATE="C.UTF-8" # for predictable `sort`ing
LC_CTYPE="C.UTF-8"   # "   "            "
LC_NUMERIC="en_US.UTF-8" # for commas
PATH="$( /usr/bin/command -p getconf PATH ):/usr/bin:/usr/sbin:${PATH}" ||
  exit "$LINENO"
export LC_COLLATE LC_CTYPE LC_NUMERIC PATH


:;: Functions
fn_age_file(){
  : fn_age_file

    :;: '<> ===== BUG? ===== sb   [[ ! -f   ???'
    [[ -f "$1" ]] ||
      return 1

  local -A loc_A_hashes_prev_files
  mapfile -d '' -t loc_a_previous_aged_files < <( 
    find "${1%/*}" -type f -regextype egrep \
      -regex ".*/${1##*/}\.([0-9]){10}" -print0 2> /dev/null ) 

  # if the new hash is already present in the assoc
  # array, then the new file is a dup
  for loc_prevsly_aged in "${loc_a_previous_aged_files[@]}"; do 
    
    if [[ -f "$loc_prevsly_aged" ]]; then
      
      loc_A_hashes_prev_files["$( 
        md5sum "$loc_prevsly_aged" | 
          cut -d ' ' -f1 )"]="$loc_prevsly_aged" 
      
      loc_aging_hash_new="$( 
        md5sum "$1" | 
          cut -d ' ' -f1 )"
      
      [[ -n "${loc_A_hashes_prev_files["$loc_aging_hash_new"]}" ]] && 
        : 'END OF fn_age_file';:
        return 0
    fi
  done

  loc_aging_mtime="$( stat -c%Y "$1" )"
  mv "$1" "${1}.${loc_aging_mtime}" ||
    fn_erx _age_file "$1"
  : 'END OF fn_age_file';:
}
fn_bak(){
  # test verifying existence of input
  : fn_bak
  
  for loc_filename_a in "$@"; do 
    
    if [[ -f "$loc_filename_a" ]]; then 
      rsync -acq "${loc_filename_a}"{,.bak} ||
        fn_erx "$LINENO"
    else
      fn_erx "$LINENO" file DNE "$loc_filename_a" 
    fi
  done
  : 'END OF fn_bak';:
}
fn_erx(){
  local loc_exit_code=$? # this assignment must be the first command
  : fn_erx
  echo -e Error: "$@" 
  : 'END OF fn_erx';:
  exit $loc_exit_code
}
fn_num(){ 
  : fn_num
  for loc_unquotd_array_nm_a in "$@"; do
    local -n loc_nameref="$loc_unquotd_array_nm_a" 
    echo ${#loc_nameref[@]}
  done
  : 'END OF fn_num';:
}
fn_usage(){
  # Usage:  fn_usage [exit-code]
  : fn_usage
  cat <<-EOF
    
    SCF - Shell Check Find, version 1.0 (for redhat-linux)
    Find and scan shell scripts depending on severity level. 
        Usage:  ./find-and-scan-shell-scripts-sh [-ehiw]
                -e error          -i info
                -h help           -w warning
    Only the first option is processed.

EOF
  : 'END OF fn_usage';:
  # shellcheck disable=SC2086
  exit $1
}
fn_write_arrays(){
  : fn_write_arrays
  # Usage: fn_write_arrays [arrays]
  # Note: Default directory is -curr_time_ssubd-.

  :;: fn_write_arrays: Write each array to disk.
  #   Note: `tee` without -a will overwrite an existing file
  for loc_unquotd_array_nm_b in "$@"; do 
    loc_write_f_b="${curr_time_ssubd}/${loc_unquotd_array_nm_b}"

    # BUG: mixing variable and array. sb a nameref

    if [[ -v "$loc_unquotd_array_nm_b" ]]; then
      
      declare -p "$loc_unquotd_array_nm_b" | 
        tee --output-error='exit' "$loc_write_f_b" > /dev/null
    else
      fn_erx $LINENO, variable "$loc_unquotd_array_nm_b" DNE
    fi
    :; fn_bak "$loc_write_f_b"
  done
  : 'END OF fn_write_arrays';:
}
fn_write_vars(){
  # Usage: fn_write_vars [loc_script_section_nm] [raw variable names]
  : fn_write_vars
  #local loc_script_section_nm loc_write_f_a
  loc_script_section_nm="$1"
  loc_write_f_a="${curr_time_ssubd}/${loc_script_section_nm}_vars"
  shift
  [[ -e "$loc_write_f_a" ]] &&
    fn_age_file "$loc_write_f_a"
  declare -p "$@" 2> /dev/null |
    tee --output-error=exit "$loc_write_f_a" > /dev/null
  :; fn_bak "$loc_write_f_a"
  #declare -p loc_script_section_nm loc_write_f_a 
  : END OF fn_write_vars;:
}
# List of functions
# fn_age_file fn_bak fn_erx fn_num fn_usage fn_write_arrays fn_write_vars


:;: Option parsing
if [[ $# -gt 0 ]]; then
  cli_input="${1:0:2}"

  # shellcheck disable=SC2034
  case "$cli_input" in
    --) printf 0a09486170707920456173746572210a0a | 
          xxd -r -p
        exit 0;;
    -e) severity=error;;
    -i) severity=info;;
    -v) printf 0a09224920776f756c642068617665206d61646520746869732073686f727465722c206275742049206469646e27742068617665207468652074696d652e220a09092d2d204d61726b20547761696e0a0a |
          xxd -r -p
        exit 0;;
    -w) severity=warning;;
    -h) :; fn_usage 0;;
    *)  :; fn_usage 1;;
  esac
fi


:;: Use -sudo-
if ! sudo -v; then
  printf '\n\tValidation failed of user\x27s \x60sudo\x60 timestamp; ' 
  printf 'exiting.\n\n' 
  exit $LINENO
fi


:;: Process lock
random_n=$RANDOM
proc_lk_f_nm=".$$.${random_n}.lock"
a_poss_proces_lock_dirs=( [0]="$XDG_RUNTIME_DIR" [1]="$HOME" 
  [2]="$TMPDIR" [3]=/tmp [4]=/var/tmp )

for poss_lk_d in "${a_poss_proces_lock_dirs[@]}"; do 
  
  if [[ -d "$poss_lk_d" ]]; then
    process_lock="${poss_lk_d}/${proc_lk_f_nm}"
    break
  fi
done

# shellcheck disable=SC2154
trap '
  
  for poss_lk_d in "${a_poss_proces_lock_dirs[@]}"; do 
    proclock="${poss_lk_d}/${proc_lk_f_nm}"
    
    if [[ -d "$proclock" ]] && [[ ! -L "$proclock" ]]; then 
      rm -rf -- "$proclock"
    fi
  done

  # Remove this script-s ACL-s
  if [[ -v acl_execd_setfacl ]]; then 
    
    if [[ -v acl_abs_path ]]; then 
      sudo setfacl -R -x u:$UID "$acl_abs_path" ||
        echo Error: setfacl failed, line $LINENO
    
    elif [[ -v mountpoint ]]; then
      sudo setfacl -R -x u:$UID "$mountpoint" ||
        echo Error: setfacl failed, line $LINENO
    fi
  fi

  trap - EXIT TERM INT
  kill -s INT $$
' EXIT TERM INT 

if ! mkdir "$process_lock" 2> /dev/null; then
  { 
    printf '\n\tCannot acquire process lock: <%s>.\n' "$process_lock"
    printf '\tID: %s\n' "$USER"
    printf 'Exiting.\n\n' 
  } 1>&2
  exit $LINENO
fi


:;: User variables
fstype_list='btrfs,exfat,ext3,ext4,fat32,ntfs,xfs'
timecode="$( builtin printf '%(%F_%H%M%S)T' )"

# List of variables, global scope
# LC_ALL LC_COLLATE PATH all_files_index any_existing_f array_count_new_a 
# array_count_new_b array_count_old_a array_count_old_b acl_abs_path 
# byte_0 byte_1 byte_count cli_input curr_time_ssubd count data_subd 
# device acl_each_dir each_sorted_f acl_execd_setfacl filesystem_type 
# first_line fstype_list hash_new_a hash_new_b hash_old_a hash_old_b 
# iterator_1 iterator_2 leftover_words_a leftover_words_b list_crunchbangs 
# list_dirs_search list_files_all main_d mountpoint mtime_age_in_hours 
# must_find_all_files must_scan_relevant_dirs prev_time_ssubd process_lock 
# random_n severity shells sorted_script subd_x timecode

# List of variables, local scope
# loc_aging_hash_new loc_aging_mtime loc_exit_code loc_filename_a 
# loc_nameref loc_prevsly_aged loc_script_section_nm 
# loc_unquotd_array_nm_a loc_unquotd_array_nm_b loc_write_f_a 
# loc_write_f_b

# List of arrays, global scope
# a_acl_name_indiv_dir a_all_files a_all_files_sorted a_all_other_files 
# a_crunches_with_hashbang_comments a_each_abspath_scriptnm 
# a_each_script_list_sorted a_each_script_SC_results a_file_DNE 
# a_incorrect_endianness a_non_rpm_system_crunches a_non_rpm_user_crunches 
# a_poss_write_devices a_previous_time_dirs a_relevant_search_dirs 
# a_shell_scripts a_write_path_nms

# List of arrays, local scope
# loc_A_hashes_prev_files loc_a_previous_aged_files



# SECTION B

:;: Assign varnames and paths for the data directories
#   Note: In case of large log files, programatically select a save di-
# rectory, attached to the local disk, where any output can be saved; 
# prefer USB flash drives.
# and print any which have both any detected filesystem and no detected
# mountpoint.

# SOLVED? BUG: needs a test for whether or not there are any unmounted
# USB drives. automatically using '/' as mountpoint is, in this case,
# ie, on a live usb, not so good of an idea.

# List all SCSI device (major number 8) partitions (ending with [0-9])
mapfile -t a_maj8s < <( 
  lsblk --ascii --include 8 --noempty --noheadings --paths \
    --output path --list /dev/sd[b-z][0-9] )

I=${#a_maj8s[@]}
for (( i=0; i<I; i++ )); do 

  # Get per-device info on fstype and uuid
  #   shellcheck disable=SC2016
  read -r 'a_fs[$i]' 'a_uu[$i]' < <( 
    sudo wipefs --no-act --output type,uuid --noheadings \
      --types "$fstype_list" "${a_maj8s[$i]}" )

  # Get per-device info on mountpoints
  #   shellcheck disable=SC2016
  read -r 'a_mp[$i]' < <( 
    lsblk --noheadings --output mountpoints "${a_maj8s[$i]}" )

  # of the found SCSI devices, if there is no FS, then disregard it...
  [[ -z "${a_fs[$i]}" ]] && 
    unset 'a_maj8s[$i]'; 
    
  # ...and if there is a mountpoint, also disregard that
  [[ -n "${a_mp[$i]}" ]] && 
    unset 'a_maj8s[$i]'
done

# create some additional arrays for counting existing values
for mp in "${a_mp[@]}"; do [[ -n "$mp" ]] && a_avail_mp+=( "$mp" ); done
for fs in "${a_fs[@]}"; do [[ -n "$fs" ]] && a_avail_fs+=( "$fs" ); done


  #:;: '<>'
  #set -x

# if there arent any available mountpoints, but there are some fs-s
# -OR- if there are some extra fs-s attached which arent mounted
if { 
  [[ ${#a_avail_mp[@]} -eq 0 ]] && [[ ${#a_avail_fs[@]} -gt 0 ]]
    } || 
  [[ ${#a_avail_mp[@]} -lt ${#a_avail_fs[@]} ]]
then
  
  # if there are any partitions left in the 'a_maj8s' array, then...
  # shellcheck disable=SC2154
  if [[ ${#a_maj8s[@]} -gt 0 ]]; then

    # 
    printf '\n\t There are _%d_ SCSI filesystems ' ${#a_avail_mp[@]}
    printf 'mounted and _%d_ additional SCSI \n\t file' ${#a_maj8s[@]} 
    printf 'systems unmounted and available.\n\n'
    printf '\t\t %s \n' "${a_maj8s[@]}"
    printf ' \n'

    # BUG: needs a timeout and a default value. use `read`?

    select mount_exit in Ignore 'Mount all' Exit; do

      case "$mount_exit" in
        Exit)        exit 0;;
        Ignore)      break;;
        'Mount all')

          # mount the found partitions
          # shellcheck disable=SC2068
          for j in ${!a_maj8s[@]}; do 

            # create a mountpoint
            sudo mkdir --parents "${a_mp[$j]}" ||
              fn_erx $LINENO

            # mount the device
            sudo mount -o nosuid,nodev,noexec,rw \
                "${a_maj8s[$j]}" "${a_mp[$j]}" ||
              fn_erx $LINENO
            
            # update the lists
            a_mp+=(       [j]="/run/media/${USER}/${a_uu[j]}" )
          done
          break
          ;;
        *) fn_erx $LINENO '*Unreachable code*'
      esac
    done
  fi
elif [[ ${#a_avail_mp[@]} -eq ${#a_avail_fs[@]} ]]; then
  true
else
  fn_erx $LINENO '*Unreachable code*'
fi


  #:;: '<>' 
  #set -x
  #declare -p a_mp a_avail_mp
  #exit "$LINENO"

# Bug: maintenance issue! Compound command

# prevent the FS root / from becoming the mountpoint
mountpoint="$( 
  for m in "${a_avail_mp[@]}"; do 
      sudo findmnt --ascii --bytes --canonicalize --df --list \
          --types "$fstype_list" --noheadings --notruncate --nofsroot \
          --output maj:min,avail,target --mountpoint "$m"
  done | 
    sort -rnk2 | 
    awk 'NR==1 { print $3 }' )"

  #exit "$LINENO"


[[ -n "$mountpoint" ]] ||
  fn_erx $LINENO
main_d="${mountpoint}/scf.d"
data_subd="${main_d}/latest_data"
curr_time_ssubd="${data_subd}/t_${timecode}"
list_crunchbangs="${curr_time_ssubd}/crunchbangs"
read -r filesystem_type device < <( 
  sudo findmnt --ascii --bytes --canonicalize --df --list \
    --types "$fstype_list" --noheadings --notruncate --nofsroot \
    --output fstype,source --mountpoint "$mountpoint" )
umask 077

:;: 'reduce use of -sudo- in this script by setting up ACLs'
case "$filesystem_type" in
  xfs)      true;;
  ext[2-4])   tune2fs -l "$device" | 
                grep -i acl
              fn_erx $LINENO TODO;;
  *)          fn_erx $LINENO TODO;;
esac
  
:;: on XFS
# Nearly all of the `sudo` commands below are allowing rw access, of
# this script's data_subd, so simply using ACL's will reduce the overuse
# of `sudo`. This section takes the "$mountpoint" variable, portions
# each subdirectory name into an array index, and tests each subdi-
# rectory from the FS root up for readability by the user running
# this script (ie, a regular user). As the absolute path is recon-
# structed, when a non-readable directory is found, a recursive "r-x"
# ACL is written, and then a recursive "rwx" is written for the
# "$main_d".
if [[ ! -r "$main_d" ]]; then
  
  mapfile -d / -t a_acl_name_indiv_dir <<< "$mountpoint"; 
  a_acl_name_indiv_dir[0]=/
  a_acl_name_indiv_dir[-1]="${a_acl_name_indiv_dir[-1]//$'\n'}"
  acl_each_dir=${#a_acl_name_indiv_dir[@]}
  
  for (( iterator_1=0; iterator_1<acl_each_dir; iterator_1++ )); do 
    acl_abs_path+="/${a_acl_name_indiv_dir[iterator_1]}"
    acl_abs_path="$( realpath -e "$acl_abs_path" )"
    
    if [[ ! -r "$acl_abs_path" ]]; then 
      sudo mkdir --parents "$main_d" ||
        fn_erx $LINENO
      
      acl_execd_setfacl=y
      export acl_execd_setfacl # SC2034, while trap-s setfacl blk is #-d
      
      if ! sudo setfacl -R -m "$USER":r-x "$acl_abs_path"; then
        fn_erx setfacl failed, acl_abs_path: "$acl_abs_path"
      
      elif ! sudo setfacl -R -m "$USER":rwx "${main_d%/*}"; then
        fn_erx setfacl failed, '\x24{maind%/*}:' "${main_d%/*}"
      fi
    fi 
  done 
fi

:;: make sure -data_subd- is a directory OR create the -data_subd- dir 
:   if necessary
[[ -d "$data_subd" ]] ||
  mkdir "$data_subd"

:;: Label the current data as -latest.-
#   Note: `find` sees dirs and symlinks as separate things 
mapfile -d '' -t a_previous_time_dirs < <( 
  find "${data_subd}" -mindepth 1 -maxdepth 1 -type d -a \! -type l \
    -name 't_*' -print0 )

:;: if -prev_time_ssubd- is empty, delete it, otherwise -mv- it out
:    of the -latest- dir
for prev_time_ssubd in "${a_previous_time_dirs[@]}"; do 
  rmdir --ignore-fail-on-non-empty "$prev_time_ssubd"

  : of previous prev_time_ssubd 
  #   Note: with `test`, dirs and symlinks can refer to the same inode
  if [[ -d "$prev_time_ssubd" ]] && [[ ! -L "$prev_time_ssubd" ]]; then
    mv "${a_previous_time_dirs[@]}" "$main_d"
  else
    continue
  fi
done

: of curr_time_ssubd
if [[ ! -d "${curr_time_ssubd}" ]]; then
  mkdir "$curr_time_ssubd" ||
    fn_erx $LINENO
fi


# SECTION C

# BUG:  Reduce Search Time

:;: Gather filenames from local attached disk storage

#   Note: earlier work: If a prior record of the relevant_search_dirs 
# array exists, and if that prior record matches the new record, then 
# it's possible the all_files list would be the same, too. So if the new 
# relevant_search_dirs list is new, then do the full all_files search 
# again. But if they're the same, then ...

:;: 'in any event, create a new record for a_relevant_search_dirs and..'
mapfile -d '' -t a_relevant_search_dirs < <(
  sudo find / -mindepth 1 -maxdepth 1 -type d \! -empty \
    \( \! -name proc -a \! -name sys -a \! -iname 'scf*' \) \
    -print0 2> /dev/null )
:; fn_write_arrays a_relevant_search_dirs

:;: If we must run -find- for a_all_files.
#if [[ ! -v a_all_files ]]; then
  
    : '<>'
    #   Note: GNU -find- by default will not search symlinks from CLI,
    #     ie, /bin or /sbin
    #a_relevant_search_dirs=( /usr/sbin )
    a_relevant_search_dirs=( /usr/sbin /usr/bin )

  :;: Find all files on disk. Even the empty ones.
  
  mapfile -d '' -t a_all_files < <( 
    sudo find "${a_relevant_search_dirs[@]}" -mindepth 1 -type f \
      -print0 2> /dev/null )
  
  :; fn_write_arrays a_all_files
#fi

:;: 'Sort the original array and test it.'
mapfile -d '' -t a_all_files_sorted < <(
  printf '%s\0' "${a_all_files[@]}" |
    sort --zero-terminated )
  
:; fn_write_arrays a_all_files_sorted


:;: Do the comparison. 
[[ $( fn_num a_all_files ) -eq $( fn_num a_all_files_sorted ) ]] ||
  fn_erx $LINENO


# SECTION D

# Bug? Can more indices and fewer files be used?

:;: Add some brevity, and write the completed arrays to disk
# shellcheck disable=SC2034
total_count="$( printf "%'d" "${#a_all_files_sorted[@]}" )"
unset IFS

# get the most recent tx number from `dnf history`
#dnf_history_number="$( 
  #dnf history info 0 | 
    #awk '/^Transaction ID/ { print $4 }' ||
      #_erx "${LINENO}" )"

  #set -x
  :;: '<>'
  [[ -f /tmp/"${list_crunchbangs##*/}" ]] &&
    fn_age_file "/tmp/${list_crunchbangs##*/}"

# tests tmp file

:;: if the full list exists -- of files on disk which begin with crash-
:    bangs -- skip the 30-90 minute search phase.
if [[ ! -f "/tmp/${list_crunchbangs##*/}" ]] || 
  [[ -L "/tmp/${list_crunchbangs##*/}" ]]; 
then

  #   Note: this loop can take 30-90 minutes!

  :;: Sort out the scripts, ie, any file beginning 
  :   with a crashbang from the rest of the files
  for all_files_index in "${!a_all_files_sorted[@]}"; do

    :;: Loop progress meter;:
    count_this_loop="$( printf "%'d" $(( all_files_index + 1 )) )"
    printf '%s of %s files\r' "$count_this_loop" "$total_count"

    :;: each_sorted_f must exist
    each_sorted_f="${a_all_files_sorted[${all_files_index}]}"
    
    if [[ ! -e "$each_sorted_f" ]]; then
      a_file_DNE+=( "$each_sorted_f" )
      continue
    fi

    # TODO: check for empty files, make a list of them

    :;: run -file- on each each_sorted_f
    { printf '+ %-8d: ' "$all_files_index" 
      sudo file -pk "$each_sorted_f"
    } | tee -a "${curr_time_ssubd}/file_out" > /dev/null
 
    # Bug: avoid as many disk writes as possible. 
    # Bug: use indices to reference each type? 
    #    RO all files array? 

    #   Note: inordinately long interpreter paths are rare, but do occur.
    #   Note: `od` command is POSIX compliant
    #   Note: POSIX `od` doesn't have GNU's '--strings' option, so use 
    #     the `strings` command separately.

    :;: 'Read from disk in binary the first two bytes of each' 
    :   'each_sorted_f in the list and output it in hexadecimal.'
    read -r leftover_words_b byte_0 byte_1 leftover_words_b < <( 
      sudo od -j 0 -N 2 -t x1z -v "$each_sorted_f" || 
        fn_erx L:$LINENO I:"$all_files_index" "$each_sorted_f" )
    export leftover_words_b # SC2034
    
    :;: If -od_o- contains some non-zero data, as it should...
    if [[ -z "$byte_0" ]]; then
      fn_erx L:$LINENO I:"$all_files_index" "<${each_sorted_f}>" \
        '*theoretically unreachable code*'

    # compare the hexadecimal representations to
    # find any crashbangs.
    elif [[ "${byte_0}${byte_1}" == @(2321|2123) ]]; then

      :;: Issue: a big endian file format, possibly
      :    a DB file, etc.
      if [[ "${byte_0}${byte_1}" == 2123 ]]; then
        a_incorrect_endianness+=( [all_files_index]="$each_sorted_f" )

      # BUG: expect non-printable characters

      :;: Crunchbang found. Use -read-, and hope
      :   there wont be any non-printable characters.
      else
        IFS= read -r first_line < "$each_sorted_f" ||
          fn_erx L:$LINENO I:"$all_files_index" "$each_sorted_f"

        :;: Issue: the files with -#!comment- as the
        :   initial bytes. These aren-t scripts, so restart the loop.
        if [[ "$first_line" =~ ^'#!comment' ]]; then
          a_crunches_with_hashbang_comments+=( \
            [all_files_index]="$each_sorted_f" )
          continue
        fi

        #   Note: with only /bin/sbin, this if-fi block doesn't execute

        :;: Issue: crashbang files which originate
        :   outside of the rpm package manager
        if ! rpm -qf "$each_sorted_f" 2> /dev/null 1>&2; then

          :;: user and system files from outside -rpm-
          if [[ "$each_sorted_f" = /@(root|home|run/media)/* ]]; then
            a_non_rpm_user_crunches+=( [all_files_index]="$each_sorted_f" )
            continue

          else
            a_non_rpm_system_crunches+=( \
              [all_files_index]="$each_sorted_f" )
            continue
          fi
        fi
      fi
      
      # TODO: Add "$all_files_index" to content of "a_shell_scripts"

      :;: 'Make an array of the relevant filenames and their crashbangs.'
      a_shell_scripts+=( [all_files_index]="$( \
        printf '%-50s   %% %% %% %%   %s\n' "$first_line" \
          "$each_sorted_f" )" )

    else
      a_all_other_files+=( [all_files_index]="$each_sorted_f" )
    fi
  done
  echo # CLI formatting
  
  :; fn_bak "${curr_time_ssubd}/file_out"


  :;: Open a timestamped file and append into it the list
  :    of filenames and their crashbangs.

  :;: Exporting is necessary of the array names from the above scan 
  export a_all_files_sorted a_file_DNE a_incorrect_endianness \
    a_crunches_with_hashbang_comments a_non_rpm_user_crunches \
    a_non_rpm_system_crunches a_shell_scripts a_all_other_files \
    a_relevant_search_dirs
  
  :;: data files
  a_write_path_nms=( "${list_crunchbangs:=crunchbangs}" \
    "/tmp/${list_crunchbangs##*/}" )

  :;: if any data files already exist, keep them
  for any_existing_f in "${a_write_path_nms[@]}"; do
  
    if [[ -f "$any_existing_f" ]] && [[ ! -L "$any_existing_f" ]]; then
      mv "$any_existing_f" "${any_existing_f}.${$}.${random_n}" ||
        fn_erx "$LINENO"
    fi
  done

  :;: create the original list_crunchbangs
  touch "${a_write_path_nms[@]}"

  :;: header
  { printf '# crunchbangs -- %s\n' "${timecode%-*}" 
    printf '# %s\n' "$( declare -p a_relevant_search_dirs )" 
  } | tee --output-error=exit "${a_write_path_nms[@]}" > /dev/null
  
  :;: printing contents of a_shell_scripts array
  printf '%s\n' "${a_shell_scripts[@]}" |
    tee --append --output-error=exit "${a_write_path_nms[@]}" > /dev/null
  
  #set -x
  :; fn_bak "${a_write_path_nms[@]}"
  #set -

else

  # the time_dir needs a copy of the crunchbangs file, also.  copy it in 
  # from the hopefully correct backup in /tmp
  if [[ ! -f "$list_crunchbangs" ]]; then
    rsync -ca "/tmp/${list_crunchbangs##*/}" "$list_crunchbangs" || 
      fn_erx "$LINENO"
  fi
fi

# TODO: verify interpreters

# Do all of the interpreters exist on disk?
#mapfile -d '' -t interpreters < <(
# sudo head "$list_crunchbangs" | 
#   grep ^'#!' | 
#   sed -e 's,#!,,g' -e 's,<.*,,g' -e 's,[[:space:]]*$,,g' -e 's, -.*,,g'| 
#   cat -Aen


# SECTION E

# Make the data readable and useable.

:;: CENTRAL TASK, 1 OF 2: Filter the list of crashbangs with the list
:     of shells.

  #declare -p list_crunchbangs

:;: header
{ printf '# SC-scrpts-list -- %s\n' "${timecode%-*}" 
  printf '# %s\n' "$( declare -p a_relevant_search_dirs )" 
} | tee --output-error=exit "${list_crunchbangs}_SC-scrpts-list" \
  > /dev/null

# pulls from time_dir
grep --extended-regexp '/bin/'"${shells}"'.*% % % %' \
  "$list_crunchbangs" > "${list_crunchbangs}_SC-scrpts-list" ||
    fn_erx $LINENO
rsync -ca "${list_crunchbangs}_SC-scrpts-list" /tmp ||
  fn_erx $LINENO
:; fn_bak "${list_crunchbangs}_SC-scrpts-list" /tmp/*_SC-scrpts-list


:;: MAIN TASK, 2 of 2: with ShellCheck scan each script for errors
  
# TODO: keep "$all_files_index" tracked with content all the way through
# into the "_found_scripts" file

# Bug? line 1 of script could contain percent symbols

:;: A hell world of pipelines
mapfile -d '' -t a_each_abspath_scriptnm < <( 
  cut -d '%' -f5- "${list_crunchbangs}_SC-scrpts-list" | 
    sed 's,^ *,,' | 
    tr '\n' '\0' )
  # Wk: awk , multi-char delim, remv lead+trail wspc - redef $0 ?, printf
  # grep -Eo | tr

# Bug: rename variable "$c" below
# Bug: why sort by line count? More text, more bugs? How to prior mult 
#   factors?

mapfile -t a_each_script_list_sorted_by_linect < <( 
  for c in "${a_each_abspath_scriptnm[@]}"; do 
    wc -l "$c"; 
  done | 
    sort -gr | 
    awk '{ print $2 }' )

# Bug? 1st grep extra?

  :;: '<>'
  #set -x

iterator_2=0
{ for sorted_script in "${!a_each_script_list_sorted_by_linect[@]}"; do     
    mapfile -d '' -t a_each_script_SC_results < <( 
      shellcheck -S "$severity" \
          "${a_each_script_list_sorted_by_linect[$sorted_script]}" | 
        grep --fixed-strings --invert-match 'shellcheck.net' | 
        grep --extended-regexp -o "SC[0-9a-zA-Z\ \t():,.'$&#\!-]*" | 
        cut -b -64 | 
        sort --general-numeric-sort | 
        uniq --count # no pipe intended
        printf '\0' )

      :;: '<>'
      #declare -p a_each_script_SC_results

    if [[ -n "${a_each_script_SC_results[*]:0:1}" ]]; then 
      printf '\n%-4d%s\n' $((iterator_2++)) \
        "${a_each_script_list_sorted_by_linect[$sorted_script]}"
      printf '%s' "${a_each_script_SC_results[@]}"
    fi
  done
} | tee -a "${list_crunchbangs}_found_scripts" > /dev/null

  #exit "$LINENO"

:;: Write semi-permanent archives

:; fn_bak      "${list_crunchbangs}_found_scripts"
rsync -ca "${list_crunchbangs}_found_scripts" "$main_d" || fn_erx $LINENO
rsync -ca "${list_crunchbangs}_found_scripts" /tmp || fn_erx $LINENO
:; fn_age_file "${list_crunchbangs}_found_scripts"

:; fn_bak      "${main_d}/${list_crunchbangs##*/}_found_scripts"
:; fn_age_file "${main_d}/${list_crunchbangs##*/}_found_scripts"

:; fn_bak      "/tmp/${list_crunchbangs##*/}_found_scripts"
:; fn_age_file "/tmp/${list_crunchbangs##*/}_found_scripts"

exit 00



# scan 'a_all_other_files' for anything that isn't an ELF file
# . /run/media/*/*/scf.d/latest_data/t_*/a_all_other_files
# for f in "${a_all_other_files[@]}"; do sudo file -pk "$f" | grep -v 'ELF 64-bit LSB '; done

# scan 'a_all_files_sorted' for proper sorting
# . /run/media/*/*/scf.d/latest_data/t_*/a_all_files_sorted
# fn_num a_all_files_sorted
# sudo command -p printf '' | sudo tee ./a_all_files_sorted_printed; for g in "${a_all_files_sorted[@]}"; do sudo -p command printf '%s\n' "$g" | sudo tee -a ./a_all_files_sorted_printed ; done


# check 'file_out' for anything odd
# grep -v 'ELF 64-bit' ./scf.d/latest_data/t_2023-04-03_084130/file_out | grep 'read permission'
# grep -v 'ELF 64-bit' ./scf.d/latest_data/t_2023-04-03_084130/file_out | grep -v 'read permission' | grep -v 'script text exec'

