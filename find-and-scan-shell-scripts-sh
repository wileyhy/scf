#! /bin/bash
# find-and-scan-shell-scripts-sh
# Written in bash version 5.1

# Implementation-dependent variables of arguments parseable by `shellcheck`
unset {a..z} {A..Z}
w='(sh|bash|dash|ksh)' # <w>hitelist
T='error' # SEVERI<T>Y

_usage(){
cat <<-EOF
  ./find-and-scan-shell-scripts-sh [-ehiw]
    -e error
    -h help
    -i info
    -w warning
  Find and scan shell scripts depending on severity level. One option only.
EOF
exit 1
}

case "$#" in  
  0)         T='error';;
  1) case "$1" in  
      -e)    T='error';; 
      -i)    T='info';; 
      -w)    T='warning';;
      -h|*)  _usage;;
    esac;;
  *)         _usage;;
esac

# Other variables
m="${TEMPDIR:="$HOME"}" # <m>ountpoint
r='(binfmt_misc|bpf|cgroup2|configfs|debugfs|devpts|devtmpfs|efivarfs|fusectl|hugetlbfs|iso9660|mqueue|proc|pstore|rpc_pipefs|securityfs|selinuxfs|sysfs|tmpfs|tracefs)' # <r>egex 
t="$( builtin printf '%(%F_%H%M%S)T' )" # <t>ime

# Bug? is '/run/media' portable to other distros? 

# get possible save directories somewhere off of the local disk.
# `df` will output three strings on one newline.
mapfile -d '' -t save_dirs < <( 
  find /run/media -mindepth 2 -maxdepth 2 -type d \
      -exec df --sync -l --output=fstype,avail,source \
      --block-size=1 '{}' ';' | 
    grep -iv avail | 
    tr '\n' '\0' )

# filter out via  <r>egex certain FS types by sorting the <o>utput of `df`
for o in "${!save_dirs[@]}"; do 
  if [[ "${save_dirs[$o]}" =~ ^${r} ]]; then 
    unset 'save_dirs[$o]'; 
  fi; 
done

# take the de<v>ice with the most available space, and get its
# <m>ountpoint, just in case large log files. `awk` can do more here.
if [[ -z "${save_dirs[*]:0:1}" ]]; then
  v="$( printf '%s\n' "${save_dirs[@]}" | 
    sort -grk2 | 
    head -n 1 |
    awk '{ print $3 }' )"
  m="$( mount | 
    awk "\$1 ~ /${v##*/}/ "'{ print $3 }' )"
fi

# Gather filenames from local attached disk storage
mapfile -d '' -t relevant_search_dirs < <(
  find / -mindepth 1 -maxdepth 1 -type d \
    \( \! -name proc -a \! -name sys -a \! \
    -name git \) -print0 )

# DEBUG: "${relevant_search_dirs[@]}" OR '/usr/sbin'
mapfile -d '' -t all_files < <( 
  find "${relevant_search_dirs[@]}" -type f -print0 2> /dev/null )

# sort out the <s>cripts, ie, any file beginning with a <c>runchbang, 
# from the rest of the files. <i> is for index.
for i in "${!all_files[@]}"; do
  
  # necc bc loop
  unset b c h n x
	
  # use a <n>ameref (sort of)
  n="${all_files[$i]}"
  
  # filter 1: file must exist and have a size greater than zero
  if [[ ! -s "$n" ]]; then
    unset 'all_files[$i]'
    continue
  fi

  # get the <b>asename
  b="${n##*/}"

  # read from disk in binary the first two bytes of every file left in 
  # the list, and format it in <h>exadecimal.
  mapfile -d '' -t h < <(  
    od -Ax0 -N2 -x "$n" |
      tr -s ' \n\t' '\0' )

  # compare the <h>exidecimal representations to find any <c>runchbangs
  if [[ "${h[1]}" == '2123' ]]; then
 
    # when a <c>runchbang's found, use `strings` to filter out any non-
    # printable data, to protect `head` from garbage input, and to 
    # get the full <c>runchbang string in ASCII.
    c="$( strings -n 1 "$n" |
      head -n 1 |
      head -c 32 )"; 

    # make a list of scripts, for use below
    if [[ "$x" =~ ^${w}$ ]]; then
      shell_scripts+=( "$n" )
    fi

    # using "<n>amerefs," make a record of the filenames and their 
    # <c>runchbangs, ie, open & append to a <t>imestamped file somewhere
    # off of the local hard disk
    printf '%s \t\t\t %s \n' "$c" "$n" >> "${m}/${t}_crunches"; 
    unset 'all_files[$j]'
  fi; 
done

# array 'shell_scripts' must exist
[[ -n "${shell_scripts[@]:0:1}" ]] || exit 3

# with ShellCheck scan each <s>cript for <e>rrors, and use index <j>
for j in "${!shell_scripts[@]}"; do 

  # also use a "nameref" for <s>cripts
  s="${shell_scripts[$j]}"

  mapfile -t errs < <( shellcheck -S "$T" "$s" | 
      grep -vFe 'shellcheck.net' | 
      grep --color=never -Eo 'SC[0-9]{4}' | 
      sort -g | 
      uniq -c |
      sed 's,^[[:space:]]*,,g' )

  if [[ -n "${errs[*]:0:1}" ]]; then 
		
    # open & append some prioritized work lists with indices
    printf '%d  <%s>\n' "$j" "$s" >> \
      "${m}/${t}_found_scripts_with_indices"
    for E in "${errs[@]}"; do
      printf '%s | %d\n' "${E//$'\n'/}" "$j" >> \
      "${m}/${t}_found_errors_with_indices_unsorted"
    done
  fi

  unset errors s 'shell_scripts[$j]'
  wait -f
done
