#!/bin/bash
# find-and-scan-shell-scripts-sh
# Written in bash version 5.1


# Implementation-dependent arguments for options parseable by `shellcheck`.
shells='(sh|bash|dash|ksh)'
severity='error'

# Variables
mountpoint="${TEMPDIR:="$HOME"}"
regex='(binfmt_misc|bpf|cgroup2|configfs|debugfs|devpts|devtmpfs|efivarfs|fusectl|hugetlbfs|iso9660|mqueue|proc|pstore|rpc_pipefs|securityfs|selinuxfs|sysfs|tmpfs|tracefs)' 
time="$( builtin printf '%(%F_%H%M%S)T' )"
datafile="${mountpoint}/${time}_crunches"
unlisted="${datafile}_test5_unlisted"

# Functions
_usage(){
  cat <<-EOF
    ./find-and-scan-shell-scripts-sh [-ehiw]
      -e error
      -h help
      -i info
      -w warning
    Find and scan shell scripts depending on severity level. One
    option only.
	EOF
  exit 1
}

# Option parsing
case "$#" in  
  0)         severity='error';;
  1) case "$1" in  
      -e)    severity='error';; 
      -i)    severity='info';; 
      -w)    severity='warning';;
      --[a-z]*)
        case "$1" in
          --python|--python2|--python3)
                    grep python "$unlisted" > "${unlisted}_python";;
          --perl)
                    grep perl "$unlisted" > "${unlisted}_perl";;
          --awk|--gawk)
                    grep awk "$unlisted" > "${unlisted}_awk";;
          --ruby)
                    grep ruby "$unlisted" > "${unlisted}_ruby";;
          #--other-lang*) # ToDo
          #         [parse '--other-language=(sed|tcsh|lua|etc)]
	  --*)      printf '\t\nHappy Easter!\n\n'
                    exit 1
        esac;;
      -h|*)  _usage;;
    esac;;
  *)         _usage;;
esac

# DEBUG: Automatically choose some directory, attached 
# to the local disk, where any output can be
# saved; prefer USB flash drives. This `df` command 
# will output three strings on one newline.
#   Bug? is '/run/media' portable to other distros? 
mapfile -d '' -t save_dirs < <( 
  find /run/media ~ /var/tmp /tmp -mindepth 2 -maxdepth 2 -type d \
      -exec df --sync -l --output=fstype,avail,source \
      --block-size=1 '{}' ';' | 
    sort -u |
    grep -iv avail | 
    tr '\n' '\0' )

# filter out via regex certain FS types by sorting the output of `df`
for df_o in "${!save_dirs[@]}"; do 
  if [[ "${save_dirs[$df_o]}" =~ ^$regex ]]; then 
    unset 'save_dirs[$df_o]'; 
  fi; 
done

# In case of large log files, of the remaining 'save_dirs' take the 
# device with the most available space and get its mountpoint. 
# If there are no 'save_dirs' left then leave 'mountpoint' set as above. 
if [[ -n "${save_dirs[*]:0:1}" ]]; then
  device="$( printf '%s\n' "${save_dirs[@]}" | 
    sort -grk2 | 
    head -n 1 |
    awk '{ print $3 }' )"
  mountpoint="$( mount | 
    awk "\$1 ~ /${device##*/}/ "'{ print $3 }' )"
fi

# Gather filenames from local attached disk storage
mapfile -d '' -t relevant_search_dirs < <(
  find / -mindepth 1 -maxdepth 1 -type d \
    \( \! -name proc -a \! -name sys -a \! \
    -name git \) -print0 )

# DEBUG: "${relevant_search_dirs[@]}" OR '/usr/sbin'
mapfile -d '' -t all_files < <( 
  find "${relevant_search_dirs[@]}" -type f -print0 2> /dev/null )

# sort out the scripts, ie, any file beginning with a crunchbang, 
# from the rest of the files.
for i1 in "${!all_files[@]}"; do
  unset crunchbangs hexes nextfile extension
  nextfile="${all_files[$i1]}"
  
  # filter 1: file must exist and have a size greater than zero
  if [[ ! -s "$nextfile" ]]; then
    unset 'all_files[$i1]'
    continue
  fi

  # read from disk in binary the first two bytes of every file left in 
  # the list, and format it in hexadecimal.
  mapfile -d '' -t hexes < <(  
    od -Ax0 -N2 -x "$nextfile" |
      tr -s ' \n\t' '\0' )

  # compare the hexidecimal representations to find any crunchbangs
  if [[ "${hexes[1]}" == '2123' ]]; then
 
    # when a crunchbang's found, use `strings` to filter out any non-
    # printable data, to protect `head` from garbage input, and to 
    # get the full crunchbang string in ASCII.
    crunchbangs="$( strings -n 1 "$nextfile" |
      head -n 1 |
      head -c 32 )"; 

    # make a list of scripts, for use below
    if [[ "$extension" =~ ^${shells}$ ]]; then
      shell_scripts+=( "$nextfile" )
    fi

    # make a record of the filenames and their 
    # crunchbangs, ie, open & append to a timestamped file
    printf '%s \t\t\t %s \n' "$crunchbangs" "$nextfile" >> \
      "${mountpoint}/${time}_crunches"; 
    unset 'all_files[$i]'
  fi; 
done

# array 'shell_scripts' must exist
[[ -n "${shell_scripts[*]:0:1}" ]] || 
  exit 3

# with ShellCheck scan each script for errors
for i2 in "${!shell_scripts[@]}"; do 
  script="${shell_scripts[$i2]}"

  mapfile -t errs < <( 
    shellcheck -S "$severity" "$script" | 
      grep -vFe 'shellcheck.net' | 
      grep --color=never -Eo 'SC[0-9]{4}' | 
      sort -g | 
      uniq -c |
      sed 's,^[[:space:]]*,,g' )

  if [[ -n "${errs[*]:0:1}" ]]; then 
		
    # open & append some prioritized work lists with indices
    printf '%d  <%s>\n' "$i2" "$script" >> \
      "${mountpoint}/${time}_found_scripts_with_indices"

    for each_error in "${errs[@]}"; do
      printf '%s | <idx:%d>\n' "${each_error//$'\n'/}" "$i2" >> \
      "${mountpoint}/${time}_found_errors_with_indices_unsorted"
    done
  fi

  unset errors script 'shell_scripts[$j]'
  wait -f
done
