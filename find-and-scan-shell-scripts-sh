#!/bin/bash
# Q: name sb scfi ?
# Written in bash version 5.1 on Fedora 37

# Notes: This script is overdesigned. "Keep your goal in mind."
#   https://www.navitor.com/blog/pursuit-perfection-overdesigning/

# SECTION A

:
: 'Regular users only'
if [[ "${UID}" == 0 ]]; then
  printf '\n\t Must be a regular user and use sudo. \n\n'
  exit 1
else
  sudo -v \
    || exit 1
fi

:
: 'Implementation-dependent arguments for opts parsable by -shellcheck-'
severity=error
# shellcheck disable=SC2034
shells='(sh|bash|dash|ksh)'

:
: 'Variables that lend themselves to some customization' # AJAX
repo_nm=scrfi
script_dirnm="${repo_nm}.d"
script_nm=find-and-scan-shell-scripts-sh
script_proper_nm='Script Finder'
script_version=1.0
umask 007

:
: Aliases
shopt -s expand_aliases
alias :_=':;: "<>"' \
      A_='fn_age_file ' \
      B_='fn_bak ' \
      D_='declare -p ' \
      I_='fn_erx "${LINENO}" ' \
      L_='exit "${LINENO}"' \
      N_='fn_num ' \
      S_='sudo ' \
      U_='fn_usage ' \
      V_='fn_write_vars ' \
      W_='fn_write_arrays ' \
      X_='set -x'
:

:
: Environment variables
unset LC_ALL
LC_COLLATE="C.UTF-8"     # for predictable sorting
LC_CTYPE="C.UTF-8"       #  "   "           "
LC_NUMERIC="en_US.UTF-8" # for commas in large numbers

PATH="$(/usr/bin/command -p getconf PATH):/usr/bin:/usr/sbin:${PATH}" \
  || L_
export LC_COLLATE LC_CTYPE LC_NUMERIC PATH

:
: Functions
fn_bak() {
  : fn_bak

  # for each of multiple input files
  for loc_filename_a in "${@}"; do

    # test verifying existence of input
    if S_ test -f "${loc_filename_a}"; then

      # if the destination (.bak) file already exists,
      # then age it first.
      if [[ -f "${loc_filename_a}.bak" ]]; then
        
        if [[ -s "${loc_filename_a}.bak" ]]; then
          return
        else
          S_ rm -f "${loc_filename_a}.bak"
        fi
      fi

      # write a new .bak file
      S_ rsync -acq "${loc_filename_a}"{,.bak} \
        || I_

    # if input file DNE, then print an error and exit
    else
      { 
        echo WARNING: file DNE "${loc_filename_a}"
        return
      }
    fi
  done
  : 'END OF fn_bak'
  :
}
fn_erx() {
  # this assignment must be the first command
  local loc_exit_code="${?}"
  : fn_erx

  # print an error message and exit with the correct exit code
  echo -e Error: "${@}"
  : 'END OF fn_erx'
  :
  exit "${loc_exit_code}"
}
fn_num() {
  # Usage: N_ [raw arrays names]
  : fn_num

  # for each of multiple input array names
  for loc_unquotd_array_nm_a in "${@}"; do

    # set a local name reference variable
    local -n loc_nameref_a="${loc_unquotd_array_nm_a}"

    # and use the nameref to print the number of indices in the input array
    echo ${#loc_nameref_a[@]}
  done
  : 'END OF fn_num'
  :
}
fn_usage() {
  # Usage:  U_ [exit-code]
  : fn_usage

  # print a usage message and exit with a pre-determined exit code
  cat <<-EOF
    ${repo_nm} - ${script_proper_nm}, version ${script_version} (for 
      redhat-linux)
    Find and scan shell scripts depending on severity level. 
        Usage:  ${script_nm} [-ehiw]
                -e error          -i info
                -h help           -w warning
    Only the first option is processed.

EOF
  : 'END OF fn_usage'
  :
  # shellcheck disable=SC2086
  exit "${1}"
}
fn_write_arrays() {
  # Usage: W_ [arrays]

  :
  : fn_write_arrays: Write each array to a file on disk.

  # for each of multiple input array names
  for loc_unquotd_array_nm_b in "${@}"; do

    # create local variables, for use as both array and string
    local -n loc_nameref_b="${loc_unquotd_array_nm_b}"
    loc_array_nm="${loc_unquotd_array_nm_b}"
    loc_write_f_b="${curr_time_ssubd}/${loc_array_nm}"

    # solved?  BUG: mixing variable and array. sb a nameref

    # Bug? When array correctly is empty. 'declare -p ... > /dev/null ||' ?

    # if the input array holds any data
    if [[ -v loc_nameref_b[@] ]]; then

      # then write a data file to disk
      declare -p "${loc_array_nm}" \
        | S_ tee --output-error=exit "${loc_write_f_b}" >/dev/null

    # if input array holds no data, then print an error and exit
    else
      I_ variable "${loc_unquotd_array_nm_b}" empty or DNE
    fi

    # write a backup of the new data file
    :
    B_ "${loc_write_f_b}"
  done
  : 'END OF fn_write_arrays'
  :
}
fn_write_vars() {
  # Usage: V_ [loc_script_section_nm] [raw variable names]

  # first pos-parm is string used for differentiating filename
  : fn_write_vars
  loc_script_section_nm="${1}"
  loc_write_f_a="${curr_time_ssubd}/${loc_script_section_nm}_vars"
  shift

  # if the destination file already exists, then age it first
  [[ -e "${loc_write_f_a}" ]] \
    && return

  # write a new data file
  declare -p "${@}" 2>/dev/null \
    | S_ tee --output-error=exit "${loc_write_f_a}" >/dev/null

  # and write a .bak file
  :
  B_ "${loc_write_f_a}"
  : END OF fn_write_vars
  :
}

:
: Use -sudo-
if ! S_ -v; then
  printf '\n\tValidation failed of user\x27s \x60sudo\x60 timestamp; '
  printf 'exiting.\n\n'
  L_
fi

:
: Lets just solve this darned new-line issue

#   Note: the in-command newline is intentional
# shellcheck disable=SC2312 
mapfile -d '' -t filenames_with_newlines < <( S_ find / -name '*
*' -print0 2> /dev/null ) # Posix compatible per Stack Overflow

for f in "${filenames_with_newlines[@]}"; do 
  S_ mv "${f}" "${f//$'\n'/}"; 
done

# shellcheck disable=SC2312
mapfile -d '' -t filenames_with_newlines < <( S_ find / -name '*
*' -print0 2> /dev/null )
: 'filenames_with_newlines:' "${#filenames_with_newlines[@]}"

# Set up a trap on signals "exit", "term" and "int"
# shellcheck disable=SC2154
trap '
  set -

  # [Trap] Delete all possible process directories, if they exist. 
  for poss_lk_d in "${a_poss_proces_lock_dirs[@]}"; do 

    # [Trap] Abbreviate var, then test and delete lock dirs.
    pl="${poss_lk_d}/${proc_lk_f_nm}"

    if [[ -d "${pl}" ]] && [[ ! -L "${pl}" ]]; then 
      S_ rm -rf -- "${pl}" \
        || L_
    fi
  done

  # [Trap] Remove any script-s ACL-s based on whether the canary variables
  # exist.
  if [[ -v acl_execd_setfacl ]]; then 
    
    if [[ -v acl_abs_path ]]; then 
      S_ setfacl -R -x "u:${UID}" "${acl_abs_path}" ||
        echo Error: setfacl failed, line "${LINENO}"

    # bug? Should this var be main_d ?

    elif [[ -v mountpoint ]]; then
      S_ setfacl -R -x "u:${UID}" "${mountpoint}" ||
        echo Error: setfacl failed, line "${LINENO}"
    fi
  fi

  trap - EXIT TERM INT
  kill -s INT $$
' EXIT TERM INT

:
: User variables
timecode="$(builtin printf '%(%F_%H%M%S)T')"

:
: Option parsing
if [[ ${#} -gt 0 ]]; then
  cli_input="${1:0:2}"

  # shellcheck disable=SC2034
  case "${cli_input}" in
    --)
      printf 0a09486170707920456173746572210a0a \
        | xxd -r -p
      exit 0
      ;;
    -e) severity=error ;;
    -i) severity=info ;;
    -v)
      printf 0a09224920776f756c642068617665206d61646520746869732073686f727465722c206275742049206469646e27742068617665207468652074696d652e220a09092d2d204d61726b20547761696e0a0a \
        | xxd -r -p
      exit 0
      ;;
    -w) severity=warning ;;
    -h)
      :
      U_ 0
      ;;
    *)
      :
      U_ 1
      ;;
  esac
fi

# SECTION B

:_
X_
:
: 'Assign varnames and paths for the data directories'
mountpoint=/run/media/root/29_Mar_2023
main_d="${mountpoint}/${script_dirnm}"
data_subd="${main_d}/latest_data"
curr_time_ssubd="${data_subd}/t_${timecode}/"
list_crunchbangs="${curr_time_ssubd}/crunchbangs"


: 'Reduce use of sudo'
if [[ ! -r "${main_d}" ]]; then

  mapfile -d / -t a_acl_name_indiv_dir <<<"${main_d}"

  a_acl_name_indiv_dir[0]=/
  a_acl_name_indiv_dir[-1]="${a_acl_name_indiv_dir[-1]//$'\n'/}"

  acl_each_dir=${#a_acl_name_indiv_dir[@]}

  for ((iterator_1 = 0; iterator_1 < acl_each_dir; iterator_1++)); do
    acl_abs_path+="/${a_acl_name_indiv_dir[iterator_1]}"
    acl_realpath="$(realpath -e "${acl_abs_path}")"

    if S_ test -e "${acl_realpath}"; then
      : 'test succeeded: acl_realpath exists '
    else
      :
      : 'test failed: acl_realpath DNE'
      :

      if [[ ! -d "${acl_abs_path}" ]]; then

        S_ mkdir -v --parents "${main_d}" \
          || I_
      fi

      acl_realpath="$(realpath -e "${acl_abs_path}" 2>/dev/null)"

      :
      : '<>'
      S_ namei -xl "${acl_realpath}"

    fi

    if [[ -r "${acl_realpath}" ]]; then
      : 'test succeeded: acl_realpath is readable'
    else
      :
      : 'test failed: acl_realpath is not readable'
      :

      acl_execd_setfacl=y
      export acl_execd_setfacl # SC2034, while trap-s setfacl blk is #-d

      # readable up to the main_d
      S_ chmod -R 750 "${acl_realpath}" \
        || I_

      S_ setfacl -d -m "${USER}:r-x" "${acl_realpath}" \
        || I_

      S_ setfacl -m "${USER}:r-x" "${acl_realpath}" \
        || I_

      :
      : '<>'
      id "${USER}"
      groups "${USER}"
      S_ namei -xl "${acl_realpath}"
      S_ getfacl "${acl_realpath}"

      [[ -r "${acl_realpath}" ]] \
        || I_

    fi
  done

  # writeable within the main_d
  S_ setfacl -d -m "${USER}:rwx" "${main_d}" \
    || I_

  S_ setfacl -R -m "${USER}:rwx" "${main_d}" \
    || I_

  :
  : '<>'
  id "${USER}"
  groups "${USER}"
  S_ namei -xl "${main_d}"
  S_ getfacl "${main_d}"

fi

:
: 'make sure -data_subd- is a directory OR create the -data_subd- dir '
: 'if necessary'
[[ -d "${data_subd}" ]] \
  || mkdir -v "${data_subd}" # as liveuser

:
: '<>'
S_ namei -xl "${data_subd}"

:
: Label the current data as -latest.-
# shellcheck disable=SC2312
mapfile -d '' -t a_previous_time_dirs < <(
  find "${data_subd}" -mindepth 1 -maxdepth 1 -type d -a \! -type l \
    -name 't_*' -print0
)

:
: if -prev_time_ssubd- is empty, delete it, otherwise -mv- it out
: of the -latest- dir
for prev_time_ssubd in "${a_previous_time_dirs[@]}"; do
  rmdir --ignore-fail-on-non-empty "${prev_time_ssubd}"

  : of previous prev_time_ssubd
  if [[ -d "${prev_time_ssubd}" ]] && [[ ! -L "${prev_time_ssubd}" ]]; then
    mv "${a_previous_time_dirs[@]}" "${main_d}"
  else
    continue
  fi
done

: of curr_time_ssubd
if [[ ! -d "${curr_time_ssubd}" ]]; then
  S_ mkdir -pv "${curr_time_ssubd}" \
    || I_
fi

:
: '<>'
S_ namei -xl "${curr_time_ssubd}"

# SECTION C

:
: 'Gather filenames from local attached disk storage'
:
: 'in any event, create a new record for a_relevant_search_dirs and..'
# shellcheck disable=SC2312
mapfile -d '' -t a_relevant_search_dirs < <(
  S_ find / -mindepth 1 -maxdepth 1 -type d \! -empty \
    \( \! -name proc -a \! -name sys -a \! -iname "${script_dirnm}*" \) \
    -print0 2>/dev/null
)
:
W_ a_relevant_search_dirs

:
: 'run -find- for a_all_files.'

: '<>'
a_relevant_search_dirs=( /usr/sbin )
#a_relevant_search_dirs=( /usr/sbin /usr/bin )
#a_relevant_search_dirs=( /usr/sbin /usr/bin /etc )
#a_relevant_search_dirs=( /usr/sbin /usr/bin /etc /var )
#a_relevant_search_dirs=(/usr/sbin /usr/bin /etc /var /root)

:
: Find all files on disk. Even the empty ones.
# shellcheck disable=SC2312
mapfile -d '' -t a_all_files < <(
  S_ find "${a_relevant_search_dirs[@]}" -mindepth 1 -type f \
    -print0 2>/dev/null
)

:
W_ a_all_files

:
: 'Sort the original array and test it.'
# shellcheck disable=SC2312
mapfile -d '' -t a_all_files_sorted < <(
  printf '%s\0' "${a_all_files[@]}" \
    | sort --zero-terminated
)

:
W_ a_all_files_sorted

# SECTION D

# Bug? Can more indices and fewer files be used?

:
: Add some brevity, and write the completed arrays to disk
# shellcheck disable=SC2034
total_count="$(printf "%'d" "${#a_all_files_sorted[@]}")"
unset IFS

:
: '<>'
[[ -f /tmp/"${list_crunchbangs##*/}" ]] \
  && rm -f "/tmp/${list_crunchbangs##*/}"

# BUG: the search dirs must be the same, as well as the dnf tx number

# tests tmp file
:
: 'if the full list exists -- of files on disk which begin with crash-'
: 'bangs -- skip the 30-90 minute search phase.'
if [[ ! -f "/tmp/${list_crunchbangs##*/}" ]] \
  || [[ -L "/tmp/${list_crunchbangs##*/}" ]]
then

  :
  : Sort out the scripts, ie, any file beginning
  : with a crashbang from the rest of the files
  for all_files_index in "${!a_all_files_sorted[@]}"; 
  do

    :
    : # Loop progress meter
    :
    count_this_loop="$(printf "%'d" $((all_files_index + 1)))"
    printf '%s of %s files\r' "${count_this_loop}" "${total_count}"

    :
    : # each_sorted_f must exist
    each_sorted_f="${a_all_files_sorted[all_files_index]}"

    if [[ ! -e "${each_sorted_f}" ]]; 
    then
      a_file_DNE+=("${each_sorted_f}")
      continue
    fi

    # check for empty files, make a list of them
    if [[ ! -s "${each_sorted_f}" ]]; 
    then
      a_empty_files+=("${each_sorted_f}")
      continue
    fi

    :
    : # run -file- on each each_sorted_f
    printf '+ %-8d: ' "${all_files_index}" \
      | S_ tee -a "${curr_time_ssubd}file_out" >/dev/null
      
    file_o="$(S_ file -pk "${each_sorted_f}" 2>&1)"
    
    if [[ -n "${file_o}" ]]; 
    then
      S_ tee -a "${curr_time_ssubd}file_out" <<< "${file_o}"  > /dev/null
    else
      err_msg="ERROR: -file- produced zero output for:  <${each_sorted_f}>"
      S_ tee -a "${curr_time_ssubd}file_out" <<< "${err_msg}" > /dev/null
    fi

    # Bug: avoid as many disk writes as possible.
    # Bug: use indices to reference each type?

    :
    : # 'Read from disk in binary the first two bytes of each'
    : # 'each_sorted_f in the list and output it in hexadecimal.'
    od_o="$(S_ od -j 0 -N 2 -t x1z -v "${each_sorted_f}" \
      || fn_erx "L:${LINENO} I:${all_files_index} ${each_sorted_f}")"
    [[ -n "${od_o}" ]] \
      || fn_erx "L:${LINENO} I:${all_files_index} ${each_sorted_f}"
    read -r leftover_words_b byte_0 byte_1 leftover_words_b <<< "${od_o}" 

    export leftover_words_b # SC2034

    :
    : # If -od_o- contains some non-zero data, as it should...
    if [[ -z "${byte_0}" ]]; 
    then
      fn_erx "L:${LINENO} I:${all_files_index} <${each_sorted_f}>" \
        '*theoretically unreachable code*'

    # compare the hexadecimal representations to
    # find any crashbangs.
    elif [[ "${byte_0}${byte_1}" == @(2321|2123) ]]; 
    then

      :
      : # Issue: a big endian file format, possibly
      : # a DB file, etc.
      if [[ "${byte_0}${byte_1}" == 2123 ]]; 
      then
        a_incorrect_endianness+=([all_files_index]="${each_sorted_f}")

        # BUG: expect non-printable characters

        :
        : Crunchbang found. Use -read-, and hope
        : there wont be any non-printable characters.
      else
        IFS= read -r first_line < "${each_sorted_f}" \
          || fn_erx "L:${LINENO} I:${all_files_index} ${each_sorted_f}"

        :
        : Issue: the files with -#!comment- as the
        : initial bytes. These aren-t scripts, so restart the loop.
        if [[ "${first_line}" =~ ^'#!comment' ]]; 
        then
          a_crunches_with_hashbang_comments+=(
            [all_files_index]="${each_sorted_f}")
          continue
        fi

        #   Note: with only /bin/sbin, this if-fi block doesn't execute

        :
        : Issue: crashbang files which originate
        : outside of the rpm package manager
        if ! rpm -qf "${each_sorted_f}" 2>/dev/null 1>&2; 
        then

          :
          : user and system files from outside -rpm-
          if [[ "${each_sorted_f}" = /@(root|home|run/media)/* ]]; 
          then
            a_non_rpm_user_crunches+=([all_files_index]="${each_sorted_f}")
            continue

          else
            a_non_rpm_system_crunches+=(
              [all_files_index]="${each_sorted_f}")
            continue
          fi
        fi
      fi

      # TODO: Add "$all_files_index" to content of "a_shell_scripts"

      :
      : 'Make an array of the relevant filenames and their crashbangs.'
      a_shell_scripts+=([all_files_index]="$(
        printf '%-50s   %% %% %% %%   %s\n' "${first_line}" \
          "${each_sorted_f}"
      )")

    else
      a_all_other_files+=([all_files_index]="${each_sorted_f}")
    fi
  done
  echo # CLI formatting

  :
  B_ "${curr_time_ssubd}/file_out"

  :
  : Open a timestamped file and append into it the list
  : of filenames and their crashbangs.

  :
  : Exporting is necessary of the array names from the above scan
  export a_all_files_sorted a_file_DNE a_incorrect_endianness \
    a_crunches_with_hashbang_comments a_non_rpm_user_crunches \
    a_non_rpm_system_crunches a_shell_scripts a_all_other_files \
    a_relevant_search_dirs

  :
  : data files
  a_write_path_nms=("${list_crunchbangs:=crunchbangs}"
    "/tmp/${list_crunchbangs##*/}")

  :
  : 'if any data files already exist, keep them'
  for any_existing_f in "${a_write_path_nms[@]}"; 
  do

    if [[ -f "${any_existing_f}" ]] && [[ ! -L "${any_existing_f}" ]]; 
    then
      mv "${any_existing_f}" "${any_existing_f}.${$}.${random_n}" \
        || I_
    fi
  done

  :
  : create the original list_crunchbangs
  S_ touch "${a_write_path_nms[@]}"

  :
  : header
  {
    printf '# crunchbangs -- %s\n' "${timecode%-*}"
    printf '# %s\n' "$(declare -p a_relevant_search_dirs)"
  } | S_ tee --output-error=exit "${a_write_path_nms[@]}" >/dev/null

  :
  : printing contents of a_shell_scripts array
  printf '%s\n' "${a_shell_scripts[@]}" \
    | S_ tee --append --output-error=exit "${a_write_path_nms[@]}" >/dev/null

  :
  B_ "${a_write_path_nms[@]}"

else

  # the time_dir needs a copy of the crunchbangs file, also.  copy it in
  # from the hopefully correct backup in /tmp
  if [[ ! -f "${list_crunchbangs}" ]]; 
  then
    S_ rsync -ca "/tmp/${list_crunchbangs##*/}" "${list_crunchbangs}" \
      || I_
  fi
fi

# TODO: verify interpreters

# SECTION E
:
: CENTRAL TASK, 1 OF 2: Filter the list of crashbangs with the list
: of shells.
:
: header
{
  printf '# SC-scrpts-list -- %s\n' "${timecode%-*}"
  printf '# %s\n' "$(declare -p a_relevant_search_dirs)"
} | S_ tee --output-error=exit "${list_crunchbangs}_SC-scrpts-list" \
  >/dev/null

# pulls from time_dir
S_ grep --extended-regexp '/bin/'"${shells}"'.*% % % %' "${list_crunchbangs}" \
  | S_ tee -a "${list_crunchbangs}_SC-scrpts-list" \
  || I_

:
B_ "${list_crunchbangs}_SC-scrpts-list" /tmp/*_SC-scrpts-list
:

S_ rsync -ca "${list_crunchbangs}_SC-scrpts-list" /tmp \
  || I_
:
B_ "${list_crunchbangs}_SC-scrpts-list" /tmp/*_SC-scrpts-list

:
: MAIN TASK, 2 of 2: with ShellCheck scan each script for errors

# TODO: keep "$all_files_index" tracked with content all the way through
# into the "_found_scripts" file

# Bug? line 1 of script could contain percent symbols

:
: A hell world of pipelines
#   Q: how to translate the correct newlines into nulls to separate the 
#   filenames when reading from a file?  awk?
:
grep_o="$(S_ grep ^'#!' "${list_crunchbangs}_SC-scrpts-list")"
:
cut_o="$(cut -d '%' -f5- <<< "${grep_o}")"
:
mapfile -t a_each_abspath_scriptnm <<< "${cut_o}"
:
a_each_abspath_scriptnm=("${a_each_abspath_scriptnm[@]##* }")

# Wk: awk , multi-char delim, remv lead+trail wspc - redef $0 ?, printf
# grep -Eo | tr

# Bug: rename variable "$c" below
# Bug: why sort by line count? More text, more bugs? How to prior mult
#   factors?

:
wc_o="$(S_ wc -l "${a_each_abspath_scriptnm[@]}")"
:
wc_o="${wc_o%$'\n*'}" # Remove 'totals' line.
:
sort_o="$(sort -gr <<< "${wc_o}")"
:
awk_o="$(awk '{ print $2 }' <<< "${sort_o}")"
:
mapfile -t a_each_script_list_sorted_by_linect <<< "${awk_o}" # ie properly

# Bug? 1st grep extra?

:
: '<>'

iterator_2=0
{
  :
  for sorted_script in "${!a_each_script_list_sorted_by_linect[@]}"; do
    :
    mapfile -d '' -t a_each_script_SC_results < <(
      shellcheck -S "${severity}" \
        "${a_each_script_list_sorted_by_linect[sorted_script]}" \
        | grep --fixed-strings --invert-match 'shellcheck.net' \
        | grep --extended-regexp -o "SC[]0-9a-zA-Z\ \t():,.'$&#\!\[-]*" \
        | cut -b -64 \
        | sort --general-numeric-sort \
        | uniq --count # end of pipe intended
      printf '\0'
    )

    :
    : '<>'

    if [[ -n "${a_each_script_SC_results[*]:0:1}" ]]; then
      printf '\n%-4d%s\n' $((iterator_2++)) \
        "${a_each_script_list_sorted_by_linect[sorted_script]}"
      printf '%s' "${a_each_script_SC_results[@]}"
    fi
  done
} | S_ tee -a "${list_crunchbangs}_found_scripts" >/dev/null


:
: Write semi-permanent archives

:
B_ "${list_crunchbangs}_found_scripts"
S_ rsync -ca "${list_crunchbangs}_found_scripts" "${main_d}" \
  || I_
S_ rsync -ca "${list_crunchbangs}_found_scripts" /tmp \
  || I_
:

:
B_ "${main_d}/${list_crunchbangs##*/}_found_scripts"
:

:
B_ "/tmp/${list_crunchbangs##*/}_found_scripts"
:

exit 00

