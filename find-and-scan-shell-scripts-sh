#!/bin/bash
# Q: name sb scf ?
# Written in bash version 5.1 on Fedora 37

# Note: Keep your goal in mind.


# SECTION A
:
: 'Regular users only'
:
if [[ "${UID}" == 0 ]]; then
  printf '\n\t Must be a regular user and use sudo. \n\n'
  exit 1
else
  sudo -v \
    || exit 1
fi
:
set -x
:

: 'Implementation dependent arguments for options parsable by -shellcheck-'
:
SC_severity=error
# shellcheck disable=SC2034
SC_shells='(sh|bash|dash|ksh)'
:
: 'Variables that lend themselves to some customization'
:
repo_nm=scrfi
script_dirnm="${repo_nm}.d"
protected_git_dir_1="${HOME}/MYPROJECTS"
protected_git_dir_2="${HOME}/OTHERSPROJECTS"
script_nm=find-and-scan-shell-scripts-sh
script_proper_nm='Script Finder'
script_version=1.0
:
a_poss_proces_lock_dirs=([0]="${XDG_RUNTIME_DIR}" [1]="${HOME}"
  [2]="${TMPDIR}" [3]=/tmp [4]=/var/tmp)
:

# to search dirs...
:
: Option parsing
if [[ $# -gt 0 ]]; then 
  cli_input="${@}"
  :
fi


######### `getopts` how-to from wooledge.org
# https://mywiki.wooledge.org/BashFAQ/035?highlight=%28getopts%29#getopts

# Initialize variables:
SC_severity='error'

while getopts ABhCDEFGHIJKLeisw cli_input; do
  case "${cli_input}" in
    A) printf '%s%s%s' 'CgkiSSB3b3VsZCBoYXZlIG1hZGUgdGhpcyBzaG9y' \
        'dGVyLCBidXQgSSBkaWRuJ3QgaGF2ZSB0aGUg' \
        'dGltZS4iCgkJLS0gTWFyayBUd2FpbgoK' \
        | base64 -d
      exit 0
      ;;   
    B) printf 'CglIYXBweSBFYXN0ZXIhCgo=' \
        | base64 -d
      exit 0
      ;;
    
    h) fn_usage 0
      ;;   
    
    #) select_interpreter=bash
      #;;
    #) select_interpreter=dash
      #;;
    #) select_interpreter=ksh
      #;;
    #) select_interpreter=sh
      #;;

    C) search_method+=(actual_all)
      ;;
    D) search_method+=(PATH_bin-sbin-only)
      ;;
    E) search_method+=(comm_p)
      ;;
    F) search_method+=(getconf_PATH)
      ;;
    G) search_method+=(PATH_as-is) # default 1 of 2
      ;;
    H) search_method+=(w_descend)
      ;;
    I) search_method+=(w_procfs)
      ;;
    J) search_method+=(w_spec_dirs)
      ;;
    K) search_method+=(w_symlinks) # default 2 of 2
      ;;
    L) search_method+=(w_sysfs)
      ;;
   
    e) SC_severity=error # default
      ;;
    i) SC_severity=info
      ;;
    s) SC_severity=style 
      ;;
    w) SC_severity=warning
      ;;

    #V) echo 'TODO: write fn_version'
      #;;

    *) fn_usage 1
      ;;   
  esac 
done
shift "$((OPTIND-1))"   # Discard the options and sentinel --


# Verify PATH

# TODO: check DAC's, ACL's and MAC's of each dir

# Get constituent dirs from PATH
IFS=':' read -ra path <<< "${PATH}" # this
# get the cannonicalized paths of each such dir
for p in "${!path[@]}"; do
  path[p]="$( realpath -e "${path[p]}" )";
done # this
# if the index is empty, then unset it
for p in "${!path[@]}"; do
  if [[ -z "${path[p]}" ]]; then
    unset 'path[p]';
  fi;
done # this
# remove any duplicates while preserving order of dirs
for p in "${!path[@]}"; do
  if [[ "${path_2[*]}" =~ ${path[p]} ]]; then
    unset 'path[p]';
  else
    path_2+=("${path[p]}");
  fi;
done # this
# print results
declare -p path_2 # this


# sort out search_method selections
if [[ -z "${search_method[*]}" ]]; then
  search_method=(PATH_as-is w_symlinks)
  bash_v_find=bash
elif [[ "${search_method[*]}" = @(comm_p) ]]; then
  search_method=(comp_p)
  bash_v_find=bash
else
  bash_v_find=find
  if [[ "${search_method[*]}" = @() ]]; then
    true
  else
    false
  fi
fi


# PATH_as-is
#   y = bash or find                        -- DEFAULT
#     # for find, convert PATH into an array 
#   n =                                     -- side effect of enabling any other PATH_* setting
# 
### MUTUALLY EXCLUSIVE: last set takes precedence
#   PATH_getconf_PATH   -- a limiting setting, usually '/usr/bin'
#     y = bash or find                        -- usually for debugging or research
#       # `unset PATH; PATH="$(getconf PATH)"
#     n =                                     -- default setting
#   PATH_bin-only       -- a limiting setting, usually the same as 'PATH_getconf_PATH'
#     y = bash or find                        -- debug setting
#       # PATH='/usr/bin:/bin'
#     n =                                     -- practical result of customary configuration AND default setting
#   PATH_sbin-only      -- a limiting setting
#     y = bash or find                        -- debug setting
#       # PATH='/usr/sbin:/sbin'
#     n =                                     -- practical result of customary configuration AND default setting
#   PATH_bin-sbin-only  -- a limiting setting
#     y = bash or find                        -- practical result of customary configuration
#       # PATH='/usr/sbin:/sbin:/usr/bin:/bin'
#     n =                                     -- default setting


# BASH_command_pv          -- usually a limiting setting, to be used independent of PATH
#   y = bash only
#     # compgen -c
#   n = <no meaning>                        -- default setting
# BASH_command_v
#   y = bash only
#     # compgen -c
#   n = <no meaning>                        -- default setting
# BASH_type_a
#   y = bash only
#     # compgen -c
#   n = <no meaning>                        -- default setting


unset alnum dict i all_commands real_dirs re
for alnum in {a..z} {A..Z} {0..9}; do 
  dict+=("${alnum}"); 
done
for i in "${!dict[@]}"; do 
  mapfile -O $((i * 1000)) -t all_commands < <(
    compgen -c "${dict[i]}"
  ); 
done
mapfile -t real_dirs < <(
  find / -maxdepth 1 -mindepth 1 -type d \! -empty
)
re="$( \
  printf '(%s' "${real_dirs[0]#/}"; 
  unset 'real_dirs[0]'; 
  printf '|%s' "${real_dirs[@]#/}"; 
  printf ')\n'
)"
unset i; 
for i in "${!all_commands[@]}"; do 

  # For anywhere in PATH: BASH_type_a
  type -a "${all_commands[i]}" \
    | grep -E 'is /'"${re}" ; 

  # For `command -pv` (usually only '/usr/bin'): BASH_command_pv
  command -pv "${all_commands[i]}" \
    | grep -E 'is /'"${re}" ; 

  # For `command -v` (usually includes '/usr/sbin'): BASH_command_v
  command -v "${all_commands[i]}" \
    | grep -E 'is /'"${re}" ; 

done \
  | wc


# w_symlinks          
#   y = bash or find                        -- DEFAULT
#   n = find only
# 
# w_descend
#   y = find only
#   n = find or bash                        -- default setting
# 
# w_user-custom_dirs
#   y = (ie, explicit include) find only
#   n = (ie, implicit exclude) find only    -- default setting
# 
# w_procfs
#   y = (ie, explicit include) find only
#   n = (ie, implicit exclude) bash or find -- practical result of customary PATH config AND default setting
# 
# w_sysfs
#   y = (ie, explicit include) find only
#   n = (ie, implicit exclude) bash or find -- practical result of customary PATH config AND default setting
# 
# actual_all
#   y = (ie, explicit include) find only
#   n = (ie, implicit exclude) bash or find -- practical result of customary PATH config AND default setting


declare -p search_method SC_severity

exit
# End of file
######### from wooledge.org


# Bug: abbrev_rel_search_dirs is not assigned

#abbrev_rel_search_dirs=all
:
# To search some specific directories, uncomment them; to search 
# all of the common dirs or FULL DISK instead # --really-- --slow--
#
declare -A A_rsd
A_rsd=( 
  # useful for testing 
    #[usr_bin]='/bin' 
    #[usr_lib]='/lib' 
    #[usr_lib64]='/lib64' 
    [usr_sbin]='/sbin' 
  # common search dirs on Fedora, ie, "all"
    #[boot]='/boot' 
    #[dev]='/dev' 
    #[etc]='/etc' 
    #[home]='/home' 
    #[root]='/root' 
    #[run]='/run' 
    #[tmp]='/tmp' 
    #[usr]='/usr' 
    #[var]='/var' 
  # usually empty
    #[afs]='/afs' 
    #[lost+found]='/lost+found' 
    #[media]='/media' 
    #[mnt]='/mnt' 
    #[opt]='/opt' 
    #[srv]='/srv' 
  # usually quite difficult to parse; rarely any shell scripts
    #[proc]='/proc' 
    #[sys]='/sys' 
)
umask 117
:
get_rel_search_dirs(){
  mapfile -d '' -t "${1}" < <(
    sudo find / -mindepth 1 -maxdepth 1 -type d \! -empty \
      \( \! -name proc -a \! -name sys \
        -a \! -iname "${script_dirnm:- scf.d}" \
        -a \! -iname "${protected_git_dir_1:- ~}" \
        -a \! -iname "${protected_git_dir_2:- tmp}" \
      \) -print0 2> /dev/null);
    }
get_rel_search_dirs a_relevant_search_dirs

# take each found dir and convert abs path [of sym, okay] to a string
# usable for directory names

unset index element calc;
for index in "${!A_rsd[@]}"; do 
  element="${A_rsd["$index"]}"; 
  calc="$(realpath -e "$element")"; 
  calc="${calc//\//_}"; 
  calc="${calc#_}"; 
  printf 'element: %-12s index: %-12s calc: %s \n' \
    "$element" "$index" "$calc"; 
  if [[ "$index" != "$calc" ]]; then 
    echo wrong; 
    exit; 
  fi; 
done

#   to have an option to search all or just some dirs
#   to store results on a per-dir basis, to reduce search time
#     per mangling of realpath
#     per dnf tx number
#     per severity level
#     per sha1sum
#  _boot
#    _tx3
#    _tx4
#      _e
#        _6cb7aa1478a1d36f5b70d7fcb3e73486caae5bfc
#          # abs path filename
#          # full shellcheck output
#          # ...
#      _w
#        _6cb7aa1478a1d36f5b70d7fcb3e73486caae5bfc
#          # abs path filename
#          # diff of shellcheck output
#          # ...
#      _s


get_mountpoint(){
  unset d dir
  d="$(realpath -e "$1")"
  mapfile -t dir < <(
    namei -xl "$d" \
    | tac \
    | grep -A100 ^D \
    | grep -E ^'[Dd]' \
    | awk '{ print $4 }')
  unset j x i
  j="${#dir[@]}"
  for (( i=j; i>0; i--)); do 
    x+="${dir[$i-1]}"/
  done; 
  x="$(realpath -e "$x")"
  echo "$x"
}
get_mountpoint /sbin

:
: 'Aliases and functions -- for brevity during debugging'
:
shopt -s expand_aliases;
alias     :_=':;: "<>"';
alias     D_='declare -p ';
alias     L_='exit "${LINENO}"';
alias     M_='sudo namei -xl ';
alias     S_='sudo ';
alias     T_='tee --output-error=exit ';
alias     X_='set -x';
alias     awk='gawk --lint ';
:
set -v
function  B_() { fn_bak "$@";};
function  I_() { fn_erx "${LINENO}";};
#function N_() { fn_num "$@";};
#function V_() { fn_write_vars "$@";};
function  W_() { fn_write_arrays "$@";};
set +v

:
: 'Environment variables'
:
unset LC_ALL
LC_COLLATE="C.UTF-8"     # for predictable sorting
LC_CTYPE="C.UTF-8"       #  "   "           "
LC_NUMERIC="en_US.UTF-8" # for commas in large numbers
:
PATH="$(/usr/bin/command -p getconf PATH):/usr/bin:/usr/sbin:${PATH}" \
  || L_
export LC_COLLATE LC_CTYPE LC_NUMERIC PATH

:
: 'Check for Process Locks'
:
for d in "${a_poss_proces_lock_dirs[@]}"; do
  if [[ -d "${d}" ]]; then
    mapfile -d '' -t lkds < <( 
      S_ find "${d}" -type d -empty -name ".${repo_nm}.[0-9a-zA-Z_-]*.lock" \
        -print0 2> /dev/null)
    :
    : 'lkds, count:' "${#lkds[@]}"
    :
    for l in "${lkds[@]}"; do
      if [[ -d "${l}" ]]; then
        if [[ -v delete_locks ]]; then
          rmdir -v -- "${l}"
        else
          printf '\n\t A process lock exists for this script. Exiting '
          printf 'now.\n\n'
          L_
        fi
      fi
    done
  fi
done
[[ -v delete_locks ]] \
  && L_

:
: 'Functions'
:
fn_bak() {
  : fn_bak

  # for each of multiple input files
  for loc_filename_a in "${@}"; do

    # test verifying existence of input
    if S_ test -f "${loc_filename_a}"; then

      # BUG: Why does this ^ test req sudo when this test \/ doesnt?

      # if the destination (.bak) file already exists,
      # then age it first.
      if [[ -f "${loc_filename_a}.bak" ]]; then
        
        if [[ -s "${loc_filename_a}.bak" ]]; then
          return
        else
          S_ rm -f -- "${loc_filename_a}.bak"
        fi
      fi

      # write a new .bak file
      S_ rsync -acq -- "${loc_filename_a}"{,.bak} \
        || I_

    # if input file DNE, then print an error and exit
    else
      { 
        echo WARNING: file DNE "${loc_filename_a}"
        return
      }
    fi
  done
  : 'END OF fn_bak'
  :
}
fn_erx() {
  # this assignment must be the first command
  local loc_exit_code="${?}"
  : fn_erx

  # print an error message and exit with the correct exit code
  echo -e Error: "${@}"
  : 'END OF fn_erx'
  :
  exit "${loc_exit_code}"
}
#fn_num() {
#  # Usage: N_ [raw arrays names]
#  : fn_num
#
#  # for each of multiple input array names
#  for loc_unquotd_array_nm_a in "${@}"; do
#
#    # set a local name reference variable
#    local -n loc_nameref_a="${loc_unquotd_array_nm_a}"
#
#    # and use the nameref to print the number of indices in the input array
#    echo ${#loc_nameref_a[@]}
#  done
#  : 'END OF fn_num'
#  :
#}
fn_usage() {
  # Usage:  fn_usage [exit-code]
  : fn_usage

  # print a usage message and exit with a pre-determined exit code
  cat <<- EOF
    ${repo_nm} - ${script_proper_nm}, version ${script_version}
    Find and scan shell scripts depending on severity level. 
        Usage:  ${script_nm} [-ehiw]
                -e error          -i info
                -h help           -w warning
    Only the first option is processed.

EOF
  : 'END OF fn_usage'
  :
  # shellcheck disable=SC2086
  exit "${1}"
}
fn_write_arrays() {
  # Usage: W_ [arrays]
  :
  : fn_write_arrays: Write each array to a file on disk.

  loc_write_d_b="${curr_time_ssubd}arrays"

  if [[ ! -d "${loc_write_d_b}" ]]; then
    S_ mkdir -p -- "${loc_write_d_b}" \
      || I_
  fi

  # for each of multiple input array names
  for loc_unquotd_array_nm_b in "${@}"; do
    
    # create local variables, for use as both array and string
    local -n loc_nameref_b="${loc_unquotd_array_nm_b}"
    loc_array_nm="${loc_unquotd_array_nm_b}"
    loc_write_f_b="${loc_write_d_b}/_${SC_severity:0:1}"
    loc_write_f_b="${loc_write_f_b}_${abbrev_rel_search_dirs}_${loc_array_nm}"

    # solved?  BUG: mixing variable and array. sb a nameref

    # Bug? When array correctly is empty. 'declare -p ... > /dev/null ||' ?

    # if the input array holds no data, then populate it
    if [[ ! -v loc_nameref_b[@] ]]; then
      loc_nameref_b=([0]='fn_write_arrays: Empty array')
      :
    fi
    :
    # then write a data file to disk
    declare -p "${loc_array_nm}" \
      | S_ T_ -- "${loc_write_f_b}" > /dev/null

    # write a backup of the new data file
    :
    B_ "${loc_write_f_b}"
  done
  : 'END OF fn_write_arrays'
  :
}
#fn_write_vars() {
#  # Usage: V_ [loc_script_section_nm] [raw variable names]
#
#  # first pos-parm is string used for differentiating filename
#  : fn_write_vars
#  loc_script_section_nm="${1}"
#  loc_write_f_a="${curr_time_ssubd}/${loc_script_section_nm}_vars"
#  shift
#
#  # if the destination file already exists, then return from FN
#  [[ -e "${loc_write_f_a}" ]] \
#    && return
#
#  # write a new data file
#  declare -p "${@}" 2>/dev/null \
#    | S_ T_ -- "${loc_write_f_a}" >/dev/null
#
#  # and write a .bak file
#  :
#  B_ "${loc_write_f_a}"
#  : END OF fn_write_vars
#  :
#}

:
: Use -sudo-
if ! S_ -v; then
  printf '\n\tValidation failed of user\x27s \x60sudo\x60 timestamp; '
  printf 'exiting.\n\n'
  L_
fi
:
# Set up a trap on signals "exit", "term" and "int"
# shellcheck disable=SC2154
trap '
  #set -
  :
  # [Trap] Delete all possible existing process directories. 
  for poss_lk_d in "${a_poss_proces_lock_dirs[@]}"; do 
    :
    # [Trap] Abbreviate variable, then test and delete lock directories.
    pl="${poss_lk_d}/${proc_lk_f_nm}"
    :
    if [[ -d "${pl}" ]] && [[ ! -L "${pl}" ]]; then 
      S_ rm -rf -- "${pl}" \
        || L_
    fi
  done
  :
  # [Trap] Remove any script-s ACL-s based on whether the canary variables
  # exist.
  if [[ -v acl_execd_setfacl ]]; then 
    : 
    if [[ -v acl_abs_path ]]; then 
      S_ setfacl -R -x "u:${UID}" -- "${acl_abs_path}" ||
        echo Error: trap: setfacl failed, line "${LINENO}"
      :
    # bug? Should this var be main_d \/ ? Sb erx ^ ?
      :
    elif [[ -v mountpoint ]]; then
      S_ setfacl -R -x "u:${UID}" -- "${mountpoint}" ||
        echo Error: trap: setfacl failed, line "${LINENO}"
    fi
  fi
  :
  trap - EXIT TERM INT
  kill -s INT "$$"
' EXIT TERM INT
:
#X_; :_

:
: 'Process lock'
:
# define basename and absolute path of the lock directory
random_n="${RANDOM}"
proc_lk_f_nm=".${repo_nm}.$$${random_n}.lock"
:
#:_; D_ a_poss_proces_lock_dirs
:
# from among the possible dirnames
for poss_lk_d in "${a_poss_proces_lock_dirs[@]}"; do
  :
  # use the first one that fulfills certain requirements
  if [[ -d "${poss_lk_d}" ]] \
    && [[ ! -L "${poss_lk_d}" ]] \
    && [[ -w "${poss_lk_d}" ]]; then
    :
    # define the lock directory
    process_lock_d="${poss_lk_d}/${proc_lk_f_nm}"
    break
  fi
done
:
# create the lock directory
if ! mkdir -m 0000 "${process_lock_d}" 2>/dev/null; then
  {
    printf '\n\tCannot acquire process lock: <%s>.\n' "${process_lock_d}"
    #printf '\tID: %s\n' "${USER}" # why?
    printf 'Exiting.\n\n'
  } 1>&2
  L_
fi
:
#:_; D_ process_lock_d; M_ -- "${process_lock_d}"; L_

:
: User variables
timecode="$(builtin printf '%(%F_%H%M%S)T')"
:

# SECTION B
:
#:_
#X_

# BUGs: Hardcoded $mountpoint; trailing backslash
:
: 'Assign varnames and paths for the data directories'
mountpoint=/run/media/root/29_Mar_2023
main_d="${mountpoint}/${script_dirnm}"
data_subd="${main_d}/latest_data"
curr_time_ssubd="${data_subd}/t_${timecode}/"
list_crunchbangs="${curr_time_ssubd}/crunchbangs"
found_scrpts_f="${list_crunchbangs}_found_scripts_${SC_severity:0:1}_${abbrev_rel_search_dirs}"
:
: 'data files'
a_write_path_nms=("${list_crunchbangs:=crunchbangs}" "/tmp/${list_crunchbangs##*/}")
:
# TODOs: grep scripts for 'todo's
#   - grep for 'shellcheck disable'
#   - This section seems buggy.

: 'Reduce use of sudo'
if [[ ! -r "${main_d}" ]]; then
  :
  mapfile -d / -t a_acl_name_indiv_dir <<< "${main_d}"
  :
  a_acl_name_indiv_dir[0]=/
  a_acl_name_indiv_dir[-1]="${a_acl_name_indiv_dir[-1]//$'\n'/}"
  :
  acl_each_dir="${#a_acl_name_indiv_dir[@]}"
  :
  for ((iterator_1 = 0; iterator_1 < acl_each_dir; iterator_1++)); do
    acl_abs_path+="/${a_acl_name_indiv_dir[iterator_1]}"
    acl_realpath="$(realpath -e "${acl_abs_path}")"
    :
    # Bug: why sudo? \/

    if S_ test -e -- "${acl_realpath}"; then
      : 'test succeeded: acl_realpath exists '
    else
      :
      : 'test failed: acl_realpath DNE'
      :
      if [[ ! -d "${acl_abs_path}" ]]; then
        :
        S_ mkdir -p -- "${main_d}" \
          || I_
      fi
      :
      acl_realpath="$(realpath -e "${acl_abs_path}" 2>/dev/null)"
      :
      #:_

      # TODO: use alias w namei

      #M_ -- "${acl_realpath}"
      :
    fi
    :
    if [[ -r "${acl_realpath}" ]]; then
      : 'test succeeded: acl_realpath is readable'
    else
      :
      : 'test failed: acl_realpath is not readable'
      :
      acl_execd_setfacl=y
      export acl_execd_setfacl # SC2034, while trap-s setfacl blk is #-d # this comment means what?
      :
      # readable up to the main_d
      S_ chmod -R 750 -- "${acl_realpath}" \
        || I_
        :
      S_ setfacl -d -m "${USER}:r-x" -- "${acl_realpath}" \
        || I_
        :
      S_ setfacl -m "${USER}:r-x" -- "${acl_realpath}" \
        || I_
        :
      #:_
      #id "${USER}"
      #groups "${USER}"
      #M_ -- "${acl_realpath}"
      #S_ getfacl -- "${acl_realpath}"
      :
      [[ -r "${acl_realpath}" ]] \
        || I_
    fi
  done
  :
  # writeable within the main_d
  S_ setfacl -d -m "${USER}:rwx" -- "${main_d}" \
    || I_
    :
  S_ setfacl -R -m "${USER}:rwx" -- "${main_d}" \
    || I_
    :
  #:_
  #id "${USER}"
  #groups "${USER}"
  #M_ -- "${main_d}"
  #S_ getfacl -- "${main_d}"
  :
fi
:
: 'make sure -data_subd- is a directory OR create the -data_subd- dir '
: 'if necessary'
[[ -d "${data_subd}" ]] \
  || mkdir "${data_subd}" # as liveuser
  :
#:_
#M_ -- "${data_subd}"
:
: Label the current data as -latest.-
# shellcheck disable=SC2312
mapfile -d '' -t a_previous_time_dirs < <(
  find "${data_subd}" -mindepth 1 -maxdepth 1 -type d -a \! -type l \
    -name 't_*' -print0
)
:
: if -prev_time_ssubd- is empty, delete it, otherwise -mv- it out
: of the -latest- dir
for prev_time_ssubd in "${a_previous_time_dirs[@]}"; do
  rmdir --ignore-fail-on-non-empty -- "${prev_time_ssubd}"
  :
  : of previous prev_time_ssubd
  if [[ -d "${prev_time_ssubd}" ]] && [[ ! -L "${prev_time_ssubd}" ]]; then
    S_ mv -- "${a_previous_time_dirs[@]}" "${main_d}"
  else
    continue
  fi
done
:
: of curr_time_ssubd
if [[ ! -d "${curr_time_ssubd}" ]]; then
  S_ mkdir -p -- "${curr_time_ssubd}" \
    || I_
fi
:
#:_
#M_ -- "${curr_time_ssubd}"
:
# SECTION C
:
: 'Gather filenames from local attached disk storage'
:
if [[ "${abbrev_rel_search_dirs}" == all ]]; then
  :
  : 'set a value for a_relevant_search_dirs and..'
  # shellcheck disable=SC2312
  mapfile -d '' -t a_relevant_search_dirs < <(
    S_ find / -mindepth 1 -maxdepth 1 -type d \! -empty \
      \( \! -name proc -a \! -name sys -a \! -iname "${script_dirnm}*" \) \
      -print0 2> /dev/null
  )
  :
  for sd in "${a_relevant_search_dirs[@]}"; do 

    # assign 
    echo "${sd}"
  done
  :
fi
:
: 'Find all files within the search area. Even the empty ones.'
# shellcheck disable=SC2312
mapfile -d '' -t a_all_files < <(
  S_ find "${a_relevant_search_dirs[@]}" -mindepth 1 -type f \
    -print0 2> /dev/null
)
:
: 'Sort the original array and test it.'
# shellcheck disable=SC2312
mapfile -d '' -t a_all_files_sorted < <(
  printf '%s\0' "${a_all_files[@]}" \
    | sort -z
)
:
# SECTION D
:
# Bug? Can more indices and fewer files be used?
:
: 'Sort out the scripts, ie, any file beginning with a crashbang from'
: 'the rest of the files'
:
: 'Get the total number of found files, for the progress indicator'
# shellcheck disable=SC2034
total_count="$(printf "%'d" "${#a_all_files_sorted[@]}")"
unset IFS
:
[[ -f /tmp/"${list_crunchbangs##*/}" ]] \
  && S_ rm -f -- "/tmp/${list_crunchbangs##*/}"
:
# BUG: the search dirs must be the same, as well as the dnf tx number
# BUG: Use of /tmp/crunchbangs as yn on do loop q. Sb a set of file lists
#.   difftd by search dir / search type / etc. See file "priority"
:
: 'if the full list exists -- of files on disk which begin with'
: 'crashbangs -- skip the 30-90 minute search phase.'
if [[ ! -f "/tmp/${list_crunchbangs##*/}" ]] \
  || [[ -L "/tmp/${list_crunchbangs##*/}" ]]
then
  :

  for all_files_index in "${!a_all_files_sorted[@]}"; 
  do
    :
    : 'Loop'
    :
    loop_idx="$(printf "%'d" $((all_files_index + 1)) )"
    printf '%s of %s files\r' "${loop_idx}" "${total_count}"
    :
    : 'file must exist'
    each_sorted_f="${a_all_files_sorted[all_files_index]}"
    :
    if [[ ! -e "${each_sorted_f}" ]]; 
    then
      a_file_DNE+=([all_files_index]="${each_sorted_f}")
      continue
    fi
    :
    : 'list of empties'
    if [[ ! -s "${each_sorted_f}" ]]; 
    then
      a_empty_files+=([all_files_index]="${each_sorted_f}")
      continue
    fi
    :
    : '-file- magic'
    printf '+ %-8d: ' "${all_files_index}" \
      | S_ tee -a -- "${curr_time_ssubd}file_out" > /dev/null
      :
    file_o="$(S_ file -pk -- "${each_sorted_f}" 2>&1)" # Bug: needs erx
    file_o="${file_o%%64-bit LSB *}"
    a_bin_file_output+=([all_files_index]="${file_o}")
    :
    # Bug? Needs tracking index? One array or file, one line per fso,
    #. use symbols or csv to indicate test results, w common indices
    # Bug: [[ -n sb right after exec file

    if [[ -n "${file_o}" ]]; 
    then
      S_ tee -a -- "${curr_time_ssubd}file_out" <<< "${file_o}" > /dev/null
    else
      err_msg="WARNING: -file- produced 0 output:  <${each_sorted_f}>"
      S_ tee -a -- "${curr_time_ssubd}file_out" <<< "${err_msg}" > /dev/null
    fi
    :
    # Bug: keep `od` output in an array
    # Bug: avoid as many disk writes as possible. 
    #.  Write out only stats?
    # Bug: use indices to reference each type? Store array diffs btw loop?
    #. Time loss to disk io? Run file in parallel? Read each file once and
    #. use var for both od and file?
    :
    : 'two bytes each'
      :
      #X_; :_

      # fix?: mapfile -d '' -t -O "${all_files_index}" a_od_output

    od_o="$(S_ od -j 0 -N 2 -t x1z -v -- "${each_sorted_f}"\
      | tr -s ' ' \
      | awk '{ print $2, $3, $4 }' \
      | tr -d '\n' \
      || I_ "P:${PIPESTATUS[*]} I:${all_files_index} ${each_sorted_f}"
    )"
    :
    #D_ od_o
    :
    [[ -n "${od_o}" ]] \
      || I_ "I:${all_files_index} ${each_sorted_f}"
      :
    a_bin_od_output+=([all_files_index]="${od_o}")
      :
      #D_ a_bin_od_output
      :
    read -r byte_0 byte_1 printable_chars <<< "${od_o}" 
      :
      #D_ byte_0 byte_1 printable_chars a_all_other_files; L_;
      :
    export printable_chars # SC2034
      :
    : '-od_o- non-zero'
    if [[ -z "${byte_0}" ]]; 
    then
      I_ "I:${all_files_index} <${each_sorted_f}>" \
        '*unreachable code*'
    elif [[ "${byte_0}" == @(23|21) ]]; 
    then
      : 'compare hexadecimals'
      :
      : 'endianness'
      if [[ "${byte_0}${byte_1}" == 2123 ]]; 
      then
        a_incorrect_endianness+=([all_files_index]="${each_sorted_f}")
        :
      else
        :
        : 'Crunchbangs'

        # q, does strings recognize unicode? Color codes? Cr's? Etc
        # test dd vs strings

        strings_o="$(strings -n1 < "${each_sorted_f}" \
          | head -n1 \
          | cut -b -$((2**14)) \
          || I_ "P:${PIPESTATUS[*]} I:${all_files_index} ${each_sorted_f}")"
          :
        IFS= read -r first_line_printable <<< "${strings_o}" \
          || I_ "I:${all_files_index} ${each_sorted_f}"
          :
        : '-#!comment-'
        if [[ "${first_line_printable}" =~ ^'#!comment' ]]; 
        then
          a_crunches_with_hashbang_comments+=(
            [all_files_index]="${each_sorted_f}")
          continue
        fi
        :
        #D_ strings_o first_line_printable all_files_index each_sorted_f; L_;
        :
        #   Note: with only /bin/sbin, this if-fi block doesn't execute
        :

        # FR: sort also per-rpm, awk script, probably

        : 'outside of rpm'
        if ! rpm -qf "${each_sorted_f}" 2>/dev/null 1>&2; 
        then
          :
          : 'user or system'
          if [[ "${each_sorted_f}" = /@(root|home|run/media)/* ]]; 
          then
            a_non_rpm_user_crunches+=([all_files_index]="${each_sorted_f}")
            continue
          else
            a_non_rpm_system_crunches+=(
              [all_files_index]="${each_sorted_f}")
            continue
          fi
        fi
      fi
      :
      #X_; :_

      # scan non-shell scripts for shell escapes ie sys-bin calls
      # https://www.sans.org/blog/escaping-restricted-linux-shells/

      # Bug, "shell scripts" incls python perl etc

      # how to make IRT lists for each interpreter?
      :
      : 'Make an array of the relevant filenames and their crashbangs.'
      a_shell_scripts+=([all_files_index]="$(printf \
        "%'-12d %%=%%=%%=%% %-50s %%=%%=%%=%% %s\n" \
          "${all_files_index}" "${first_line_printable}" \
          "${each_sorted_f}")"
        )
      :
      #:_; D_ a_shell_scripts all_files_index first_line_printable each_sorted_f; L_
    else
      :
      : 'all others'
      a_all_other_files+=([all_files_index]="$(printf \
        "%'-12d %%=%%=%%=%% %s\n" "${all_files_index}" \
          "${each_sorted_f}")"
        )
    fi
  done
  :
  #X_; :_; D_ a_shell_scripts all_files_index first_line_printable each_sorted_f; L_

  # Note, you want to see the full crunchbangs in printed ASCII form
  :
  : 'Open a timestamped file and append into it the list of filenames' 
  : 'and their crashbangs.'
  :
  : 'Exporting is necessary of the array names from the above scan'
  a_arrays=( a_all_files a_all_files_sorted a_file_DNE a_empty_files a_bin_file_output a_bin_od_output a_incorrect_endianness a_crunches_with_hashbang_comments a_non_rpm_user_crunches a_non_rpm_system_crunches a_shell_scripts a_all_other_files a_write_path_nms )
  export  "${a_arrays[@]}"
  :
  W_ "${a_arrays[@]}"; 
  B_ "${curr_time_ssubd}/file_out"; 
  #L_;
  :
  : 'if any data files already exist, keep them'
  for any_existing_f in "${a_write_path_nms[@]}"; do
    :
    if [[ -f "${any_existing_f}" ]] && [[ ! -L "${any_existing_f}" ]]; then
      S_ mv -- "${any_existing_f}" "${any_existing_f}.${$}.${random_n}" \
        || I_
    fi
  done
  :
  : 'create the original list_crunchbangs'
  S_ touch -- "${a_write_path_nms[@]}"
  :
  : 'write a file header'
  {
    printf '# crunchbangs -- %s\n' "${timecode%-*}"
    printf '# %s\n' "$(declare -p a_relevant_search_dirs)"
  } | S_ T_ -- "${a_write_path_nms[@]}" > /dev/null
  :
  : 'printing contents of a_shell_scripts array, with backup'
  printf '%s\n' "${a_shell_scripts[@]}" \
    | S_ T_ -a -- "${a_write_path_nms[@]}" > /dev/null
  B_ "${a_write_path_nms[@]}"
  :
else
  :
  # the time_dir needs a copy of the crunchbangs file, also.  copy it in
  # from the hopefully correct backup in /tmp
  if [[ ! -f "${list_crunchbangs}" ]]; 
  then
    S_ rsync -ca -- "/tmp/${list_crunchbangs##*/}" "${list_crunchbangs}" \
      || I_
  fi
fi
:
W_ a_write_path_nms; 
:
#X_; :_; 
S_ head -- "/tmp/${list_crunchbangs##*/}"; 
#L_;
:

:
: 'Verify inter^preters'
:
: 'Get the list of interpreters from the list of crunchbangs.'
#   Note: new indices starting from 0
# shellcheck disable=SC2016
mapfile -t a_interpreters < <( 
  S_ awk 'BEGIN { FS = "%=%=%=%" } ; /#!/ { print $2 }' -- \
    "/tmp/${list_crunchbangs##*/}" \
    | awk 'BEGIN { FS = " -" } ; { print $1 }' \
    | sed 's, *,,g' \
    | sort -u \
    | cut -b3- \
    || I_ "P:${PIPESTATUS[*]}"
  )
:
:_; D_ a_interpreters; 
#L_
:
: 'Ways to find an interpreter if it-s available on disk:'
:
# Bug: `realpath -e` and `command -v` are redundant
:
for program in "${a_interpreters[@]}"; do
  : 'command -pv'
  command_o="$(command -pv "${program}" 2>&1)"
  
  if [[ -n "${command_o}" ]]; then 
    realpath_o="$(realpath -e "${command_o}" 2> /dev/null)"
    
    if [[ -f "${realpath_o}" ]]; then 
      a_interps_rps+=("${realpath_o}")
      m="exists on disk"; 
      break
    fi
  fi
done  

#   Note: new indices starting from 0
mapfile -t a_interps_rps < <(
  S_ realpath -e -- "${a_interpreters[@]}" \
    | sort -u
  )
:
D_ a_interps_rps; L_
{
for b in "${!a_interps_rps[@]}"; do 
  printf '%-32s' "${a_interps_rps[b]}"; 
  :
  if command -pv "${a_interps_rps[b]}" > /dev/null; then 
    m="exists on disk"; 
  else 
    m="DNE on disk"; 
  fi; 
  :
  a_interps_disk_repo+=([b]="${b} : ${a_interps_rps[b]} : ${m}")
  printf '%-8s' "${m}"; 
  :
  dnf_po="$( S_ dnf provides -- "${a_interps_rps[b]}" \
    | awk '/x86_64|i686/ { print $1 }' \
    | sort -u 
    )"; 
    :
  if [[ -n "$dnf_po" ]]; then 
    m="exists in repos"; 
  else 
    m="DNE in repos"; 
  fi;
  :
  a_interps_disk_repo+=([b+100]="${b} : ${a_interps_rps[b]} : ${m}")
  printf '\t\t\t\t%s\n' "${m}"; 
  printf '%s\n' "$dnf_po"; 
  unset dnf_po; 
  :
done
} | S_ T_ -a -- "${curr_time_ssubd}a_interpreters" > /dev/null
:
#X_; :_; 
W_ a_write_path_nms a_interpreters a_interps_rps a_interps_disk_repo
L_
:

:
# SECTION E
:
: 'CENTRAL TASK, 1 OF 2: Filter the list of crashbangs with the list'
: 'of shells.'
:
: 'file header'
{
  printf '# SC-scrpts-list -- %s\n' "${timecode%-*}"
  printf '# %s\n' "$(D_ a_relevant_search_dirs)"
} | S_ T_ -- "${list_crunchbangs}_SC-scrpts-list" > /dev/null
:
# pulls from time_dir
S_ grep -E -- '/bin/'"${SC_shells}"'.*%=%=%=%' "${list_crunchbangs}" \
  | S_ tee -a -- "${list_crunchbangs}_SC-scrpts-list" \
  || I_
:
B_ "${list_crunchbangs}_SC-scrpts-list" /tmp/*_SC-scrpts-list
:
S_ rsync -ca -- "${list_crunchbangs}_SC-scrpts-list" /tmp \
  || I_
:
B_ "${list_crunchbangs}_SC-scrpts-list" /tmp/*_SC-scrpts-list
:
X_; :_; W_ timecode list_crunchbangs SC_shells 
L_
:

:
: 'CENTRAL TASK, 2 of 2: with ShellCheck scan each script for errors'
:
# TODO: keep "$all_files_index" tracked with content all the way through
#   into the "_found_scripts" file
# Bug? line 1 of script could contain percent symbols
:
: 'A hell world of pipelines'
#   Q: how to translate the correct newlines into nulls to separate the 
#   filenames when reading from a file?  awk? files _can_ contain \n-s
:
grep_o="$(S_ grep ^'#!' -- "${list_crunchbangs}_SC-scrpts-list")"
:
cut_o="$(cut -d '%' -f5- <<< "${grep_o}")"
:
mapfile -t a_each_abspath_scriptnm <<< "${cut_o}"
:
a_each_abspath_scriptnm=("${a_each_abspath_scriptnm[@]##* }")
:
# Wk: awk , multi-char delim, remv lead+trail wspc - redef $0 ?, printf
#   grep -Eo | tr
# Bug: rename variable "$c" below
# Bug: why sort by line count? More text, more bugs? How to prior mult
#   factors?
:
wc_o="$(S_ wc -l -- "${a_each_abspath_scriptnm[@]}")"
:
wc_o="${wc_o%$'\n*'}" # Remove 'totals' line.
:
sort_o="$(sort -gr <<< "${wc_o}")"
:
awk_o="$(awk '{ print $2 }' <<< "${sort_o}")"
:
mapfile -t a_each_script_list_sorted_by_linect \
  <<< "${awk_o}" # ie properly
:
found_scrpts_f="${list_crunchbangs}_found_scripts_${SC_severity:0:1}_${abbrev_rel_search_dirs}"
iterator_2=0
:
# Bug? 1st grep extra?
:
{
  :
  for sorted_script in "${!a_each_script_list_sorted_by_linect[@]}"; do
    :
    mapfile -d '' -t a_each_script_SC_results < <(
      shellcheck -S "${SC_severity}" \
        "${a_each_script_list_sorted_by_linect[sorted_script]}" \
        | grep -Fv 'shellcheck.net' \
        | grep -Eo "SC[0-9]{4}.*" \
        | cut -b -64 \
        | sort -g \
        | uniq -c \
        | sort -k3 \
        || I_ "P:${PIPESTATUS[*]} I: S:" # index and script name
              # end of pipe intended 
      printf '\0'
    )
    :
    if [[ -n "${a_each_script_SC_results[*]:0:1}" ]]; then
      printf '\n%-4d%s\n' $((iterator_2++)) \
        "${a_each_script_list_sorted_by_linect[sorted_script]}"
      printf '%s' "${a_each_script_SC_results[@]}"
    fi
  done
} | S_ tee -a -- "${found_scrpts_f}" > /dev/null
:

: 'Write semi-permanent archives'
:
B_ "${found_scrpts_f}"
S_ rsync -ca -- "${found_scrpts_f}" "${main_d}" \
  || I_
S_ rsync -ca -- "${found_scrpts_f}" /tmp \
  || I_
  :
B_ "${main_d}/${found_scrpts_f##*/}"
:
B_ "/tmp/${found_scrpts_f##*/}"
:
: 'Print some usable variables'
z=0
for d in "${curr_time_ssubd}" "${main_d}" /tmp; do 
  printf '\n\t data_d_%d=%s\n' $((z++)) "${d}"
done
:
trap - EXIT
exit 00
