#!/bin/bash
# get-filename-extensions-sh
# shellcheck disable=SC1090
# written in bash 5.1

    # get filename extensions from output of find-and-scan-shell-scripts-sh
    # for constructing the regex filter "$f" in said script

unset {a..z} {A..Z}
m="${TEMPDIR:="$HOME"}" # <m>ountpoint
t="$( builtin printf '%(%F_%H%M%S)T\n' )" # <t>ime
declare -p m t

_erx(){ 
  local ec=$?
  echo Error: "$@"
  exit "$ec"
}

# find data files from find-and-scan-shell-scripts-sh
mapfile -d '' -t data_files < <( 
  find / -type f -name '*_remaining_files' -print0 2> /dev/null )

# get latest data file and `source` it (function from libera IRC)
for i in "${!data_files[@]}"; do
  [[ "${data_files[$i]}" -nt "$latest" ]] && 
    latest="${data_files[$i]}"
done
. "$latest" || _erx $LINENO
[[ -z "${all_files[*]:1:1}" ]] && _erx $LINENO 
all_files=( "${all_files[@]}" )

# get files that have filename extensions and that aren't shell scripts
for i in "${!all_files[@]}"; do
  
  # necc inside a loop
  unset n x y hex_bits
  
  # <n>ameref (sort of)
  n="${all_files[$i]}" 
  
  # must contain a period
  if ! [[ "${n##*/}" =~ \. ]]; then
    unset 'all_files[$i]'
    continue
  fi  
  
  # file must exist
  if [[ ! -e "$n" ]]; then 
    unset 'all_files[$i]'
    continue
  fi  

  # effectivel<y> `basename`
  y="${n##*/}" 
  
  # rename dotfiles in RAM
  if [[ "${y:0:1}" == '.'  ]]; then 
    y="${y:1}"; 
  fi  

  # get the filename's e<x>tension
  x="${y##*.}" 
  
  # no change = no extension
  if [[ "$y" == "$x" ]]; then 
    unset 'all_files[$i]'
    continue
  fi  

  # read from disk in binary the first two bytes of every remaining file  
  # in the list, and format it in <h>exadecimal. (`od`: POSIX 2008)
  mapfile -d '' -t hex_bits < <(  
    od -Ax0 -N2 -x "$n" |
      tr -s ' \n\t' '\0' )

  # compare the <h>exidecimal representations to find any <c>runchbangs
  if [[ "${hex_bits[1]}" == '2123' ]]; then
  
    # discard the <c>runchbangs
    unset 'all_files[$i]'
    continue
  else
    
    # gather more info on the other file types
    file -p "$n" >> "${m}/${t}_B_file_o" ;
    
    # especially their filename extensions
    printf '<%s> <%s> \n' "$x" "$n" >> "${m}/${t}_B_extensions" ; 
  fi;

  unset 'all_files[$i]'
  continue
done

# process the results, ie, into a form usable by said other script
mapfile -t common_extensions < <( 
  awk '{ print $1 }' "${m}/${t}_B_extensions" | 
    tr -d '<>' | 
    sort | 
    uniq -c | 
    sort -gr | 
    awk '( $1 >= 100 ) { print $2 }' |
    sort ); # the horror!
common_extensions+=( 7z bz2 gz info jpeg json mp4 png sqlite swp tar upp zip )

# print the regex / variable assignment for find-and-scan-shell-scripts-sh
printf 'f=(%s' "${common_extensions[0]}"
for e in "${common_extensions[@]}"; do
  printf '|%s' "$e"; 
done
printf ')\n'

exit
